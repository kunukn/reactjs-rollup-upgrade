"use strict";

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

// TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

{
  throw new Error(
    "React Refresh runtime should not be included in the production bundle."
  );
} // In old environments, we'll leak previous types after every edit.

var didSomeRootFailOnMount = false;

function performReactRefresh() {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function register(type, id) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function setSignature(type, key) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
} // This is lazily called during first render for a type.
// It captures Hook list at that time so inline requires don't break comparisons.

function collectCustomHooksForSignature(type) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function getFamilyByID(id) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function getFamilyByType(type) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function findAffectedHostInstances(families) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function injectIntoGlobalHook(globalObject) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function hasUnrecoverableErrors() {
  return didSomeRootFailOnMount;
} // Exposed for testing.

function _getMountedRootCount() {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
} // This is a wrapper over more primitive functions for setting signature.
// Signatures let us decide whether the Hook order has changed on refresh.
//
// This function is intended to be used as a transform target, e.g.:
// var _s = createSignatureFunctionForTransform()
//
// function Hello() {
//   const [foo, setFoo] = useState(0);
//   const value = useCustomHook();
//   _s(); /* Second call triggers collecting the custom Hook list.
//          * This doesn't happen during the module evaluation because we
//          * don't want to change the module order with inline requires.
//          * Next calls are noops. */
//   return <h1>Hi</h1>;
// }
//
// /* First call specifies the signature: */
// _s(
//   Hello,
//   'useState{[foo, setFoo]}(0)',
//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
// );

function createSignatureFunctionForTransform() {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}
function isLikelyComponentType(type) {
  {
    throw new Error(
      "Unexpected call to React Refresh in a production environment."
    );
  }
}

var ReactFreshRuntime = {
  performReactRefresh: performReactRefresh,
  register: register,
  setSignature: setSignature,
  collectCustomHooksForSignature: collectCustomHooksForSignature,
  getFamilyByID: getFamilyByID,
  getFamilyByType: getFamilyByType,
  findAffectedHostInstances: findAffectedHostInstances,
  injectIntoGlobalHook: injectIntoGlobalHook,
  hasUnrecoverableErrors: hasUnrecoverableErrors,
  _getMountedRootCount: _getMountedRootCount,
  createSignatureFunctionForTransform: createSignatureFunctionForTransform,
  isLikelyComponentType: isLikelyComponentType
};

// This is hacky but makes it work with both Rollup and Jest.

var runtime = ReactFreshRuntime.default || ReactFreshRuntime;

module.exports = runtime;

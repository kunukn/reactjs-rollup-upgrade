/** @license React vundefined
 * react-dom-test-utils.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";
(function(global, factory) {
  "object" === typeof exports && "undefined" !== typeof module
    ? (module.exports = factory(require("react"), require("react-dom")))
    : "function" === typeof define && define.amd
      ? define(["react", "react-dom"], factory)
      : ((global = global || self),
        (global.ReactTestUtils = factory(global.React, global.ReactDOM)));
})(this, function(React, ReactDOM) {
  function ReactErrorProd(error) {
    for (
      var code = error.message,
        url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code,
        i = 1;
      i < arguments.length;
      i++
    )
      url += "&args[]=" + encodeURIComponent(arguments[i]);
    error.message =
      "Minified React error #" +
      code +
      "; visit " +
      url +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ";
    return error;
  }
  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (fiber.alternate) for (; node.return; ) node = node.return;
    else {
      if (0 !== (node.effectTag & 2)) return 1;
      for (; node.return; )
        if (((node = node.return), 0 !== (node.effectTag & 2))) return 1;
    }
    return 3 === node.tag ? 2 : 3;
  }
  function assertIsMounted(fiber) {
    if (2 !== isFiberMountedImpl(fiber)) throw ReactErrorProd(Error(188));
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = isFiberMountedImpl(fiber);
      if (3 === alternate) throw ReactErrorProd(Error(188));
      return 1 === alternate ? null : fiber;
    }
    for (var a = fiber, b = alternate; ; ) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b = parentA.return;
        if (null !== b) {
          a = b;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB; ) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw ReactErrorProd(Error(188));
      }
      if (a.return !== b.return) (a = parentA), (b = parentB);
      else {
        for (var didFindChild = !1, _child = parentA.child; _child; ) {
          if (_child === a) {
            didFindChild = !0;
            a = parentA;
            b = parentB;
            break;
          }
          if (_child === b) {
            didFindChild = !0;
            b = parentA;
            a = parentB;
            break;
          }
          _child = _child.sibling;
        }
        if (!didFindChild) {
          for (_child = parentB.child; _child; ) {
            if (_child === a) {
              didFindChild = !0;
              a = parentB;
              b = parentA;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentB;
              a = parentA;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) throw ReactErrorProd(Error(189));
        }
      }
      if (a.alternate !== b) throw ReactErrorProd(Error(190));
    }
    if (3 !== a.tag) throw ReactErrorProd(Error(188));
    return a.stateNode.current === a ? fiber : alternate;
  }
  function functionThatReturnsTrue() {
    return !0;
  }
  function functionThatReturnsFalse() {
    return !1;
  }
  function SyntheticEvent(
    dispatchConfig,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this.dispatchConfig = dispatchConfig;
    this._targetInst = targetInst;
    this.nativeEvent = nativeEvent;
    dispatchConfig = this.constructor.Interface;
    for (var propName in dispatchConfig)
      dispatchConfig.hasOwnProperty(propName) &&
        ((targetInst = dispatchConfig[propName])
          ? (this[propName] = targetInst(nativeEvent))
          : "target" === propName
            ? (this.target = nativeEventTarget)
            : (this[propName] = nativeEvent[propName]));
    this.isDefaultPrevented = (null != nativeEvent.defaultPrevented
    ? nativeEvent.defaultPrevented
    : !1 === nativeEvent.returnValue)
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
    if (this.eventPool.length) {
      var instance = this.eventPool.pop();
      this.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
      return instance;
    }
    return new this(dispatchConfig, targetInst, nativeEvent, nativeInst);
  }
  function releasePooledEvent(event) {
    if (!(event instanceof this)) throw ReactErrorProd(Error(279));
    event.destructor();
    10 > this.eventPool.length && this.eventPool.push(event);
  }
  function addEventPoolingTo(EventConstructor) {
    EventConstructor.eventPool = [];
    EventConstructor.getPooled = getPooledEvent;
    EventConstructor.release = releasePooledEvent;
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName],
      styleProp;
    for (styleProp in prefixMap)
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
        return (prefixedEventNames[eventName] = prefixMap[styleProp]);
    return eventName;
  }
  function flushWorkAndMicroTasks(onDone) {
    try {
      flushWork(),
        enqueueTask$1(function() {
          flushWork() ? flushWorkAndMicroTasks(onDone) : onDone();
        });
    } catch (err) {
      onDone(err);
    }
  }
  function Event(suffix) {}
  function findAllInRenderedFiberTreeInternal(fiber, test) {
    if (!fiber) return [];
    fiber = findCurrentFiberUsingSlowPath(fiber);
    if (!fiber) return [];
    for (var node = fiber, ret = []; ; ) {
      if (
        5 === node.tag ||
        6 === node.tag ||
        1 === node.tag ||
        0 === node.tag
      ) {
        var publicInst = node.stateNode;
        test(publicInst) && ret.push(publicInst);
      }
      if (node.child) (node.child.return = node), (node = node.child);
      else {
        if (node === fiber) return ret;
        for (; !node.sibling; ) {
          if (!node.return || node.return === fiber) return ret;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
  }
  function validateClassInstance(inst, methodName) {
    if (inst && !inst._reactInternalFiber) {
      var stringified = "" + inst;
      inst = Array.isArray(inst)
        ? "an array"
        : inst && 1 === inst.nodeType && inst.tagName
          ? "a DOM node"
          : "[object Object]" === stringified
            ? "object with keys {" + Object.keys(inst).join(", ") + "}"
            : stringified;
      throw ReactErrorProd(Error(286), methodName, inst);
    }
  }
  function makeSimulator(eventType) {
    return function(domNode, eventData) {
      if (React.isValidElement(domNode)) throw ReactErrorProd(Error(228));
      if (ReactTestUtils.isCompositeComponent(domNode))
        throw ReactErrorProd(Error(229));
      var dispatchConfig = eventNameDispatchConfigs$1[eventType],
        fakeNativeEvent = new Event();
      fakeNativeEvent.target = domNode;
      fakeNativeEvent.type = eventType.toLowerCase();
      var targetInst = getInstanceFromNode$1(domNode),
        event = new SyntheticEvent(
          dispatchConfig,
          targetInst,
          fakeNativeEvent,
          domNode
        );
      event.persist();
      _assign(event, eventData);
      dispatchConfig.phasedRegistrationNames
        ? accumulateTwoPhaseDispatches$1(event)
        : accumulateDirectDispatches$1(event);
      ReactDOM.unstable_batchedUpdates(function() {
        enqueueStateRestore$1(domNode);
        runEventsInBatch$1(event);
      });
      restoreStateIfNeeded$1();
    };
  }
  function makeNativeSimulator(eventType, topLevelType) {
    return function(domComponentOrNode, nativeEventData) {
      var fakeNativeEvent = new Event(eventType);
      _assign(fakeNativeEvent, nativeEventData);
      ReactTestUtils.isDOMComponent(domComponentOrNode)
        ? ((domComponentOrNode = findDOMNode(domComponentOrNode)),
          (fakeNativeEvent.target = domComponentOrNode),
          dispatchEvent$1(topLevelType, 1, fakeNativeEvent))
        : domComponentOrNode.tagName &&
          ((fakeNativeEvent.target = domComponentOrNode),
          dispatchEvent$1(topLevelType, 1, fakeNativeEvent));
    };
  }
  var _assign = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
    ReactSharedInternals =
      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher") ||
    (ReactSharedInternals.ReactCurrentDispatcher = { current: null });
  ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig") ||
    (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null });
  _assign(SyntheticEvent.prototype, {
    preventDefault: function() {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function() {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function() {
      this.isPersistent = functionThatReturnsTrue;
    },
    isPersistent: functionThatReturnsFalse,
    destructor: function() {
      var Interface = this.constructor.Interface,
        propName;
      for (propName in Interface) this[propName] = null;
      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      this.isPropagationStopped = this.isDefaultPrevented = functionThatReturnsFalse;
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });
  SyntheticEvent.Interface = {
    type: null,
    target: null,
    currentTarget: function() {
      return null;
    },
    eventPhase: null,
    bubbles: null,
    cancelable: null,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: null,
    isTrusted: null
  };
  SyntheticEvent.extend = function(Interface) {
    function Class() {
      return Super.apply(this, arguments);
    }
    var Super = this,
      E = function() {};
    E.prototype = Super.prototype;
    E = new E();
    _assign(E, Class.prototype);
    Class.prototype = E;
    Class.prototype.constructor = Class;
    Class.Interface = _assign({}, Super.Interface, Interface);
    Class.extend = Super.extend;
    addEventPoolingTo(Class);
    return Class;
  };
  addEventPoolingTo(SyntheticEvent);
  var canUseDOM = !(
      "undefined" === typeof window ||
      "undefined" === typeof window.document ||
      "undefined" === typeof window.document.createElement
    ),
    vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    },
    prefixedEventNames = {},
    style = {};
  canUseDOM &&
    ((style = document.createElement("div").style),
    "AnimationEvent" in window ||
      (delete vendorPrefixes.animationend.animation,
      delete vendorPrefixes.animationiteration.animation,
      delete vendorPrefixes.animationstart.animation),
    "TransitionEvent" in window ||
      delete vendorPrefixes.transitionend.transition);
  canUseDOM = getVendorPrefixedEventName("animationend");
  var TOP_ANIMATION_ITERATION = getVendorPrefixedEventName(
      "animationiteration"
    ),
    TOP_ANIMATION_START = getVendorPrefixedEventName("animationstart"),
    TOP_TRANSITION_END = getVendorPrefixedEventName("transitionend");
  try {
    var requireString = ("require" + Math.random()).slice(0, 7);
    var enqueueTask = (module && module[requireString])("timers").setImmediate;
  } catch (_err) {
    enqueueTask = function(callback) {
      var channel = new MessageChannel();
      channel.port1.onmessage = callback;
      channel.port2.postMessage(void 0);
    };
  }
  var enqueueTask$1 = enqueueTask;
  enqueueTask =
    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler
      .unstable_flushAllWithoutAsserting;
  requireString =
    ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;
  var flushPassiveEffects = requireString[11],
    IsThisRendererActing = requireString[12],
    batchedUpdates = ReactDOM.unstable_batchedUpdates,
    IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing,
    isSchedulerMocked = "function" === typeof enqueueTask,
    flushWork =
      enqueueTask ||
      function() {
        for (var didFlushWork = !1; flushPassiveEffects(); ) didFlushWork = !0;
        return didFlushWork;
      },
    actingUpdatesScopeDepth = 0,
    didWarnAboutUsingActInProd = !1,
    findDOMNode = ReactDOM.findDOMNode;
  ReactSharedInternals =
    ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events;
  var getInstanceFromNode$1 = ReactSharedInternals[0],
    eventNameDispatchConfigs$1 = ReactSharedInternals[4],
    accumulateTwoPhaseDispatches$1 = ReactSharedInternals[5],
    accumulateDirectDispatches$1 = ReactSharedInternals[6],
    enqueueStateRestore$1 = ReactSharedInternals[7],
    restoreStateIfNeeded$1 = ReactSharedInternals[8],
    dispatchEvent$1 = ReactSharedInternals[9],
    runEventsInBatch$1 = ReactSharedInternals[10],
    hasWarnedAboutDeprecatedMockComponent = !1,
    ReactTestUtils = {
      renderIntoDocument: function(element) {
        var div = document.createElement("div");
        return ReactDOM.render(element, div);
      },
      isElement: function(element) {
        return React.isValidElement(element);
      },
      isElementOfType: function(inst, convenienceConstructor) {
        return (
          React.isValidElement(inst) && inst.type === convenienceConstructor
        );
      },
      isDOMComponent: function(inst) {
        return !(!inst || 1 !== inst.nodeType || !inst.tagName);
      },
      isDOMComponentElement: function(inst) {
        return !!(inst && React.isValidElement(inst) && inst.tagName);
      },
      isCompositeComponent: function(inst) {
        return ReactTestUtils.isDOMComponent(inst)
          ? !1
          : null != inst &&
              "function" === typeof inst.render &&
              "function" === typeof inst.setState;
      },
      isCompositeComponentWithType: function(inst, type) {
        return ReactTestUtils.isCompositeComponent(inst)
          ? inst._reactInternalFiber.type === type
          : !1;
      },
      findAllInRenderedTree: function(inst, test) {
        validateClassInstance(inst, "findAllInRenderedTree");
        return inst
          ? findAllInRenderedFiberTreeInternal(inst._reactInternalFiber, test)
          : [];
      },
      scryRenderedDOMComponentsWithClass: function(root, classNames) {
        validateClassInstance(root, "scryRenderedDOMComponentsWithClass");
        return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
          if (ReactTestUtils.isDOMComponent(inst)) {
            var className = inst.className;
            "string" !== typeof className &&
              (className = inst.getAttribute("class") || "");
            var classList = className.split(/\s+/);
            if (!Array.isArray(classNames)) {
              if (void 0 === classNames) throw ReactErrorProd(Error(11));
              classNames = classNames.split(/\s+/);
            }
            return classNames.every(function(name) {
              return -1 !== classList.indexOf(name);
            });
          }
          return !1;
        });
      },
      findRenderedDOMComponentWithClass: function(root, className) {
        validateClassInstance(root, "findRenderedDOMComponentWithClass");
        root = ReactTestUtils.scryRenderedDOMComponentsWithClass(
          root,
          className
        );
        if (1 !== root.length)
          throw Error(
            "Did not find exactly one match (found: " +
              root.length +
              ") for class:" +
              className
          );
        return root[0];
      },
      scryRenderedDOMComponentsWithTag: function(root, tagName) {
        validateClassInstance(root, "scryRenderedDOMComponentsWithTag");
        return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
          return (
            ReactTestUtils.isDOMComponent(inst) &&
            inst.tagName.toUpperCase() === tagName.toUpperCase()
          );
        });
      },
      findRenderedDOMComponentWithTag: function(root, tagName) {
        validateClassInstance(root, "findRenderedDOMComponentWithTag");
        root = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
        if (1 !== root.length)
          throw Error(
            "Did not find exactly one match (found: " +
              root.length +
              ") for tag:" +
              tagName
          );
        return root[0];
      },
      scryRenderedComponentsWithType: function(root, componentType) {
        validateClassInstance(root, "scryRenderedComponentsWithType");
        return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
          return ReactTestUtils.isCompositeComponentWithType(
            inst,
            componentType
          );
        });
      },
      findRenderedComponentWithType: function(root, componentType) {
        validateClassInstance(root, "findRenderedComponentWithType");
        root = ReactTestUtils.scryRenderedComponentsWithType(
          root,
          componentType
        );
        if (1 !== root.length)
          throw Error(
            "Did not find exactly one match (found: " +
              root.length +
              ") for componentType:" +
              componentType
          );
        return root[0];
      },
      mockComponent: function(module, mockTagName) {
        hasWarnedAboutDeprecatedMockComponent ||
          (hasWarnedAboutDeprecatedMockComponent = !0);
        mockTagName = mockTagName || module.mockTagName || "div";
        module.prototype.render.mockImplementation(function() {
          return React.createElement(mockTagName, null, this.props.children);
        });
        return this;
      },
      nativeTouchData: function(x, y) {
        return { touches: [{ pageX: x, pageY: y }] };
      },
      Simulate: null,
      SimulateNative: {},
      act: function(callback) {
        function onDone() {
          actingUpdatesScopeDepth--;
          IsSomeRendererActing.current = previousIsSomeRendererActing;
          IsThisRendererActing.current = previousIsThisRendererActing;
        }
        !1 === didWarnAboutUsingActInProd &&
          ((didWarnAboutUsingActInProd = !0),
          console.error(
            "act(...) is not supported in production builds of React, and might not behave as expected."
          ));
        actingUpdatesScopeDepth++;
        var previousIsSomeRendererActing = IsSomeRendererActing.current;
        var previousIsThisRendererActing = IsThisRendererActing.current;
        IsSomeRendererActing.current = !0;
        IsThisRendererActing.current = !0;
        try {
          var result = batchedUpdates(callback);
        } catch (error) {
          throw (onDone(), error);
        }
        if (
          null !== result &&
          "object" === typeof result &&
          "function" === typeof result.then
        )
          return {
            then: function(resolve, reject) {
              result.then(
                function() {
                  1 < actingUpdatesScopeDepth ||
                  (!0 === isSchedulerMocked &&
                    !0 === previousIsSomeRendererActing)
                    ? (onDone(), resolve())
                    : flushWorkAndMicroTasks(function(err) {
                        onDone();
                        err ? reject(err) : resolve();
                      });
                },
                function(err) {
                  onDone();
                  reject(err);
                }
              );
            }
          };
        try {
          1 !== actingUpdatesScopeDepth ||
            (!1 !== isSchedulerMocked && !1 !== previousIsSomeRendererActing) ||
            flushWork(),
            onDone();
        } catch (err) {
          throw (onDone(), err);
        }
        return {
          then: function(resolve) {
            resolve();
          }
        };
      }
    };
  (function() {
    ReactTestUtils.Simulate = {};
    for (var eventType in eventNameDispatchConfigs$1)
      ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
  })();
  [
    ["abort", "abort"],
    [canUseDOM, "animationEnd"],
    [TOP_ANIMATION_ITERATION, "animationIteration"],
    [TOP_ANIMATION_START, "animationStart"],
    ["blur", "blur"],
    ["canplaythrough", "canPlayThrough"],
    ["canplay", "canPlay"],
    ["cancel", "cancel"],
    ["change", "change"],
    ["click", "click"],
    ["close", "close"],
    ["compositionend", "compositionEnd"],
    ["compositionstart", "compositionStart"],
    ["compositionupdate", "compositionUpdate"],
    ["contextmenu", "contextMenu"],
    ["copy", "copy"],
    ["cut", "cut"],
    ["dblclick", "doubleClick"],
    ["dragend", "dragEnd"],
    ["dragenter", "dragEnter"],
    ["dragexit", "dragExit"],
    ["dragleave", "dragLeave"],
    ["dragover", "dragOver"],
    ["dragstart", "dragStart"],
    ["drag", "drag"],
    ["drop", "drop"],
    ["durationchange", "durationChange"],
    ["emptied", "emptied"],
    ["encrypted", "encrypted"],
    ["ended", "ended"],
    ["error", "error"],
    ["focus", "focus"],
    ["input", "input"],
    ["keydown", "keyDown"],
    ["keypress", "keyPress"],
    ["keyup", "keyUp"],
    ["loadstart", "loadStart"],
    ["loadstart", "loadStart"],
    ["load", "load"],
    ["loadeddata", "loadedData"],
    ["loadedmetadata", "loadedMetadata"],
    ["mousedown", "mouseDown"],
    ["mousemove", "mouseMove"],
    ["mouseout", "mouseOut"],
    ["mouseover", "mouseOver"],
    ["mouseup", "mouseUp"],
    ["paste", "paste"],
    ["pause", "pause"],
    ["play", "play"],
    ["playing", "playing"],
    ["progress", "progress"],
    ["ratechange", "rateChange"],
    ["scroll", "scroll"],
    ["seeked", "seeked"],
    ["seeking", "seeking"],
    ["selectionchange", "selectionChange"],
    ["stalled", "stalled"],
    ["suspend", "suspend"],
    ["textInput", "textInput"],
    ["timeupdate", "timeUpdate"],
    ["toggle", "toggle"],
    ["touchcancel", "touchCancel"],
    ["touchend", "touchEnd"],
    ["touchmove", "touchMove"],
    ["touchstart", "touchStart"],
    [TOP_TRANSITION_END, "transitionEnd"],
    ["volumechange", "volumeChange"],
    ["waiting", "waiting"],
    ["wheel", "wheel"]
  ].forEach(function(_ref) {
    var eventType = _ref[1];
    ReactTestUtils.SimulateNative[eventType] = makeNativeSimulator(
      eventType,
      _ref[0]
    );
  });
  ReactSharedInternals =
    ((ReactSharedInternals = { default: ReactTestUtils }),
    ReactSharedInternals["default"]) || ReactSharedInternals;
  return ReactSharedInternals.default || ReactSharedInternals;
});

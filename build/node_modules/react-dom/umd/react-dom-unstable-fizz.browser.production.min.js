/** @license React vundefined
 * react-dom-unstable-fizz.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";
(function(global, factory) {
  "object" === typeof exports && "undefined" !== typeof module
    ? (module.exports = factory())
    : "function" === typeof define && define.amd
      ? define(factory)
      : (global.ReactDOMFizzServer = factory());
})(this, function() {
  function formatChunk(type, props) {
    var str = "<" + type + ">";
    "string" === typeof props.children && (str += props.children);
    return textEncoder.encode(str + ("</" + type + ">"));
  }
  function flushCompletedChunks(request) {
    var destination = request.destination,
      chunks = request.completedChunks;
    request.completedChunks = [];
    for (request = 0; request < chunks.length; request++)
      destination.enqueue(chunks[request]);
    destination.close();
  }
  var textEncoder = new TextEncoder(),
    REACT_ELEMENT_TYPE =
      "function" === typeof Symbol && Symbol.for
        ? Symbol.for("react.element")
        : 60103,
    ReactDOMFizzServerBrowser = {
      renderToReadableStream: function(children) {
        var request;
        return new ReadableStream({
          start: function(controller) {
            controller = request = {
              destination: controller,
              children: children,
              completedChunks: [],
              flowing: !1
            };
            controller.flowing = !0;
            var element = controller.children;
            controller.children = null;
            if (!element || element.$$typeof === REACT_ELEMENT_TYPE) {
              var type = element.type;
              element = element.props;
              "string" === typeof type &&
                (controller.completedChunks.push(formatChunk(type, element)),
                controller.flowing && flushCompletedChunks(controller));
            }
          },
          pull: function(controller) {
            controller = request;
            controller.flowing = !1;
            flushCompletedChunks(controller);
          },
          cancel: function(reason) {}
        });
      }
    },
    ReactDOMFizzServerBrowser$1 = { default: ReactDOMFizzServerBrowser };
  ReactDOMFizzServerBrowser =
    (ReactDOMFizzServerBrowser$1 && ReactDOMFizzServerBrowser) ||
    ReactDOMFizzServerBrowser$1;
  return ReactDOMFizzServerBrowser.default || ReactDOMFizzServerBrowser;
});

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });

var React = require("react");

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be converted to ReactError during
// build, and in production they will be minified.
function ReactErrorProd(error) {
  var code = error.message;
  var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;

  for (var i = 1; i < arguments.length; i++) {
    url += "&args[]=" + encodeURIComponent(arguments[i]);
  }

  error.message =
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or " +
    "use the non-minified dev environment for full errors and additional " +
    "helpful warnings. ";
  return error;
}

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be converted to ReactError during
// build, and in production they will be minified.

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

function createSubscription(config) {
  var getCurrentValue = config.getCurrentValue,
    _subscribe = config.subscribe;
  var Subscription =
    /*#__PURE__*/
    (function(_React$Component) {
      _inheritsLoose(Subscription, _React$Component);

      function Subscription() {
        var _this;

        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key];
        }

        _this =
          _React$Component.call.apply(_React$Component, [this].concat(args)) ||
          this;
        _this.state = {
          source: _this.props.source,
          value:
            _this.props.source != null
              ? getCurrentValue(_this.props.source)
              : undefined
        };
        _this._hasUnmounted = false;
        _this._unsubscribe = null;
        return _this;
      }

      Subscription.getDerivedStateFromProps = function getDerivedStateFromProps(
        nextProps,
        prevState
      ) {
        if (nextProps.source !== prevState.source) {
          return {
            source: nextProps.source,
            value:
              nextProps.source != null
                ? getCurrentValue(nextProps.source)
                : undefined
          };
        }

        return null;
      };

      var _proto = Subscription.prototype;

      _proto.componentDidMount = function componentDidMount() {
        this.subscribe();
      };

      _proto.componentDidUpdate = function componentDidUpdate(
        prevProps,
        prevState
      ) {
        if (this.state.source !== prevState.source) {
          this.unsubscribe();
          this.subscribe();
        }
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        this.unsubscribe(); // Track mounted to avoid calling setState after unmounting
        // For source like Promises that can't be unsubscribed from.

        this._hasUnmounted = true;
      };

      _proto.render = function render() {
        return this.props.children(this.state.value);
      };

      _proto.subscribe = function subscribe() {
        var _this2 = this;

        var source = this.state.source;

        if (source != null) {
          var _callback = function(value) {
            if (_this2._hasUnmounted) {
              return;
            }

            _this2.setState(function(state) {
              // If the value is the same, skip the unnecessary state update.
              if (value === state.value) {
                return null;
              } // If this event belongs to an old or uncommitted data source, ignore it.

              if (source !== state.source) {
                return null;
              }

              return {
                value: value
              };
            });
          }; // Store the unsubscribe method for later (in case the subscribable prop changes).

          var unsubscribe = _subscribe(source, _callback);

          (function() {
            if (!(typeof unsubscribe === "function")) {
              {
                throw ReactErrorProd(Error(266));
              }
            }
          })(); // It's safe to store unsubscribe on the instance because
          // We only read or write that property during the "commit" phase.

          this._unsubscribe = unsubscribe; // External values could change between render and mount,
          // In some cases it may be important to handle this case.

          var _value = getCurrentValue(this.props.source);

          if (_value !== this.state.value) {
            this.setState({
              value: _value
            });
          }
        }
      };

      _proto.unsubscribe = function unsubscribe() {
        if (typeof this._unsubscribe === "function") {
          this._unsubscribe();
        }

        this._unsubscribe = null;
      };

      return Subscription;
    })(React.Component);

  return Subscription;
}

exports.createSubscription = createSubscription;

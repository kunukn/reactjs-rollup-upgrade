/** @license React vundefined
 * react-test-renderer-shallow.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";
(function(global, factory) {
  "object" === typeof exports && "undefined" !== typeof module
    ? (module.exports = factory(require("react")))
    : "function" === typeof define && define.amd
      ? define(["react"], factory)
      : (global.ReactShallowRenderer = factory(global.React));
})(this, function(React) {
  function ReactErrorProd(error) {
    for (
      var code = error.message,
        url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code,
        i = 1;
      i < arguments.length;
      i++
    )
      url += "&args[]=" + encodeURIComponent(arguments[i]);
    error.message =
      "Minified React error #" +
      code +
      "; visit " +
      url +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ";
    return error;
  }
  function typeOf(object) {
    if ("object" === typeof object && null !== object) {
      var $$typeof = object.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (((object = object.type), object)) {
            case REACT_ASYNC_MODE_TYPE:
            case REACT_CONCURRENT_MODE_TYPE:
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
              return object;
            default:
              switch (((object = object && object.$$typeof), object)) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_PROVIDER_TYPE:
                  return object;
                default:
                  return $$typeof;
              }
          }
        case REACT_LAZY_TYPE:
        case REACT_MEMO_TYPE:
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  function getComponentName(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          return "Context.Consumer";
        case REACT_PROVIDER_TYPE:
          return "Context.Provider";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          innerType = innerType.displayName || innerType.name || "";
          return (
            type.displayName ||
            ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef")
          );
        case REACT_MEMO_TYPE:
          return getComponentName(type.type);
        case REACT_LAZY_TYPE:
          if ((type = 1 === type._status ? type._result : null))
            return getComponentName(type);
      }
    return null;
  }
  function is(x, y) {
    return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return !0;
    if (
      "object" !== typeof objA ||
      null === objA ||
      "object" !== typeof objB ||
      null === objB
    )
      return !1;
    var keysA = Object.keys(objA),
      keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;
    for (keysB = 0; keysB < keysA.length; keysB++)
      if (
        !hasOwnProperty.call(objB, keysA[keysB]) ||
        !is(objA[keysA[keysB]], objB[keysA[keysB]])
      )
        return !1;
    return !0;
  }
  function createHook() {
    return { memoizedState: null, queue: null, next: null };
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  var _assign = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
    hasSymbol = "function" === typeof Symbol && Symbol.for,
    REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103,
    REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
    REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107,
    REACT_STRICT_MODE_TYPE = hasSymbol
      ? Symbol.for("react.strict_mode")
      : 60108,
    REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114,
    REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109,
    REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110,
    REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111,
    REACT_CONCURRENT_MODE_TYPE = hasSymbol
      ? Symbol.for("react.concurrent_mode")
      : 60111,
    REACT_FORWARD_REF_TYPE = hasSymbol
      ? Symbol.for("react.forward_ref")
      : 60112,
    REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
    REACT_SUSPENSE_LIST_TYPE = hasSymbol
      ? Symbol.for("react.suspense_list")
      : 60120,
    REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
    REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
    ForwardRef = REACT_FORWARD_REF_TYPE;
  hasSymbol = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  hasSymbol.hasOwnProperty("ReactCurrentDispatcher") ||
    (hasSymbol.ReactCurrentDispatcher = { current: null });
  hasSymbol.hasOwnProperty("ReactCurrentBatchConfig") ||
    (hasSymbol.ReactCurrentBatchConfig = { suspense: null });
  var hasOwnProperty = Object.prototype.hasOwnProperty,
    ReactCurrentDispatcher = hasSymbol.ReactCurrentDispatcher,
    emptyObject = {},
    Updater = (function() {
      function Updater(renderer) {
        this._renderer = renderer;
        this._callbacks = [];
      }
      var _proto = Updater.prototype;
      _proto._enqueueCallback = function(callback, publicInstance) {
        "function" === typeof callback &&
          publicInstance &&
          this._callbacks.push({
            callback: callback,
            publicInstance: publicInstance
          });
      };
      _proto._invokeCallbacks = function() {
        var callbacks = this._callbacks;
        this._callbacks = [];
        callbacks.forEach(function(_ref) {
          _ref.callback.call(_ref.publicInstance);
        });
      };
      _proto.isMounted = function(publicInstance) {
        return !!this._renderer._element;
      };
      _proto.enqueueForceUpdate = function(
        publicInstance,
        callback,
        callerName
      ) {
        this._enqueueCallback(callback, publicInstance);
        this._renderer._forcedUpdate = !0;
        this._renderer.render(this._renderer._element, this._renderer._context);
      };
      _proto.enqueueReplaceState = function(
        publicInstance,
        completeState,
        callback,
        callerName
      ) {
        this._enqueueCallback(callback, publicInstance);
        this._renderer._newState = completeState;
        this._renderer.render(this._renderer._element, this._renderer._context);
      };
      _proto.enqueueSetState = function(
        publicInstance,
        partialState,
        callback,
        callerName
      ) {
        this._enqueueCallback(callback, publicInstance);
        callback = this._renderer._newState || publicInstance.state;
        "function" === typeof partialState &&
          (partialState = partialState.call(
            publicInstance,
            callback,
            publicInstance.props
          ));
        null !== partialState &&
          void 0 !== partialState &&
          ((this._renderer._newState = _assign({}, callback, {}, partialState)),
          this._renderer.render(
            this._renderer._element,
            this._renderer._context
          ));
      };
      return Updater;
    })(),
    ReactShallowRenderer = (function() {
      function ReactShallowRenderer() {
        this._reset();
      }
      var _proto2 = ReactShallowRenderer.prototype;
      _proto2._reset = function() {
        this._rendered = this._newState = this._instance = this._element = this._context = null;
        this._forcedUpdate = this._rendering = !1;
        this._updater = new Updater(this);
        this._dispatcher = this._createDispatcher();
        this._firstWorkInProgressHook = this._workInProgressHook = null;
        this._didScheduleRenderPhaseUpdate = this._isReRender = !1;
        this._renderPhaseUpdates = null;
        this._numberOfReRenders = 0;
      };
      _proto2._validateCurrentlyRenderingComponent = function() {
        if (!this._rendering || this._instance)
          throw ReactErrorProd(Error(321));
      };
      _proto2._createDispatcher = function() {
        var _this2 = this,
          useReducer = function(reducer, initialArg, init) {
            _this2._validateCurrentlyRenderingComponent();
            _this2._createWorkInProgressHook();
            var workInProgressHook = _this2._workInProgressHook;
            if (_this2._isReRender) {
              init = workInProgressHook.queue;
              initialArg = init.dispatch;
              if (0 < _this2._numberOfReRenders) {
                if (null !== _this2._renderPhaseUpdates) {
                  var firstRenderPhaseUpdate = _this2._renderPhaseUpdates.get(
                    init
                  );
                  if (void 0 !== firstRenderPhaseUpdate) {
                    _this2._renderPhaseUpdates.delete(init);
                    init = workInProgressHook.memoizedState;
                    do
                      (init = reducer(init, firstRenderPhaseUpdate.action)),
                        (firstRenderPhaseUpdate = firstRenderPhaseUpdate.next);
                    while (null !== firstRenderPhaseUpdate);
                    workInProgressHook.memoizedState = init;
                    return [init, initialArg];
                  }
                }
                return [workInProgressHook.memoizedState, initialArg];
              }
              firstRenderPhaseUpdate = workInProgressHook.memoizedState;
              var update = init.first;
              if (null !== update) {
                do
                  (firstRenderPhaseUpdate = reducer(
                    firstRenderPhaseUpdate,
                    update.action
                  )),
                    (update = update.next);
                while (null !== update);
                init.first = null;
                workInProgressHook.memoizedState = firstRenderPhaseUpdate;
              }
              return [firstRenderPhaseUpdate, initialArg];
            }
            reducer =
              reducer === basicStateReducer
                ? "function" === typeof initialArg
                  ? initialArg()
                  : initialArg
                : void 0 !== init
                  ? init(initialArg)
                  : initialArg;
            workInProgressHook.memoizedState = reducer;
            reducer = workInProgressHook.queue = {
              first: null,
              dispatch: null
            };
            reducer = reducer.dispatch = _this2._dispatchAction.bind(
              _this2,
              reducer
            );
            return [workInProgressHook.memoizedState, reducer];
          },
          noOp = function() {
            _this2._validateCurrentlyRenderingComponent();
          };
        return {
          readContext: function(context, observedBits) {
            return context._currentValue;
          },
          useCallback: function(fn) {
            return fn;
          },
          useContext: function(context) {
            _this2._validateCurrentlyRenderingComponent();
            return context._currentValue;
          },
          useDebugValue: noOp,
          useEffect: noOp,
          useImperativeHandle: noOp,
          useLayoutEffect: noOp,
          useMemo: function(nextCreate, deps) {
            _this2._validateCurrentlyRenderingComponent();
            _this2._createWorkInProgressHook();
            deps = void 0 !== deps ? deps : null;
            if (
              null !== _this2._workInProgressHook &&
              null !== _this2._workInProgressHook.memoizedState
            ) {
              var prevState = _this2._workInProgressHook.memoizedState,
                prevDeps = prevState[1];
              if (null !== deps) {
                a: if (null === prevDeps) prevDeps = !1;
                else {
                  for (var i = 0; i < prevDeps.length && i < deps.length; i++)
                    if (!is(deps[i], prevDeps[i])) {
                      prevDeps = !1;
                      break a;
                    }
                  prevDeps = !0;
                }
                if (prevDeps) return prevState[0];
              }
            }
            nextCreate = nextCreate();
            _this2._workInProgressHook.memoizedState = [nextCreate, deps];
            return nextCreate;
          },
          useReducer: useReducer,
          useRef: function(initialValue) {
            _this2._validateCurrentlyRenderingComponent();
            _this2._createWorkInProgressHook();
            var previousRef = _this2._workInProgressHook.memoizedState;
            return null === previousRef
              ? ((initialValue = { current: initialValue }),
                (_this2._workInProgressHook.memoizedState = initialValue))
              : previousRef;
          },
          useState: function(initialState) {
            return useReducer(basicStateReducer, initialState);
          },
          useResponder: function(responder, props) {
            return { props: props, responder: responder };
          }
        };
      };
      _proto2._dispatchAction = function(queue, action) {
        if (!(25 > this._numberOfReRenders)) throw ReactErrorProd(Error(301));
        if (this._rendering) {
          this._didScheduleRenderPhaseUpdate = !0;
          action = { action: action, next: null };
          var renderPhaseUpdates = this._renderPhaseUpdates;
          null === renderPhaseUpdates &&
            (this._renderPhaseUpdates = renderPhaseUpdates = new Map());
          var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
          if (void 0 === firstRenderPhaseUpdate)
            renderPhaseUpdates.set(queue, action);
          else {
            for (queue = firstRenderPhaseUpdate; null !== queue.next; )
              queue = queue.next;
            queue.next = action;
          }
        } else {
          action = { action: action, next: null };
          renderPhaseUpdates = queue.first;
          if (null === renderPhaseUpdates) queue.first = action;
          else {
            for (; null !== renderPhaseUpdates.next; )
              renderPhaseUpdates = renderPhaseUpdates.next;
            renderPhaseUpdates.next = action;
          }
          this.render(this._element, this._context);
        }
      };
      _proto2._createWorkInProgressHook = function() {
        null === this._workInProgressHook
          ? null === this._firstWorkInProgressHook
            ? ((this._isReRender = !1),
              (this._firstWorkInProgressHook = this._workInProgressHook = createHook()))
            : ((this._isReRender = !0),
              (this._workInProgressHook = this._firstWorkInProgressHook))
          : null === this._workInProgressHook.next
            ? ((this._isReRender = !1),
              (this._workInProgressHook = this._workInProgressHook.next = createHook()))
            : ((this._isReRender = !0),
              (this._workInProgressHook = this._workInProgressHook.next));
        return this._workInProgressHook;
      };
      _proto2._finishHooks = function(element, context) {
        this._didScheduleRenderPhaseUpdate
          ? ((this._didScheduleRenderPhaseUpdate = !1),
            (this._numberOfReRenders += 1),
            (this._workInProgressHook = null),
            (this._rendering = !1),
            this.render(element, context))
          : ((this._renderPhaseUpdates = this._workInProgressHook = null),
            (this._numberOfReRenders = 0));
      };
      _proto2.getMountedInstance = function() {
        return this._instance;
      };
      _proto2.getRenderOutput = function() {
        return this._rendered;
      };
      _proto2.render = function(element) {
        var context =
          1 < arguments.length && void 0 !== arguments[1]
            ? arguments[1]
            : emptyObject;
        if (!React.isValidElement(element))
          throw ReactErrorProd(
            Error(12),
            "function" === typeof element
              ? " Instead of passing a component class, make sure to instantiate it by passing it to React.createElement."
              : ""
          );
        if ("string" === typeof element.type)
          throw ReactErrorProd(Error(13), element.type);
        if (
          typeOf(element) !== REACT_FORWARD_REF_TYPE &&
          "function" !== typeof element.type &&
          typeOf(element.type) !== REACT_MEMO_TYPE
        )
          throw ReactErrorProd(
            Error(249),
            Array.isArray(element.type)
              ? "array"
              : null === element.type
                ? "null"
                : typeof element.type
          );
        if (!this._rendering) {
          null != this._element &&
            this._element.type !== element.type &&
            this._reset();
          var elementType =
              typeOf(element.type) === REACT_MEMO_TYPE
                ? element.type.type
                : element.type,
            previousElement = this._element;
          this._rendering = !0;
          this._element = element;
          var JSCompiler_inline_result;
          if (
            (JSCompiler_inline_result = elementType.contextTypes) &&
            context
          ) {
            var context$jscomp$0 = {},
              key;
            for (key in JSCompiler_inline_result)
              context$jscomp$0[key] = context[key];
            JSCompiler_inline_result = context$jscomp$0;
          } else JSCompiler_inline_result = emptyObject;
          this._context = JSCompiler_inline_result;
          typeOf(element.type) === REACT_MEMO_TYPE &&
            elementType.propTypes &&
            getComponentName(elementType);
          if (this._instance)
            this._updateClassComponent(elementType, element, this._context);
          else if (
            elementType.prototype &&
            elementType.prototype.isReactComponent
          )
            (this._instance = new elementType(
              element.props,
              this._context,
              this._updater
            )),
              "function" === typeof elementType.getDerivedStateFromProps &&
                ((context = elementType.getDerivedStateFromProps.call(
                  null,
                  element.props,
                  this._instance.state
                )),
                null != context &&
                  (this._instance.state = _assign(
                    {},
                    this._instance.state,
                    context
                  ))),
              this._mountClassComponent(elementType, element, this._context);
          else if (
            ((JSCompiler_inline_result = !0),
            typeOf(element.type) === REACT_MEMO_TYPE &&
              null !== previousElement &&
              (element.type.compare || shallowEqual)(
                previousElement.props,
                element.props
              ) &&
              (JSCompiler_inline_result = !1),
            JSCompiler_inline_result)
          ) {
            previousElement = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = this._dispatcher;
            try {
              if (elementType.$$typeof === ForwardRef) {
                if ("function" !== typeof elementType.render)
                  throw ReactErrorProd(Error(322), typeof elementType.render);
                this._rendered = elementType.render.call(
                  void 0,
                  element.props,
                  element.ref
                );
              } else this._rendered = elementType(element.props, this._context);
            } finally {
              ReactCurrentDispatcher.current = previousElement;
            }
            this._finishHooks(element, context);
          }
          this._rendering = !1;
          this._updater._invokeCallbacks();
          return this.getRenderOutput();
        }
      };
      _proto2.unmount = function() {
        this._instance &&
          "function" === typeof this._instance.componentWillUnmount &&
          this._instance.componentWillUnmount();
        this._reset();
      };
      _proto2._mountClassComponent = function(elementType, element, context) {
        this._instance.context = context;
        this._instance.props = element.props;
        this._instance.state = this._instance.state || null;
        this._instance.updater = this._updater;
        if (
          "function" === typeof this._instance.UNSAFE_componentWillMount ||
          "function" === typeof this._instance.componentWillMount
        )
          (element = this._newState),
            "function" !== typeof elementType.getDerivedStateFromProps &&
              "function" !== typeof this._instance.getSnapshotBeforeUpdate &&
              ("function" === typeof this._instance.componentWillMount &&
                this._instance.componentWillMount(),
              "function" === typeof this._instance.UNSAFE_componentWillMount &&
                this._instance.UNSAFE_componentWillMount()),
            element !== this._newState &&
              (this._instance.state = this._newState || emptyObject);
        this._rendered = this._instance.render();
      };
      _proto2._updateClassComponent = function(elementType, element, context) {
        element = element.props;
        var oldState = this._instance.state || emptyObject,
          oldProps = this._instance.props;
        oldProps !== element &&
          "function" !== typeof elementType.getDerivedStateFromProps &&
          "function" !== typeof this._instance.getSnapshotBeforeUpdate &&
          ("function" === typeof this._instance.componentWillReceiveProps &&
            this._instance.componentWillReceiveProps(element, context),
          "function" ===
            typeof this._instance.UNSAFE_componentWillReceiveProps &&
            this._instance.UNSAFE_componentWillReceiveProps(element, context));
        var state = this._newState || oldState;
        if ("function" === typeof elementType.getDerivedStateFromProps) {
          var partialState = elementType.getDerivedStateFromProps.call(
            null,
            element,
            state
          );
          null != partialState && (state = _assign({}, state, partialState));
        }
        partialState = !0;
        this._forcedUpdate
          ? ((partialState = !0), (this._forcedUpdate = !1))
          : "function" === typeof this._instance.shouldComponentUpdate
            ? (partialState = !!this._instance.shouldComponentUpdate(
                element,
                state,
                context
              ))
            : elementType.prototype &&
              elementType.prototype.isPureReactComponent &&
              (partialState =
                !shallowEqual(oldProps, element) ||
                !shallowEqual(oldState, state));
        partialState &&
          "function" !== typeof elementType.getDerivedStateFromProps &&
          "function" !== typeof this._instance.getSnapshotBeforeUpdate &&
          ("function" === typeof this._instance.componentWillUpdate &&
            this._instance.componentWillUpdate(element, state, context),
          "function" === typeof this._instance.UNSAFE_componentWillUpdate &&
            this._instance.UNSAFE_componentWillUpdate(element, state, context));
        this._instance.context = context;
        this._instance.props = element;
        this._instance.state = state;
        this._newState = null;
        partialState && (this._rendered = this._instance.render());
      };
      return ReactShallowRenderer;
    })();
  ReactShallowRenderer.createRenderer = function() {
    return new ReactShallowRenderer();
  };
  hasSymbol =
    ((hasSymbol = { default: ReactShallowRenderer }), ReactShallowRenderer) ||
    hasSymbol;
  return hasSymbol.default || hasSymbol;
});

/** @license React vundefined
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";
(function(global, factory) {
  "object" === typeof exports && "undefined" !== typeof module
    ? (module.exports = factory())
    : "function" === typeof define && define.amd
      ? define(factory)
      : ((global = global || self), (global.React = factory()));
})(this, function() {
  function ReactErrorProd(error) {
    for (
      var code = error.message,
        url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code,
        i = 1;
      i < arguments.length;
      i++
    )
      url += "&args[]=" + encodeURIComponent(arguments[i]);
    error.message =
      "Minified React error #" +
      code +
      "; visit " +
      url +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ";
    return error;
  }
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  function ComponentDummy() {}
  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  function createElement(type, config, children) {
    var propName,
      props = {},
      key = null,
      ref = null;
    if (null != config)
      for (propName in (void 0 !== config.ref && (ref = config.ref),
      void 0 !== config.key && (key = "" + config.key),
      config))
        hasOwnProperty$1.call(config, propName) &&
          !RESERVED_PROPS.hasOwnProperty(propName) &&
          (props[propName] = config[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) props.children = children;
    else if (1 < childrenLength) {
      for (
        var childArray = Array(childrenLength), i = 0;
        i < childrenLength;
        i++
      )
        childArray[i] = arguments[i + 2];
      props.children = childArray;
    }
    if (type && type.defaultProps)
      for (propName in ((childrenLength = type.defaultProps), childrenLength))
        void 0 === props[propName] &&
          (props[propName] = childrenLength[propName]);
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key,
      ref: ref,
      props: props,
      _owner: ReactCurrentOwner.current
    };
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type: oldElement.type,
      key: newKey,
      ref: oldElement.ref,
      props: oldElement.props,
      _owner: oldElement._owner
    };
  }
  function isValidElement(object) {
    return (
      "object" === typeof object &&
      null !== object &&
      object.$$typeof === REACT_ELEMENT_TYPE
    );
  }
  function escape(key) {
    var escaperLookup = { "=": "=0", ":": "=2" };
    return (
      "$" +
      ("" + key).replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      })
    );
  }
  function getPooledTraverseContext(
    mapResult,
    keyPrefix,
    mapFunction,
    mapContext
  ) {
    if (traverseContextPool.length) {
      var traverseContext = traverseContextPool.pop();
      traverseContext.result = mapResult;
      traverseContext.keyPrefix = keyPrefix;
      traverseContext.func = mapFunction;
      traverseContext.context = mapContext;
      traverseContext.count = 0;
      return traverseContext;
    }
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
  function releaseTraverseContext(traverseContext) {
    traverseContext.result = null;
    traverseContext.keyPrefix = null;
    traverseContext.func = null;
    traverseContext.context = null;
    traverseContext.count = 0;
    10 > traverseContextPool.length &&
      traverseContextPool.push(traverseContext);
  }
  function traverseAllChildrenImpl(
    children,
    nameSoFar,
    callback,
    traverseContext
  ) {
    var type = typeof children;
    if ("undefined" === type || "boolean" === type) children = null;
    var invokeCallback = !1;
    if (null === children) invokeCallback = !0;
    else
      switch (type) {
        case "string":
        case "number":
          invokeCallback = !0;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = !0;
          }
      }
    if (invokeCallback)
      return (
        callback(
          traverseContext,
          children,
          "" === nameSoFar ? "." + getComponentKey(children, 0) : nameSoFar
        ),
        1
      );
    invokeCallback = 0;
    nameSoFar = "" === nameSoFar ? "." : nameSoFar + ":";
    if (Array.isArray(children))
      for (var i = 0; i < children.length; i++) {
        type = children[i];
        var nextName = nameSoFar + getComponentKey(type, i);
        invokeCallback += traverseAllChildrenImpl(
          type,
          nextName,
          callback,
          traverseContext
        );
      }
    else if (
      (null === children || "object" !== typeof children
        ? (nextName = null)
        : ((nextName =
            (MAYBE_ITERATOR_SYMBOL && children[MAYBE_ITERATOR_SYMBOL]) ||
            children["@@iterator"]),
          (nextName = "function" === typeof nextName ? nextName : null)),
      "function" === typeof nextName)
    )
      for (
        children = nextName.call(children), i = 0;
        !(type = children.next()).done;

      )
        (type = type.value),
          (nextName = nameSoFar + getComponentKey(type, i++)),
          (invokeCallback += traverseAllChildrenImpl(
            type,
            nextName,
            callback,
            traverseContext
          ));
    else if ("object" === type)
      throw ((callback = "" + children),
      ReactErrorProd(
        Error(31),
        "[object Object]" === callback
          ? "object with keys {" + Object.keys(children).join(", ") + "}"
          : callback,
        ""
      ));
    return invokeCallback;
  }
  function traverseAllChildren(children, callback, traverseContext) {
    return null == children
      ? 0
      : traverseAllChildrenImpl(children, "", callback, traverseContext);
  }
  function getComponentKey(component, index) {
    return "object" === typeof component &&
      null !== component &&
      null != component.key
      ? escape(component.key)
      : index.toString(36);
  }
  function forEachSingleChild(bookKeeping, child, name) {
    bookKeeping.func.call(bookKeeping.context, child, bookKeeping.count++);
  }
  function mapSingleChildIntoContext(bookKeeping, child, childKey) {
    var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix;
    bookKeeping = bookKeeping.func.call(
      bookKeeping.context,
      child,
      bookKeeping.count++
    );
    Array.isArray(bookKeeping)
      ? mapIntoWithKeyPrefixInternal(bookKeeping, result, childKey, function(
          c
        ) {
          return c;
        })
      : null != bookKeeping &&
        (isValidElement(bookKeeping) &&
          (bookKeeping = cloneAndReplaceKey(
            bookKeeping,
            keyPrefix +
              (!bookKeeping.key || (child && child.key === bookKeeping.key)
                ? ""
                : ("" + bookKeeping.key).replace(
                    userProvidedKeyEscapeRegex,
                    "$&/"
                  ) + "/") +
              childKey
          )),
        result.push(bookKeeping));
  }
  function mapIntoWithKeyPrefixInternal(
    children,
    array,
    prefix,
    func,
    context
  ) {
    var escapedPrefix = "";
    null != prefix &&
      (escapedPrefix =
        ("" + prefix).replace(userProvidedKeyEscapeRegex, "$&/") + "/");
    array = getPooledTraverseContext(array, escapedPrefix, func, context);
    traverseAllChildren(children, mapSingleChildIntoContext, array);
    releaseTraverseContext(array);
  }
  function resolveDispatcher() {
    var dispatcher = ReactCurrentDispatcher.current;
    if (null === dispatcher) throw ReactErrorProd(Error(321));
    return dispatcher;
  }
  function push(heap, node) {
    var index = heap.length;
    heap.push(node);
    a: for (;;) {
      var parentIndex = Math.floor((index - 1) / 2),
        parent = heap[parentIndex];
      if (void 0 !== parent && 0 < compare(parent, node))
        (heap[parentIndex] = node),
          (heap[index] = parent),
          (index = parentIndex);
      else break a;
    }
  }
  function peek(heap) {
    heap = heap[0];
    return void 0 === heap ? null : heap;
  }
  function pop(heap) {
    var first = heap[0];
    if (void 0 !== first) {
      var last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index = 0, length = heap.length; index < length; ) {
          var leftIndex = 2 * (index + 1) - 1,
            left = heap[leftIndex],
            rightIndex = leftIndex + 1,
            right = heap[rightIndex];
          if (void 0 !== left && 0 > compare(left, last))
            void 0 !== right && 0 > compare(right, left)
              ? ((heap[index] = right),
                (heap[rightIndex] = last),
                (index = rightIndex))
              : ((heap[index] = left),
                (heap[leftIndex] = last),
                (index = leftIndex));
          else if (void 0 !== right && 0 > compare(right, last))
            (heap[index] = right),
              (heap[rightIndex] = last),
              (index = rightIndex);
          else break a;
        }
      }
      return first;
    }
    return null;
  }
  function compare(a, b) {
    var diff = a.sortIndex - b.sortIndex;
    return 0 !== diff ? diff : a.id - b.id;
  }
  function advanceTimers(currentTime) {
    for (var timer = peek(timerQueue); null !== timer; ) {
      if (null === timer.callback) pop(timerQueue);
      else if (timer.startTime <= currentTime)
        pop(timerQueue),
          (timer.sortIndex = timer.expirationTime),
          push(taskQueue, timer);
      else break;
      timer = peek(timerQueue);
    }
  }
  function handleTimeout(currentTime) {
    isHostTimeoutScheduled = !1;
    advanceTimers(currentTime);
    if (!isHostCallbackScheduled)
      if (null !== peek(taskQueue))
        (isHostCallbackScheduled = !0), requestHostCallback(flushWork);
      else {
        var firstTimer = peek(timerQueue);
        null !== firstTimer &&
          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
  }
  function flushWork(hasTimeRemaining, initialTime) {
    isHostCallbackScheduled = !1;
    isHostTimeoutScheduled &&
      ((isHostTimeoutScheduled = !1), cancelHostTimeout());
    isPerformingWork = !0;
    var previousPriorityLevel = currentPriorityLevel;
    try {
      advanceTimers(initialTime);
      for (
        currentTask = peek(taskQueue);
        null !== currentTask &&
        (!(currentTask.expirationTime > initialTime) ||
          (hasTimeRemaining && !shouldYieldToHost()));

      ) {
        var callback = currentTask.callback;
        if (null !== callback) {
          currentTask.callback = null;
          var task = currentTask,
            callback$jscomp$0 = callback,
            currentTime = initialTime;
          currentPriorityLevel = task.priorityLevel;
          var continuationCallback = callback$jscomp$0(
            task.expirationTime <= currentTime
          );
          var continuation =
            "function" === typeof continuationCallback
              ? continuationCallback
              : null;
          null !== continuation
            ? (currentTask.callback = continuation)
            : currentTask === peek(taskQueue) && pop(taskQueue);
          initialTime = getCurrentTime();
          advanceTimers(initialTime);
        } else pop(taskQueue);
        currentTask = peek(taskQueue);
      }
      if (null !== currentTask) return !0;
      var firstTimer = peek(timerQueue);
      null !== firstTimer &&
        requestHostTimeout(handleTimeout, firstTimer.startTime - initialTime);
      return !1;
    } finally {
      (currentTask = null),
        (currentPriorityLevel = previousPriorityLevel),
        (isPerformingWork = !1);
    }
  }
  function timeoutForPriorityLevel(priorityLevel) {
    switch (priorityLevel) {
      case 1:
        return -1;
      case 2:
        return 250;
      case 5:
        return 1073741823;
      case 4:
        return 1e4;
      default:
        return 5e3;
    }
  }
  var hasSymbol = "function" === typeof Symbol && Symbol.for,
    REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103,
    REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
    REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107,
    REACT_STRICT_MODE_TYPE = hasSymbol
      ? Symbol.for("react.strict_mode")
      : 60108,
    REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114,
    REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109,
    REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110,
    REACT_FORWARD_REF_TYPE = hasSymbol
      ? Symbol.for("react.forward_ref")
      : 60112,
    REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
    REACT_SUSPENSE_LIST_TYPE = hasSymbol
      ? Symbol.for("react.suspense_list")
      : 60120,
    REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
    REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116,
    MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator,
    getOwnPropertySymbols = Object.getOwnPropertySymbols,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    propIsEnumerable = Object.prototype.propertyIsEnumerable,
    objectAssign = (function() {
      try {
        if (!Object.assign) return !1;
        var test1 = new String("abc");
        test1[5] = "de";
        if ("5" === Object.getOwnPropertyNames(test1)[0]) return !1;
        var test2 = {};
        for (test1 = 0; 10 > test1; test1++)
          test2["_" + String.fromCharCode(test1)] = test1;
        if (
          "0123456789" !==
          Object.getOwnPropertyNames(test2)
            .map(function(n) {
              return test2[n];
            })
            .join("")
        )
          return !1;
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        return "abcdefghijklmnopqrst" !==
          Object.keys(Object.assign({}, test3)).join("")
          ? !1
          : !0;
      } catch (err) {
        return !1;
      }
    })()
      ? Object.assign
      : function(target, source) {
          if (null === target || void 0 === target)
            throw new TypeError(
              "Object.assign cannot be called with null or undefined"
            );
          var to = Object(target);
          for (var symbols, s = 1; s < arguments.length; s++) {
            var from = Object(arguments[s]);
            for (var key in from)
              hasOwnProperty.call(from, key) && (to[key] = from[key]);
            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++)
                propIsEnumerable.call(from, symbols[i]) &&
                  (to[symbols[i]] = from[symbols[i]]);
            }
          }
          return to;
        },
    ReactNoopUpdateQueue = {
      isMounted: function(publicInstance) {
        return !1;
      },
      enqueueForceUpdate: function(publicInstance, callback, callerName) {},
      enqueueReplaceState: function(
        publicInstance,
        completeState,
        callback,
        callerName
      ) {},
      enqueueSetState: function(
        publicInstance,
        partialState,
        callback,
        callerName
      ) {}
    },
    emptyObject = {};
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function(partialState, callback) {
    if (
      "object" !== typeof partialState &&
      "function" !== typeof partialState &&
      null != partialState
    )
      throw ReactErrorProd(Error(85));
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  ComponentDummy.prototype = Component.prototype;
  hasSymbol = PureComponent.prototype = new ComponentDummy();
  hasSymbol.constructor = PureComponent;
  objectAssign(hasSymbol, Component.prototype);
  hasSymbol.isPureReactComponent = !0;
  var ReactCurrentDispatcher = { current: null },
    ReactCurrentOwner = { current: null },
    hasOwnProperty$1 = Object.prototype.hasOwnProperty,
    RESERVED_PROPS = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    },
    userProvidedKeyEscapeRegex = /\/+/g,
    traverseContextPool = [],
    forceFrameRate;
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var _callback = null,
      _timeoutID = null,
      _flushCallback = function() {
        if (null !== _callback)
          try {
            var currentTime = getCurrentTime();
            _callback(!0, currentTime);
            _callback = null;
          } catch (e) {
            throw (setTimeout(_flushCallback, 0), e);
          }
      };
    var getCurrentTime = function() {
      return Date.now();
    };
    var requestHostCallback = function(cb) {
      null !== _callback
        ? setTimeout(requestHostCallback, 0, cb)
        : ((_callback = cb), setTimeout(_flushCallback, 0));
    };
    var requestHostTimeout = function(cb, ms) {
      _timeoutID = setTimeout(cb, ms);
    };
    var cancelHostTimeout = function() {
      clearTimeout(_timeoutID);
    };
    var shouldYieldToHost = function() {
      return !1;
    };
    hasSymbol = forceFrameRate = function() {};
  } else {
    var performance = window.performance,
      _Date = window.Date,
      _setTimeout = window.setTimeout,
      _clearTimeout = window.clearTimeout,
      requestAnimationFrame = window.requestAnimationFrame;
    hasSymbol = window.cancelAnimationFrame;
    "undefined" !== typeof console &&
      ("function" !== typeof requestAnimationFrame &&
        console.error(
          "This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"
        ),
      "function" !== typeof hasSymbol &&
        console.error(
          "This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"
        ));
    getCurrentTime =
      "object" === typeof performance && "function" === typeof performance.now
        ? function() {
            return performance.now();
          }
        : function() {
            return _Date.now();
          };
    var isRAFLoopRunning = !1,
      scheduledHostCallback = null,
      rAFTimeoutID = -1,
      taskTimeoutID = -1,
      frameLength = 33.33,
      prevRAFTime = -1,
      prevRAFInterval = -1,
      frameDeadline = 0,
      fpsLocked = !1;
    shouldYieldToHost = function() {
      return getCurrentTime() >= frameDeadline;
    };
    hasSymbol = function() {};
    forceFrameRate = function(fps) {
      0 > fps || 125 < fps
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"
          )
        : 0 < fps
          ? ((frameLength = Math.floor(1e3 / fps)), (fpsLocked = !0))
          : ((frameLength = 33.33), (fpsLocked = !1));
    };
    var performWorkUntilDeadline = function() {
        if (null !== scheduledHostCallback) {
          var _currentTime = getCurrentTime(),
            _hasTimeRemaining = 0 < frameDeadline - _currentTime;
          try {
            scheduledHostCallback(_hasTimeRemaining, _currentTime) ||
              (scheduledHostCallback = null);
          } catch (error) {
            throw (port.postMessage(null), error);
          }
        }
      },
      channel = new MessageChannel(),
      port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    var onAnimationFrame = function(rAFTime) {
      if (null === scheduledHostCallback)
        (prevRAFInterval = prevRAFTime = -1), (isRAFLoopRunning = !1);
      else {
        isRAFLoopRunning = !0;
        requestAnimationFrame(function(nextRAFTime) {
          _clearTimeout(rAFTimeoutID);
          onAnimationFrame(nextRAFTime);
        });
        var onTimeout = function() {
          frameDeadline = getCurrentTime() + frameLength / 2;
          performWorkUntilDeadline();
          rAFTimeoutID = _setTimeout(onTimeout, 3 * frameLength);
        };
        rAFTimeoutID = _setTimeout(onTimeout, 3 * frameLength);
        if (-1 !== prevRAFTime && 0.1 < rAFTime - prevRAFTime) {
          var rAFInterval = rAFTime - prevRAFTime;
          !fpsLocked &&
            -1 !== prevRAFInterval &&
            rAFInterval < frameLength &&
            prevRAFInterval < frameLength &&
            ((frameLength =
              rAFInterval < prevRAFInterval ? prevRAFInterval : rAFInterval),
            8.33 > frameLength && (frameLength = 8.33));
          prevRAFInterval = rAFInterval;
        }
        prevRAFTime = rAFTime;
        frameDeadline = rAFTime + frameLength;
        port.postMessage(null);
      }
    };
    requestHostCallback = function(callback) {
      scheduledHostCallback = callback;
      isRAFLoopRunning ||
        ((isRAFLoopRunning = !0),
        requestAnimationFrame(function(rAFTime) {
          onAnimationFrame(rAFTime);
        }));
    };
    requestHostTimeout = function(callback, ms) {
      taskTimeoutID = _setTimeout(function() {
        callback(getCurrentTime());
      }, ms);
    };
    cancelHostTimeout = function() {
      _clearTimeout(taskTimeoutID);
      taskTimeoutID = -1;
    };
  }
  var taskQueue = [],
    timerQueue = [],
    taskIdCounter = 0,
    currentTask = null,
    currentPriorityLevel = 3,
    isPerformingWork = !1,
    isHostCallbackScheduled = !1,
    isHostTimeoutScheduled = !1,
    threadIDCounter = 0;
  channel = {
    ReactCurrentDispatcher: ReactCurrentDispatcher,
    ReactCurrentOwner: ReactCurrentOwner,
    IsSomeRendererActing: { current: !1 },
    assign: objectAssign
  };
  objectAssign(channel, {
    Scheduler: {
      unstable_ImmediatePriority: 1,
      unstable_UserBlockingPriority: 2,
      unstable_NormalPriority: 3,
      unstable_IdlePriority: 5,
      unstable_LowPriority: 4,
      unstable_runWithPriority: function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      },
      unstable_next: function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      },
      unstable_scheduleCallback: function(priorityLevel, callback, options) {
        var currentTime = getCurrentTime();
        if ("object" === typeof options && null !== options) {
          var startTime = options.delay;
          startTime =
            "number" === typeof startTime && 0 < startTime
              ? currentTime + startTime
              : currentTime;
          options =
            "number" === typeof options.timeout
              ? options.timeout
              : timeoutForPriorityLevel(priorityLevel);
        } else
          (options = timeoutForPriorityLevel(priorityLevel)),
            (startTime = currentTime);
        options = startTime + options;
        priorityLevel = {
          id: taskIdCounter++,
          callback: callback,
          priorityLevel: priorityLevel,
          startTime: startTime,
          expirationTime: options,
          sortIndex: -1
        };
        startTime > currentTime
          ? ((priorityLevel.sortIndex = startTime),
            push(timerQueue, priorityLevel),
            null === peek(taskQueue) &&
              priorityLevel === peek(timerQueue) &&
              (isHostTimeoutScheduled
                ? cancelHostTimeout()
                : (isHostTimeoutScheduled = !0),
              requestHostTimeout(handleTimeout, startTime - currentTime)))
          : ((priorityLevel.sortIndex = options),
            push(taskQueue, priorityLevel),
            isHostCallbackScheduled ||
              isPerformingWork ||
              ((isHostCallbackScheduled = !0), requestHostCallback(flushWork)));
        return priorityLevel;
      },
      unstable_cancelCallback: function(task) {
        task.callback = null;
      },
      unstable_wrapCallback: function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      },
      unstable_getCurrentPriorityLevel: function() {
        return currentPriorityLevel;
      },
      unstable_shouldYield: function() {
        var currentTime = getCurrentTime();
        advanceTimers(currentTime);
        var firstTask = peek(taskQueue);
        return (
          (firstTask !== currentTask &&
            null !== currentTask &&
            null !== firstTask &&
            null !== firstTask.callback &&
            firstTask.startTime <= currentTime &&
            firstTask.expirationTime < currentTask.expirationTime) ||
          shouldYieldToHost()
        );
      },
      unstable_requestPaint: hasSymbol,
      unstable_continueExecution: function() {
        isHostCallbackScheduled ||
          isPerformingWork ||
          ((isHostCallbackScheduled = !0), requestHostCallback(flushWork));
      },
      unstable_pauseExecution: function() {},
      unstable_getFirstCallbackNode: function() {
        return peek(taskQueue);
      },
      get unstable_now() {
        return getCurrentTime;
      },
      get unstable_forceFrameRate() {
        return forceFrameRate;
      }
    },
    SchedulerTracing: {
      get __interactionsRef() {
        return null;
      },
      get __subscriberRef() {
        return null;
      },
      unstable_clear: function(callback) {
        return callback();
      },
      unstable_getCurrent: function() {
        return null;
      },
      unstable_getThreadID: function() {
        return ++threadIDCounter;
      },
      unstable_trace: function(name, timestamp, callback) {
        return callback();
      },
      unstable_wrap: function(callback) {
        return callback;
      },
      unstable_subscribe: function(subscriber) {},
      unstable_unsubscribe: function(subscriber) {}
    }
  });
  REACT_FRAGMENT_TYPE =
    ((REACT_FRAGMENT_TYPE = {
      default: {
        Children: {
          map: function(children, func, context) {
            if (null == children) return children;
            var result = [];
            mapIntoWithKeyPrefixInternal(children, result, null, func, context);
            return result;
          },
          forEach: function(children, forEachFunc, forEachContext) {
            if (null == children) return children;
            forEachFunc = getPooledTraverseContext(
              null,
              null,
              forEachFunc,
              forEachContext
            );
            traverseAllChildren(children, forEachSingleChild, forEachFunc);
            releaseTraverseContext(forEachFunc);
          },
          count: function(children) {
            return traverseAllChildren(
              children,
              function() {
                return null;
              },
              null
            );
          },
          toArray: function(children) {
            var result = [];
            mapIntoWithKeyPrefixInternal(children, result, null, function(
              child
            ) {
              return child;
            });
            return result;
          },
          only: function(children) {
            if (!isValidElement(children)) throw ReactErrorProd(Error(143));
            return children;
          }
        },
        createRef: function() {
          return { current: null };
        },
        Component: Component,
        PureComponent: PureComponent,
        createContext: function(defaultValue, calculateChangedBits) {
          void 0 === calculateChangedBits && (calculateChangedBits = null);
          defaultValue = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          defaultValue.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: defaultValue
          };
          return (defaultValue.Consumer = defaultValue);
        },
        forwardRef: function(render) {
          return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
        },
        lazy: function(ctor) {
          return {
            $$typeof: REACT_LAZY_TYPE,
            _ctor: ctor,
            _status: -1,
            _result: null
          };
        },
        memo: function(type, compare) {
          return {
            $$typeof: REACT_MEMO_TYPE,
            type: type,
            compare: void 0 === compare ? null : compare
          };
        },
        useCallback: function(callback, inputs) {
          return resolveDispatcher().useCallback(callback, inputs);
        },
        useContext: function(Context, unstable_observedBits) {
          return resolveDispatcher().useContext(Context, unstable_observedBits);
        },
        useEffect: function(create, inputs) {
          return resolveDispatcher().useEffect(create, inputs);
        },
        useImperativeHandle: function(ref, create, inputs) {
          return resolveDispatcher().useImperativeHandle(ref, create, inputs);
        },
        useDebugValue: function(value, formatterFn) {},
        useLayoutEffect: function(create, inputs) {
          return resolveDispatcher().useLayoutEffect(create, inputs);
        },
        useMemo: function(create, inputs) {
          return resolveDispatcher().useMemo(create, inputs);
        },
        useReducer: function(reducer, initialArg, init) {
          return resolveDispatcher().useReducer(reducer, initialArg, init);
        },
        useRef: function(initialValue) {
          return resolveDispatcher().useRef(initialValue);
        },
        useState: function(initialState) {
          return resolveDispatcher().useState(initialState);
        },
        Fragment: REACT_FRAGMENT_TYPE,
        Profiler: REACT_PROFILER_TYPE,
        StrictMode: REACT_STRICT_MODE_TYPE,
        Suspense: REACT_SUSPENSE_TYPE,
        unstable_SuspenseList: REACT_SUSPENSE_LIST_TYPE,
        createElement: createElement,
        cloneElement: function(element, config, children) {
          if (null === element || void 0 === element)
            throw ReactErrorProd(Error(267), element);
          var props = objectAssign({}, element.props),
            key = element.key,
            ref = element.ref,
            owner = element._owner;
          if (null != config) {
            void 0 !== config.ref &&
              ((ref = config.ref), (owner = ReactCurrentOwner.current));
            void 0 !== config.key && (key = "" + config.key);
            if (element.type && element.type.defaultProps)
              var defaultProps = element.type.defaultProps;
            for (propName in config)
              hasOwnProperty$1.call(config, propName) &&
                !RESERVED_PROPS.hasOwnProperty(propName) &&
                (props[propName] =
                  void 0 === config[propName] && void 0 !== defaultProps
                    ? defaultProps[propName]
                    : config[propName]);
          }
          var propName = arguments.length - 2;
          if (1 === propName) props.children = children;
          else if (1 < propName) {
            defaultProps = Array(propName);
            for (var i = 0; i < propName; i++)
              defaultProps[i] = arguments[i + 2];
            props.children = defaultProps;
          }
          return {
            $$typeof: REACT_ELEMENT_TYPE,
            type: element.type,
            key: key,
            ref: ref,
            props: props,
            _owner: owner
          };
        },
        createFactory: function(type) {
          var factory = createElement.bind(null, type);
          factory.type = type;
          return factory;
        },
        isValidElement: isValidElement,
        version: "16.8.6",
        unstable_withSuspenseConfig: function(scope, config) {
          scope();
        },
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: channel
      }
    }),
    REACT_FRAGMENT_TYPE["default"]) || REACT_FRAGMENT_TYPE;
  return REACT_FRAGMENT_TYPE.default || REACT_FRAGMENT_TYPE;
});

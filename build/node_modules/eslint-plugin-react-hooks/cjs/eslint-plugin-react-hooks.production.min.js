/** @license React vundefined
 * eslint-plugin-react-hooks.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";
function isHook(node) {
  return "Identifier" === node.type
    ? /^use[A-Z0-9].*$/.test(node.name)
    : "MemberExpression" === node.type &&
      !node.computed &&
      isHook(node.property)
      ? ((node = node.object),
        "Identifier" === node.type && "React" === node.name)
      : !1;
}
function isComponentName(node) {
  return "Identifier" === node.type ? !/^[a-z]/.test(node.name) : !1;
}
function isInsideComponentOrHook(node) {
  for (; node; ) {
    var functionName = getFunctionName(node);
    if (functionName && (isComponentName(functionName) || isHook(functionName)))
      return !0;
    node = node.parent;
  }
  return !1;
}
function getFunctionName(node) {
  if (
    "FunctionDeclaration" === node.type ||
    ("FunctionExpression" === node.type && node.id)
  )
    return node.id;
  if (
    "FunctionExpression" === node.type ||
    "ArrowFunctionExpression" === node.type
  )
    return "VariableDeclarator" === node.parent.type &&
      node.parent.init === node
      ? node.parent.id
      : "AssignmentExpression" === node.parent.type &&
        node.parent.right === node &&
        "=" === node.parent.operator
        ? node.parent.left
        : "Property" !== node.parent.type ||
          node.parent.value !== node ||
          node.parent.computed
          ? "AssignmentPattern" !== node.parent.type ||
            node.parent.right !== node ||
            node.parent.computed
            ? void 0
            : node.parent.left
          : node.parent.key;
}
function collectRecommendations(_ref5) {
  function createDepTree() {
    return {
      isRequired: !1,
      isSatisfiedRecursively: !1,
      hasRequiredNodesBelow: !1,
      children: new Map()
    };
  }
  function getOrCreateNodeByPath(rootNode, path) {
    path = path.split(".");
    var _iteratorNormalCompletion3 = !0,
      _didIteratorError3 = !1,
      _iteratorError3 = void 0;
    try {
      for (
        var _iterator3 = path[Symbol.iterator](), _step3;
        !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done);
        _iteratorNormalCompletion3 = !0
      ) {
        var key = _step3.value,
          child = rootNode.children.get(key);
        child || ((child = createDepTree()), rootNode.children.set(key, child));
        rootNode = child;
      }
    } catch (err) {
      (_didIteratorError3 = !0), (_iteratorError3 = err);
    } finally {
      try {
        _iteratorNormalCompletion3 ||
          null == _iterator3.return ||
          _iterator3.return();
      } finally {
        if (_didIteratorError3) throw _iteratorError3;
      }
    }
    return rootNode;
  }
  function markAllParentsByPath(rootNode, path, fn) {
    path = path.split(".");
    var _iteratorNormalCompletion4 = !0,
      _didIteratorError4 = !1,
      _iteratorError4 = void 0;
    try {
      for (
        var _iterator4 = path[Symbol.iterator](), _step4;
        !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done);
        _iteratorNormalCompletion4 = !0
      ) {
        var child = rootNode.children.get(_step4.value);
        if (!child) break;
        fn(child);
        rootNode = child;
      }
    } catch (err) {
      (_didIteratorError4 = !0), (_iteratorError4 = err);
    } finally {
      try {
        _iteratorNormalCompletion4 ||
          null == _iterator4.return ||
          _iterator4.return();
      } finally {
        if (_didIteratorError4) throw _iteratorError4;
      }
    }
  }
  function scanTreeRecursively(node, missingPaths, satisfyingPaths, keyToPath) {
    node.children.forEach(function(child, key) {
      var path = keyToPath(key);
      child.isSatisfiedRecursively
        ? child.hasRequiredNodesBelow && satisfyingPaths.add(path)
        : child.isRequired
          ? missingPaths.add(path)
          : scanTreeRecursively(child, missingPaths, satisfyingPaths, function(
              childKey
            ) {
              return path + "." + childKey;
            });
    });
  }
  var dependencies = _ref5.dependencies,
    declaredDependencies = _ref5.declaredDependencies,
    optionalDependencies = _ref5.optionalDependencies,
    externalDependencies = _ref5.externalDependencies,
    isEffect = _ref5.isEffect,
    depTree = createDepTree();
  dependencies.forEach(function(_, key) {
    getOrCreateNodeByPath(depTree, key).isRequired = !0;
    markAllParentsByPath(depTree, key, function(parent) {
      parent.hasRequiredNodesBelow = !0;
    });
  });
  declaredDependencies.forEach(function(_ref6) {
    getOrCreateNodeByPath(depTree, _ref6.key).isSatisfiedRecursively = !0;
  });
  optionalDependencies.forEach(function(key) {
    getOrCreateNodeByPath(depTree, key).isSatisfiedRecursively = !0;
  });
  _ref5 = new Set();
  var satisfyingDependencies = new Set();
  scanTreeRecursively(depTree, _ref5, satisfyingDependencies, function(key) {
    return key;
  });
  var suggestedDependencies = [],
    unnecessaryDependencies = new Set(),
    duplicateDependencies = new Set();
  declaredDependencies.forEach(function(_ref7) {
    _ref7 = _ref7.key;
    satisfyingDependencies.has(_ref7)
      ? -1 === suggestedDependencies.indexOf(_ref7)
        ? suggestedDependencies.push(_ref7)
        : duplicateDependencies.add(_ref7)
      : !isEffect ||
        _ref7.endsWith(".current") ||
        externalDependencies.has(_ref7)
        ? unnecessaryDependencies.add(_ref7)
        : -1 === suggestedDependencies.indexOf(_ref7) &&
          suggestedDependencies.push(_ref7);
  });
  _ref5.forEach(function(key) {
    suggestedDependencies.push(key);
  });
  return {
    suggestedDependencies: suggestedDependencies,
    unnecessaryDependencies: unnecessaryDependencies,
    duplicateDependencies: duplicateDependencies,
    missingDependencies: _ref5
  };
}
function scanForDeclaredBareFunctions(_ref8) {
  var declaredDependenciesNode = _ref8.declaredDependenciesNode,
    componentScope = _ref8.componentScope,
    scope = _ref8.scope;
  return _ref8.declaredDependencies
    .map(function(_ref9) {
      _ref9 = componentScope.set.get(_ref9.key);
      if (null == _ref9) return null;
      var fnNode = _ref9.defs[0];
      return null == fnNode
        ? null
        : ("Variable" === fnNode.type &&
            "VariableDeclarator" === fnNode.node.type &&
            null != fnNode.node.init &&
            ("ArrowFunctionExpression" === fnNode.node.init.type ||
              "FunctionExpression" === fnNode.node.init.type)) ||
          ("FunctionName" === fnNode.type &&
            "FunctionDeclaration" === fnNode.node.type)
          ? _ref9
          : null;
    })
    .filter(Boolean)
    .map(function(fnRef) {
      var JSCompiler_temp_const = fnRef.defs[0];
      a: {
        for (var foundWriteExpr = !1, i = 0; i < fnRef.references.length; i++) {
          var reference = fnRef.references[i];
          if (reference.writeExpr)
            if (foundWriteExpr) {
              fnRef = !0;
              break a;
            } else {
              foundWriteExpr = !0;
              continue;
            }
          for (
            var currentScope = reference.from;
            currentScope !== scope && null != currentScope;

          )
            currentScope = currentScope.upper;
          if (
            currentScope !== scope &&
            !isAncestorNodeOf(declaredDependenciesNode, reference.identifier)
          ) {
            fnRef = !0;
            break a;
          }
        }
        fnRef = !1;
      }
      return { fn: JSCompiler_temp_const, suggestUseCallback: fnRef };
    });
}
function getDependency(node) {
  return "MemberExpression" !== node.parent.type ||
    node.parent.object !== node ||
    "current" === node.parent.property.name ||
    node.parent.computed ||
    (null != node.parent.parent &&
      "CallExpression" === node.parent.parent.type &&
      node.parent.parent.callee === node.parent)
    ? node
    : getDependency(node.parent);
}
function toPropertyAccessString(node) {
  if ("Identifier" === node.type) return node.name;
  if ("MemberExpression" !== node.type || node.computed)
    throw Error("Unsupported node type: " + node.type);
  var object = toPropertyAccessString(node.object);
  node = toPropertyAccessString(node.property);
  return object + "." + node;
}
function getNodeWithoutReactNamespace(node) {
  return "MemberExpression" !== node.type ||
    "Identifier" !== node.object.type ||
    "React" !== node.object.name ||
    "Identifier" !== node.property.type ||
    node.computed
    ? node
    : node.property;
}
function getReactiveHookCallbackIndex(calleeNode, options) {
  var node = getNodeWithoutReactNamespace(calleeNode);
  if ("Identifier" !== node.type) return null;
  switch (node.name) {
    case "useEffect":
    case "useLayoutEffect":
    case "useCallback":
    case "useMemo":
      return 0;
    case "useImperativeHandle":
      return 1;
    default:
      if (node === calleeNode && options && options.additionalHooks) {
        try {
          var name = toPropertyAccessString(node);
        } catch (error) {
          if (/Unsupported node type/.test(error.message)) return 0;
          throw error;
        }
        return options.additionalHooks.test(name) ? 0 : -1;
      }
      return -1;
  }
}
function fastFindReferenceWithParent(start, target) {
  for (var queue = [start], item = null; queue.length; ) {
    item = queue.shift();
    if (
      "Identifier" === item.type &&
      item.name === target.name &&
      item.range[0] === target.range[0] &&
      item.range[1] === target.range[1]
    )
      return item;
    if (isAncestorNodeOf(item, target)) {
      start = 0;
      for (
        var _Object$entries = Object.entries(item);
        start < _Object$entries.length;
        start++
      ) {
        var _Object$entries$_i = _Object$entries[start],
          value = _Object$entries$_i[1];
        "parent" !== _Object$entries$_i[0] &&
          (isNodeLike(value)
            ? ((value.parent = item), queue.push(value))
            : Array.isArray(value) &&
              value.forEach(function(val) {
                isNodeLike(val) && ((val.parent = item), queue.push(val));
              }));
      }
    }
  }
  return null;
}
function joinEnglish(arr) {
  for (var s = "", i = 0; i < arr.length; i++)
    (s += arr[i]),
      0 === i && 2 === arr.length
        ? (s += " and ")
        : i === arr.length - 2 && 2 < arr.length
          ? (s += ", and ")
          : i < arr.length - 1 && (s += ", ");
  return s;
}
function isNodeLike(val) {
  return (
    "object" === typeof val &&
    null !== val &&
    !Array.isArray(val) &&
    "string" === typeof val.type
  );
}
function isAncestorNodeOf(a, b) {
  return a.range[0] <= b.range[0] && a.range[1] >= b.range[1];
}
var src = {
  rules: {
    "rules-of-hooks": {
      create: function(context) {
        var codePathReactHooksMapStack = [],
          codePathSegmentStack = [];
        return {
          onCodePathSegmentStart: function(segment) {
            return codePathSegmentStack.push(segment);
          },
          onCodePathSegmentEnd: function() {
            return codePathSegmentStack.pop();
          },
          onCodePathStart: function() {
            return codePathReactHooksMapStack.push(new Map());
          },
          onCodePathEnd: function(codePath, codePathNode) {
            function countPathsFromStart(segment) {
              var cache = countPathsFromStart.cache,
                paths = cache.get(segment.id);
              if (null === paths) {
                if (!cyclic.has(segment.id)) {
                  cyclic.add(segment.id);
                  cache = !0;
                  paths = !1;
                  var _iteratorError = void 0;
                  try {
                    for (
                      var _iterator = segment.prevSegments[Symbol.iterator](),
                        _step;
                      !(cache = (_step = _iterator.next()).done);
                      cache = !0
                    )
                      countPathsFromStart(_step.value);
                  } catch (err) {
                    (paths = !0), (_iteratorError = err);
                  } finally {
                    try {
                      cache || null == _iterator.return || _iterator.return();
                    } finally {
                      if (paths) throw _iteratorError;
                    }
                  }
                }
                return 0;
              }
              if (void 0 !== paths) return paths;
              cache.set(segment.id, null);
              if (codePath.thrownSegments.includes(segment)) paths = 0;
              else if (0 === segment.prevSegments.length) paths = 1;
              else {
                paths = 0;
                _iterator = !0;
                _step = !1;
                var _iteratorError2 = void 0;
                try {
                  _iteratorError = segment.prevSegments[Symbol.iterator]();
                  for (
                    var _step2;
                    !(_iterator = (_step2 = _iteratorError.next()).done);
                    _iterator = !0
                  )
                    paths += countPathsFromStart(_step2.value);
                } catch (err) {
                  (_step = !0), (_iteratorError2 = err);
                } finally {
                  try {
                    _iterator ||
                      null == _iteratorError.return ||
                      _iteratorError.return();
                  } finally {
                    if (_step) throw _iteratorError2;
                  }
                }
              }
              segment.reachable && 0 === paths
                ? cache.delete(segment.id)
                : cache.set(segment.id, paths);
              return paths;
            }
            function countPathsToEnd(segment) {
              var cache = countPathsToEnd.cache,
                paths = cache.get(segment.id);
              if (null === paths) {
                if (!cyclic.has(segment.id)) {
                  cyclic.add(segment.id);
                  cache = !0;
                  paths = !1;
                  var _iteratorError3 = void 0;
                  try {
                    for (
                      var _iterator3 = segment.nextSegments[Symbol.iterator](),
                        _step3;
                      !(cache = (_step3 = _iterator3.next()).done);
                      cache = !0
                    )
                      countPathsToEnd(_step3.value);
                  } catch (err) {
                    (paths = !0), (_iteratorError3 = err);
                  } finally {
                    try {
                      cache || null == _iterator3.return || _iterator3.return();
                    } finally {
                      if (paths) throw _iteratorError3;
                    }
                  }
                }
                return 0;
              }
              if (void 0 !== paths) return paths;
              cache.set(segment.id, null);
              if (codePath.thrownSegments.includes(segment)) paths = 0;
              else if (0 === segment.nextSegments.length) paths = 1;
              else {
                paths = 0;
                _iterator3 = !0;
                _step3 = !1;
                var _iteratorError4 = void 0;
                try {
                  _iteratorError3 = segment.nextSegments[Symbol.iterator]();
                  for (
                    var _step4;
                    !(_iterator3 = (_step4 = _iteratorError3.next()).done);
                    _iterator3 = !0
                  )
                    paths += countPathsToEnd(_step4.value);
                } catch (err) {
                  (_step3 = !0), (_iteratorError4 = err);
                } finally {
                  try {
                    _iterator3 ||
                      null == _iteratorError3.return ||
                      _iteratorError3.return();
                  } finally {
                    if (_step3) throw _iteratorError4;
                  }
                }
              }
              cache.set(segment.id, paths);
              return paths;
            }
            function shortestPathLengthToStart(segment) {
              var cache = shortestPathLengthToStart.cache,
                length = cache.get(segment.id);
              if (null === length) return Infinity;
              if (void 0 !== length) return length;
              cache.set(segment.id, null);
              if (0 === segment.prevSegments.length) length = 1;
              else {
                length = Infinity;
                var _iteratorNormalCompletion5 = !0,
                  _didIteratorError5 = !1,
                  _iteratorError5 = void 0;
                try {
                  for (
                    var _iterator5 = segment.prevSegments[Symbol.iterator](),
                      _step5;
                    !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next())
                      .done);
                    _iteratorNormalCompletion5 = !0
                  ) {
                    var prevLength = shortestPathLengthToStart(_step5.value);
                    prevLength < length && (length = prevLength);
                  }
                } catch (err) {
                  (_didIteratorError5 = !0), (_iteratorError5 = err);
                } finally {
                  try {
                    _iteratorNormalCompletion5 ||
                      null == _iterator5.return ||
                      _iterator5.return();
                  } finally {
                    if (_didIteratorError5) throw _iteratorError5;
                  }
                }
                length += 1;
              }
              cache.set(segment.id, length);
              return length;
            }
            var reactHooksMap = codePathReactHooksMapStack.pop();
            if (0 !== reactHooksMap.size) {
              var cyclic = new Set();
              countPathsFromStart.cache = new Map();
              countPathsToEnd.cache = new Map();
              shortestPathLengthToStart.cache = new Map();
              var allPathsFromStartToEnd = countPathsToEnd(
                  codePath.initialSegment
                ),
                codePathFunctionName = getFunctionName(codePathNode),
                isSomewhereInsideComponentOrHook = isInsideComponentOrHook(
                  codePathNode
                ),
                isDirectlyInsideComponentOrHook = codePathFunctionName
                  ? isComponentName(codePathFunctionName) ||
                    isHook(codePathFunctionName)
                  : !1,
                shortestFinalPathLength = Infinity,
                _iteratorNormalCompletion6 = !0,
                _didIteratorError6 = !1,
                _iteratorError6 = void 0;
              try {
                for (
                  var _iterator6 = codePath.finalSegments[Symbol.iterator](),
                    _step6;
                  !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next())
                    .done);
                  _iteratorNormalCompletion6 = !0
                ) {
                  var finalSegment = _step6.value;
                  if (finalSegment.reachable) {
                    var length$jscomp$0 = shortestPathLengthToStart(
                      finalSegment
                    );
                    length$jscomp$0 < shortestFinalPathLength &&
                      (shortestFinalPathLength = length$jscomp$0);
                  }
                }
              } catch (err) {
                (_didIteratorError6 = !0), (_iteratorError6 = err);
              } finally {
                try {
                  _iteratorNormalCompletion6 ||
                    null == _iterator6.return ||
                    _iterator6.return();
                } finally {
                  if (_didIteratorError6) throw _iteratorError6;
                }
              }
              _iteratorNormalCompletion6 = !0;
              _didIteratorError6 = !1;
              _iteratorError6 = void 0;
              try {
                for (
                  var _iterator7 = reactHooksMap[Symbol.iterator](), _step7;
                  !(_iteratorNormalCompletion6 = (_step7 = _iterator7.next())
                    .done);
                  _iteratorNormalCompletion6 = !0
                ) {
                  var _step7$value = _step7.value,
                    segment$jscomp$0 = _step7$value[0],
                    reactHooks = _step7$value[1];
                  if (segment$jscomp$0.reachable) {
                    var possiblyHasEarlyReturn =
                        0 === segment$jscomp$0.nextSegments.length
                          ? shortestFinalPathLength <=
                            shortestPathLengthToStart(segment$jscomp$0)
                          : shortestFinalPathLength <
                            shortestPathLengthToStart(segment$jscomp$0),
                      pathsFromStartToEnd =
                        countPathsFromStart(segment$jscomp$0) *
                        countPathsToEnd(segment$jscomp$0),
                      cycled = cyclic.has(segment$jscomp$0.id);
                    reactHooksMap = !0;
                    _iterator6 = !1;
                    _step6 = void 0;
                    try {
                      for (
                        var _iterator8 = reactHooks[Symbol.iterator](), _step8;
                        !(reactHooksMap = (_step8 = _iterator8.next()).done);
                        reactHooksMap = !0
                      ) {
                        var hook = _step8.value;
                        cycled &&
                          context.report({
                            node: hook,
                            message:
                              'React Hook "' +
                              context.getSource(hook) +
                              '" may be executed more than once. Possibly because it is called in a loop. React Hooks must be called in the exact same order in every component render.'
                          });
                        if (isDirectlyInsideComponentOrHook) {
                          if (
                            !cycled &&
                            pathsFromStartToEnd !== allPathsFromStartToEnd
                          ) {
                            var message =
                              'React Hook "' +
                              context.getSource(hook) +
                              '" is called conditionally. React Hooks must be called in the exact same order in every component render.' +
                              (possiblyHasEarlyReturn
                                ? " Did you accidentally call a React Hook after an early return?"
                                : "");
                            context.report({ node: hook, message: message });
                          }
                        } else if (
                          !codePathNode.parent ||
                          ("MethodDefinition" !== codePathNode.parent.type &&
                            "ClassProperty" !== codePathNode.parent.type) ||
                          codePathNode.parent.value !== codePathNode
                        )
                          if (codePathFunctionName) {
                            var _message =
                              'React Hook "' +
                              context.getSource(hook) +
                              '" is called in ' +
                              ('function "' +
                                context.getSource(codePathFunctionName) +
                                '" ') +
                              "which is neither a React function component or a custom React Hook function.";
                            context.report({ node: hook, message: _message });
                          } else if ("Program" === codePathNode.type) {
                            var _message2 =
                              'React Hook "' +
                              context.getSource(hook) +
                              '" cannot be called at the top level. React Hooks must be called in a React function component or a custom React Hook function.';
                            context.report({ node: hook, message: _message2 });
                          } else if (isSomewhereInsideComponentOrHook) {
                            var _message3 =
                              'React Hook "' +
                              context.getSource(hook) +
                              '" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.';
                            context.report({ node: hook, message: _message3 });
                          }
                      }
                    } catch (err) {
                      (_iterator6 = !0), (_step6 = err);
                    } finally {
                      try {
                        reactHooksMap ||
                          null == _iterator8.return ||
                          _iterator8.return();
                      } finally {
                        if (_iterator6) throw _step6;
                      }
                    }
                  }
                }
              } catch (err) {
                (_didIteratorError6 = !0), (_iteratorError6 = err);
              } finally {
                try {
                  _iteratorNormalCompletion6 ||
                    null == _iterator7.return ||
                    _iterator7.return();
                } finally {
                  if (_didIteratorError6) throw _iteratorError6;
                }
              }
            }
          },
          CallExpression: function(node) {
            if (isHook(node.callee)) {
              var reactHooksMap =
                  codePathReactHooksMapStack[
                    codePathReactHooksMapStack.length - 1
                  ],
                codePathSegment =
                  codePathSegmentStack[codePathSegmentStack.length - 1],
                reactHooks = reactHooksMap.get(codePathSegment);
              reactHooks ||
                ((reactHooks = []),
                reactHooksMap.set(codePathSegment, reactHooks));
              reactHooks.push(node.callee);
            }
          }
        };
      }
    },
    "exhaustive-deps": {
      meta: {
        fixable: "code",
        schema: [
          {
            type: "object",
            additionalProperties: !1,
            properties: { additionalHooks: { type: "string" } }
          }
        ]
      },
      create: function(context) {
        function memoizeWithWeakMap(fn, map) {
          return function(arg) {
            if (map.has(arg)) return map.get(arg);
            var result = fn(arg);
            map.set(arg, result);
            return result;
          };
        }
        function visitFunctionExpression(node) {
          function gatherDependenciesRecursively(currentScope) {
            var _iteratorNormalCompletion = !0,
              _didIteratorError = !1,
              _iteratorError = void 0;
            try {
              for (
                var _iterator = currentScope.references[Symbol.iterator](),
                  _step;
                !(_iteratorNormalCompletion = (_step = _iterator.next()).done);
                _iteratorNormalCompletion = !0
              ) {
                var reference = _step.value;
                if (
                  reference.resolved &&
                  pureScopes.has(reference.resolved.scope)
                ) {
                  var referenceNode = fastFindReferenceWithParent(
                      node,
                      reference.identifier
                    ),
                    dependencyNode = getDependency(referenceNode),
                    dependency = toPropertyAccessString(dependencyNode),
                    JSCompiler_temp;
                  if (
                    (JSCompiler_temp =
                      isEffect &&
                      "Identifier" === dependencyNode.type &&
                      "MemberExpression" === dependencyNode.parent.type &&
                      !dependencyNode.parent.computed &&
                      "Identifier" === dependencyNode.parent.property.type &&
                      "current" === dependencyNode.parent.property.name)
                  ) {
                    for (
                      var curScope = reference.from, isInReturnedFunction = !1;
                      curScope.block !== node;

                    )
                      "function" === curScope.type &&
                        (isInReturnedFunction =
                          null != curScope.block.parent &&
                          "ReturnStatement" === curScope.block.parent.type),
                        (curScope = curScope.upper);
                    JSCompiler_temp = isInReturnedFunction;
                  }
                  JSCompiler_temp &&
                    currentRefsInEffectCleanup.set(dependency, {
                      reference: reference,
                      dependencyNode: dependencyNode
                    });
                  var def = reference.resolved.defs[0];
                  if (
                    null != def &&
                    (null == def.node || def.node.init !== node.parent) &&
                    "TypeParameter" !== def.type
                  )
                    if (dependencies.has(dependency))
                      dependencies.get(dependency).references.push(reference);
                    else {
                      var resolved = reference.resolved,
                        isStatic =
                          memoizedIsStaticKnownHookValue(resolved) ||
                          memoizedIsFunctionWithoutCapturedValues(resolved);
                      dependencies.set(dependency, {
                        isStatic: isStatic,
                        references: [reference]
                      });
                    }
                }
              }
            } catch (err) {
              (_didIteratorError = !0), (_iteratorError = err);
            } finally {
              try {
                _iteratorNormalCompletion ||
                  null == _iterator.return ||
                  _iterator.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
            _iteratorNormalCompletion = !0;
            _didIteratorError = !1;
            _iteratorError = void 0;
            try {
              for (
                var _iterator2 = currentScope.childScopes[Symbol.iterator](),
                  _step2;
                !(_iteratorNormalCompletion = (_step2 = _iterator2.next())
                  .done);
                _iteratorNormalCompletion = !0
              )
                gatherDependenciesRecursively(_step2.value);
            } catch (err) {
              (_didIteratorError = !0), (_iteratorError = err);
            } finally {
              try {
                _iteratorNormalCompletion ||
                  null == _iterator2.return ||
                  _iterator2.return();
              } finally {
                if (_didIteratorError) throw _iteratorError;
              }
            }
          }
          function getWarningMessage(deps, singlePrefix, label, fixVerb) {
            return 0 === deps.size
              ? null
              : (1 < deps.size ? "" : singlePrefix + " ") +
                  label +
                  " " +
                  (1 < deps.size ? "dependencies" : "dependency") +
                  ": " +
                  joinEnglish(
                    Array.from(deps)
                      .sort()
                      .map(function(name) {
                        return "'" + name + "'";
                      })
                  ) +
                  (". Either " +
                    fixVerb +
                    " " +
                    (1 < deps.size ? "them" : "it") +
                    " or remove the dependency array.");
          }
          if (
            ("FunctionExpression" === node.type ||
              "ArrowFunctionExpression" === node.type) &&
            "CallExpression" === node.parent.type
          ) {
            var callbackIndex = getReactiveHookCallbackIndex(
              node.parent.callee,
              options
            );
            if (node.parent.arguments[callbackIndex] === node) {
              var reactiveHook = node.parent.callee,
                reactiveHookName = getNodeWithoutReactNamespace(reactiveHook)
                  .name,
                isEffect = reactiveHookName.endsWith("Effect"),
                declaredDependenciesNode =
                  node.parent.arguments[callbackIndex + 1];
              if (declaredDependenciesNode || isEffect) {
                isEffect &&
                  node.async &&
                  context.report({
                    node: node,
                    message:
                      "Effect callbacks are synchronous to prevent race conditions. Put the async function inside:\n\nuseEffect(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching"
                  });
                var scope = context.getScope(),
                  pureScopes = new Set(),
                  componentScope = null;
                for (callbackIndex = scope.upper; callbackIndex; ) {
                  pureScopes.add(callbackIndex);
                  if ("function" === callbackIndex.type) break;
                  callbackIndex = callbackIndex.upper;
                }
                if (callbackIndex) {
                  componentScope = callbackIndex;
                  var memoizedIsStaticKnownHookValue = memoizeWithWeakMap(
                      function(resolved) {
                        if (!Array.isArray(resolved.defs)) return !1;
                        var def = resolved.defs[0];
                        if (
                          null == def ||
                          "VariableDeclarator" !== def.node.type
                        )
                          return !1;
                        var init = def.node.init;
                        if (null == init) return !1;
                        var declaration = def.node.parent;
                        if (
                          null == declaration &&
                          (fastFindReferenceWithParent(
                            componentScope.block,
                            def.node.id
                          ),
                          (declaration = def.node.parent),
                          null == declaration)
                        )
                          return !1;
                        if (
                          "const" === declaration.kind &&
                          "Literal" === init.type &&
                          ("string" === typeof init.value ||
                            "number" === typeof init.value ||
                            null === init.value)
                        )
                          return !0;
                        if ("CallExpression" !== init.type) return !1;
                        init = init.callee;
                        "MemberExpression" !== init.type ||
                          "React" !== init.object.name ||
                          null == init.property ||
                          init.computed ||
                          (init = init.property);
                        if ("Identifier" !== init.type) return !1;
                        def = def.node.id;
                        init = init.name;
                        if ("useRef" === init && "Identifier" === def.type)
                          return !0;
                        if (
                          ("useState" === init || "useReducer" === init) &&
                          "ArrayPattern" === def.type &&
                          2 === def.elements.length &&
                          Array.isArray(resolved.identifiers)
                        ) {
                          if (def.elements[1] === resolved.identifiers[0]) {
                            if ("useState" === init)
                              for (
                                resolved = resolved.references, init = 0;
                                init < resolved.length;
                                init++
                              )
                                setStateCallSites.set(
                                  resolved[init].identifier,
                                  def.elements[0]
                                );
                            return !0;
                          }
                          if (
                            def.elements[0] === resolved.identifiers[0] &&
                            "useState" === init
                          )
                            for (
                              resolved = resolved.references, def = 0;
                              def < resolved.length;
                              def++
                            )
                              stateVariables.add(resolved[def].identifier);
                        }
                        return !1;
                      },
                      staticKnownValueCache
                    ),
                    memoizedIsFunctionWithoutCapturedValues = memoizeWithWeakMap(
                      function(resolved) {
                        if (!Array.isArray(resolved.defs)) return !1;
                        resolved = resolved.defs[0];
                        if (
                          null == resolved ||
                          null == resolved.node ||
                          null == resolved.node.id
                        )
                          return !1;
                        var fnNode = resolved.node,
                          childScopes = componentScope.childScopes;
                        resolved = null;
                        var i;
                        for (i = 0; i < childScopes.length; i++) {
                          var childScope = childScopes[i],
                            childScopeBlock = childScope.block;
                          if (
                            ("FunctionDeclaration" === fnNode.type &&
                              childScopeBlock === fnNode) ||
                            ("VariableDeclarator" === fnNode.type &&
                              childScopeBlock.parent === fnNode)
                          ) {
                            resolved = childScope;
                            break;
                          }
                        }
                        if (null == resolved) return !1;
                        for (i = 0; i < resolved.through.length; i++)
                          if (
                            ((fnNode = resolved.through[i]),
                            null != fnNode.resolved &&
                              pureScopes.has(fnNode.resolved.scope) &&
                              !memoizedIsStaticKnownHookValue(fnNode.resolved))
                          )
                            return !1;
                        return !0;
                      },
                      functionWithoutCapturedValueCache
                    ),
                    currentRefsInEffectCleanup = new Map(),
                    dependencies = new Map();
                  gatherDependenciesRecursively(scope);
                  currentRefsInEffectCleanup.forEach(function(
                    _ref,
                    dependency
                  ) {
                    var dependencyNode = _ref.dependencyNode;
                    _ref = _ref.reference.resolved.references;
                    for (
                      var foundCurrentAssignment = !1, i = 0;
                      i < _ref.length;
                      i++
                    ) {
                      var parent = _ref[i].identifier.parent;
                      if (
                        null != parent &&
                        "MemberExpression" === parent.type &&
                        !parent.computed &&
                        "Identifier" === parent.property.type &&
                        "current" === parent.property.name &&
                        "AssignmentExpression" === parent.parent.type &&
                        parent.parent.left === parent
                      ) {
                        foundCurrentAssignment = !0;
                        break;
                      }
                    }
                    foundCurrentAssignment ||
                      context.report({
                        node: dependencyNode.parent.property,
                        message:
                          "The ref value '" +
                          dependency +
                          ".current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy " +
                          ("'" +
                            dependency +
                            ".current' to a variable inside the effect, and ") +
                          "use that variable in the cleanup function."
                      });
                  });
                  var staleAssignments = new Set(),
                    optionalDependencies = new Set();
                  dependencies.forEach(function(_ref2, key) {
                    var references = _ref2.references;
                    _ref2.isStatic && optionalDependencies.add(key);
                    references.forEach(function(reference) {
                      reference.writeExpr &&
                        ((reference = reference.writeExpr),
                        staleAssignments.has(key) ||
                          (staleAssignments.add(key),
                          context.report({
                            node: reference,
                            message:
                              "Assignments to the '" +
                              key +
                              "' variable from inside React Hook " +
                              (context.getSource(reactiveHook) +
                                " will be lost after each ") +
                              "render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside " +
                              (context.getSource(reactiveHook) + ".")
                          })));
                    });
                  });
                  if (!(0 < staleAssignments.size))
                    if (declaredDependenciesNode) {
                      var declaredDependencies = [],
                        externalDependencies = new Set();
                      "ArrayExpression" !== declaredDependenciesNode.type
                        ? context.report({
                            node: declaredDependenciesNode,
                            message:
                              "React Hook " +
                              context.getSource(reactiveHook) +
                              " was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies."
                          })
                        : declaredDependenciesNode.elements.forEach(function(
                            declaredDependencyNode
                          ) {
                            if (null !== declaredDependencyNode)
                              if (
                                "SpreadElement" === declaredDependencyNode.type
                              )
                                context.report({
                                  node: declaredDependencyNode,
                                  message:
                                    "React Hook " +
                                    context.getSource(reactiveHook) +
                                    " has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies."
                                });
                              else {
                                try {
                                  var declaredDependency = toPropertyAccessString(
                                    declaredDependencyNode
                                  );
                                } catch (error) {
                                  if (
                                    /Unsupported node type/.test(error.message)
                                  ) {
                                    "Literal" === declaredDependencyNode.type
                                      ? dependencies.has(
                                          declaredDependencyNode.value
                                        )
                                        ? context.report({
                                            node: declaredDependencyNode,
                                            message:
                                              "The " +
                                              declaredDependencyNode.raw +
                                              " literal is not a valid dependency because it never changes. " +
                                              ("Did you mean to include " +
                                                declaredDependencyNode.value +
                                                " in the array instead?")
                                          })
                                        : context.report({
                                            node: declaredDependencyNode,
                                            message:
                                              "The " +
                                              declaredDependencyNode.raw +
                                              " literal is not a valid dependency because it never changes. You can safely remove it."
                                          })
                                      : context.report({
                                          node: declaredDependencyNode,
                                          message:
                                            "React Hook " +
                                            context.getSource(reactiveHook) +
                                            " has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked."
                                        });
                                    return;
                                  }
                                  throw error;
                                }
                                for (
                                  var maybeID = declaredDependencyNode;
                                  "MemberExpression" === maybeID.type;

                                )
                                  maybeID = maybeID.object;
                                var isDeclaredInComponent = !componentScope.through.some(
                                  function(ref) {
                                    return ref.identifier === maybeID;
                                  }
                                );
                                declaredDependencies.push({
                                  key: declaredDependency,
                                  node: declaredDependencyNode
                                });
                                isDeclaredInComponent ||
                                  externalDependencies.add(declaredDependency);
                              }
                          });
                      var _collectRecommendatio2 = collectRecommendations({
                          dependencies: dependencies,
                          declaredDependencies: declaredDependencies,
                          optionalDependencies: optionalDependencies,
                          externalDependencies: externalDependencies,
                          isEffect: isEffect
                        }),
                        suggestedDependencies =
                          _collectRecommendatio2.suggestedDependencies;
                      callbackIndex =
                        _collectRecommendatio2.unnecessaryDependencies;
                      var missingDependencies =
                        _collectRecommendatio2.missingDependencies;
                      _collectRecommendatio2 =
                        _collectRecommendatio2.duplicateDependencies;
                      if (
                        0 ===
                        _collectRecommendatio2.size +
                          missingDependencies.size +
                          callbackIndex.size
                      )
                        scanForDeclaredBareFunctions({
                          declaredDependencies: declaredDependencies,
                          declaredDependenciesNode: declaredDependenciesNode,
                          componentScope: componentScope,
                          scope: scope
                        }).forEach(function(_ref4) {
                          var fn = _ref4.fn,
                            suggestUseCallback = _ref4.suggestUseCallback;
                          _ref4 =
                            "The '" +
                            fn.name.name +
                            "' function makes the dependencies of " +
                            (reactiveHookName +
                              " Hook (at line " +
                              declaredDependenciesNode.loc.start.line +
                              ") ") +
                            "change on every render.";
                          _ref4 = suggestUseCallback
                            ? _ref4 +
                              (" To fix this, " +
                                ("wrap the '" +
                                  fn.name.name +
                                  "' definition into its own useCallback() Hook."))
                            : _ref4 +
                              (" Move it inside the " +
                                reactiveHookName +
                                " callback. " +
                                ("Alternatively, wrap the '" +
                                  fn.name.name +
                                  "' definition into its own useCallback() Hook."));
                          context.report({
                            node: fn.node,
                            message: _ref4,
                            fix: function(fixer) {
                              if (suggestUseCallback && "Variable" === fn.type)
                                return [
                                  fixer.insertTextBefore(
                                    fn.node.init,
                                    "useCallback("
                                  ),
                                  fixer.insertTextAfter(fn.node.init, ")")
                                ];
                            }
                          });
                        });
                      else {
                        !isEffect &&
                          0 < missingDependencies.size &&
                          (suggestedDependencies = collectRecommendations({
                            dependencies: dependencies,
                            declaredDependencies: [],
                            optionalDependencies: optionalDependencies,
                            externalDependencies: externalDependencies,
                            isEffect: isEffect
                          }).suggestedDependencies);
                        (function() {
                          if (0 === declaredDependencies.length) return !0;
                          var declaredDepKeys = declaredDependencies.map(
                              function(dep) {
                                return dep.key;
                              }
                            ),
                            sortedDeclaredDepKeys = declaredDepKeys
                              .slice()
                              .sort();
                          return (
                            declaredDepKeys.join(",") ===
                            sortedDeclaredDepKeys.join(",")
                          );
                        })() && suggestedDependencies.sort();
                        var extraWarning = "";
                        if (0 < callbackIndex.size) {
                          var badRef = null;
                          Array.from(callbackIndex.keys()).forEach(function(
                            key
                          ) {
                            null === badRef &&
                              key.endsWith(".current") &&
                              (badRef = key);
                          });
                          if (null !== badRef)
                            extraWarning =
                              " Mutable values like '" +
                              badRef +
                              "' aren't valid dependencies because mutating them doesn't re-render the component.";
                          else if (0 < externalDependencies.size) {
                            var dep = Array.from(externalDependencies)[0];
                            scope.set.has(dep) ||
                              (extraWarning =
                                " Outer scope values like '" +
                                dep +
                                "' aren't valid dependencies because mutating them doesn't re-render the component.");
                          }
                        }
                        if (!extraWarning && missingDependencies.has("props")) {
                          scope = dependencies.get("props");
                          if (null == scope) return;
                          scope = scope.references;
                          if (!Array.isArray(scope)) return;
                          dep = !0;
                          for (var i = 0; i < scope.length; i++) {
                            var id = fastFindReferenceWithParent(
                              componentScope.block,
                              scope[i].identifier
                            );
                            if (!id) {
                              dep = !1;
                              break;
                            }
                            id = id.parent;
                            if (null == id) {
                              dep = !1;
                              break;
                            }
                            if ("MemberExpression" !== id.type) {
                              dep = !1;
                              break;
                            }
                          }
                          dep &&
                            (extraWarning =
                              " However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of " +
                              ("the " +
                                reactiveHookName +
                                " call and refer to those specific props ") +
                              ("inside " +
                                context.getSource(reactiveHook) +
                                "."));
                        }
                        if (!extraWarning && 0 < missingDependencies.size) {
                          var missingCallbackDep = null;
                          missingDependencies.forEach(function(missingDep) {
                            if (!missingCallbackDep) {
                              var topScopeRef = componentScope.set.get(
                                  missingDep
                                ),
                                usedDep = dependencies.get(missingDep);
                              if (
                                usedDep.references[0].resolved ===
                                  topScopeRef &&
                                ((topScopeRef = topScopeRef.defs[0]),
                                null != topScopeRef &&
                                  null != topScopeRef.name &&
                                  "Parameter" === topScopeRef.type)
                              ) {
                                topScopeRef = !1;
                                for (
                                  var id, _i2 = 0;
                                  _i2 < usedDep.references.length;
                                  _i2++
                                )
                                  if (
                                    ((id = usedDep.references[_i2].identifier),
                                    null != id &&
                                      null != id.parent &&
                                      "CallExpression" === id.parent.type &&
                                      id.parent.callee === id)
                                  ) {
                                    topScopeRef = !0;
                                    break;
                                  }
                                topScopeRef &&
                                  (missingCallbackDep = missingDep);
                              }
                            }
                          });
                          null !== missingCallbackDep &&
                            (extraWarning =
                              " If '" +
                              missingCallbackDep +
                              "' changes too often, find the parent component that defines it and wrap that definition in useCallback.");
                        }
                        if (!extraWarning && 0 < missingDependencies.size) {
                          var setStateRecommendation = null;
                          missingDependencies.forEach(function(missingDep) {
                            if (null === setStateRecommendation)
                              for (
                                var references = dependencies.get(missingDep)
                                    .references,
                                  id,
                                  maybeCall,
                                  _i3 = 0;
                                _i3 < references.length;
                                _i3++
                              ) {
                                id = references[_i3].identifier;
                                for (
                                  maybeCall = id.parent;
                                  null != maybeCall &&
                                  maybeCall !== componentScope.block;

                                ) {
                                  if ("CallExpression" === maybeCall.type) {
                                    var correspondingStateVariable = setStateCallSites.get(
                                      maybeCall.callee
                                    );
                                    if (null != correspondingStateVariable) {
                                      correspondingStateVariable.name ===
                                      missingDep
                                        ? (setStateRecommendation = {
                                            missingDep: missingDep,
                                            setter: maybeCall.callee.name,
                                            form: "updater"
                                          })
                                        : stateVariables.has(id)
                                          ? (setStateRecommendation = {
                                              missingDep: missingDep,
                                              setter: maybeCall.callee.name,
                                              form: "reducer"
                                            })
                                          : ((id = references[_i3].resolved),
                                            null != id &&
                                              ((id = id.defs[0]),
                                              null != id &&
                                                "Parameter" === id.type &&
                                                (setStateRecommendation = {
                                                  missingDep: missingDep,
                                                  setter: maybeCall.callee.name,
                                                  form: "inlineReducer"
                                                })));
                                      break;
                                    }
                                  }
                                  maybeCall = maybeCall.parent;
                                }
                                if (null !== setStateRecommendation) break;
                              }
                          });
                          if (null !== setStateRecommendation)
                            switch (setStateRecommendation.form) {
                              case "reducer":
                                extraWarning =
                                  " You can also replace multiple useState variables with useReducer " +
                                  ("if '" +
                                    setStateRecommendation.setter +
                                    "' needs the ") +
                                  ("current value of '" +
                                    setStateRecommendation.missingDep +
                                    "'.");
                                break;
                              case "inlineReducer":
                                extraWarning =
                                  " If '" +
                                  setStateRecommendation.setter +
                                  "' needs the " +
                                  ("current value of '" +
                                    setStateRecommendation.missingDep +
                                    "', ") +
                                  "you can also switch to useReducer instead of useState and " +
                                  ("read '" +
                                    setStateRecommendation.missingDep +
                                    "' in the reducer.");
                                break;
                              case "updater":
                                extraWarning =
                                  " You can also do a functional update '" +
                                  setStateRecommendation.setter +
                                  "(" +
                                  setStateRecommendation.missingDep.substring(
                                    0,
                                    1
                                  ) +
                                  " => ...)' if you only need '" +
                                  setStateRecommendation.missingDep +
                                  "'" +
                                  (" in the '" +
                                    setStateRecommendation.setter +
                                    "' call.");
                                break;
                              default:
                                throw Error("Unknown case.");
                            }
                        }
                        context.report({
                          node: declaredDependenciesNode,
                          message:
                            "React Hook " +
                            context.getSource(reactiveHook) +
                            " has " +
                            (getWarningMessage(
                              missingDependencies,
                              "a",
                              "missing",
                              "include"
                            ) ||
                              getWarningMessage(
                                callbackIndex,
                                "an",
                                "unnecessary",
                                "exclude"
                              ) ||
                              getWarningMessage(
                                _collectRecommendatio2,
                                "a",
                                "duplicate",
                                "omit"
                              )) +
                            extraWarning,
                          fix: function(fixer) {
                            return fixer.replaceText(
                              declaredDependenciesNode,
                              "[" + suggestedDependencies.join(", ") + "]"
                            );
                          }
                        });
                      }
                    } else {
                      var setStateInsideEffectWithoutDeps = null;
                      dependencies.forEach(function(_ref3, key) {
                        setStateInsideEffectWithoutDeps ||
                          _ref3.references.forEach(function(reference) {
                            if (
                              !setStateInsideEffectWithoutDeps &&
                              setStateCallSites.has(reference.identifier)
                            ) {
                              for (
                                reference = reference.from;
                                "function" !== reference.type;

                              )
                                reference = reference.upper;
                              reference.block === node &&
                                (setStateInsideEffectWithoutDeps = key);
                            }
                          });
                      });
                      if (setStateInsideEffectWithoutDeps) {
                        var _suggestedDependencies = collectRecommendations({
                          dependencies: dependencies,
                          declaredDependencies: [],
                          optionalDependencies: optionalDependencies,
                          externalDependencies: new Set(),
                          isEffect: !0
                        }).suggestedDependencies;
                        context.report({
                          node: node.parent.callee,
                          message:
                            "React Hook " +
                            reactiveHookName +
                            " contains a call to '" +
                            setStateInsideEffectWithoutDeps +
                            "'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [" +
                            _suggestedDependencies.join(", ") +
                            ("] as a second argument to the " +
                              reactiveHookName +
                              " Hook."),
                          fix: function(fixer) {
                            return fixer.insertTextAfter(
                              node,
                              ", [" + _suggestedDependencies.join(", ") + "]"
                            );
                          }
                        });
                      }
                    }
                }
              } else
                ("useMemo" !== reactiveHookName &&
                  "useCallback" !== reactiveHookName) ||
                  context.report({
                    node: node.parent.callee,
                    message:
                      "React Hook " +
                      reactiveHookName +
                      " does nothing when called with only one argument. Did you forget to pass an array of dependencies?"
                  });
            }
          }
        }
        var options = {
            additionalHooks:
              context.options &&
              context.options[0] &&
              context.options[0].additionalHooks
                ? new RegExp(context.options[0].additionalHooks)
                : void 0
          },
          setStateCallSites = new WeakMap(),
          stateVariables = new WeakSet(),
          staticKnownValueCache = new WeakMap(),
          functionWithoutCapturedValueCache = new WeakMap();
        return {
          FunctionExpression: visitFunctionExpression,
          ArrowFunctionExpression: visitFunctionExpression
        };
      }
    }
  }
};
module.exports = (src && src["default"]) || src;

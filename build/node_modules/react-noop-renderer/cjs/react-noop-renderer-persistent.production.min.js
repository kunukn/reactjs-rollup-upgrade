/** @license React vundefined
 * react-noop-renderer-persistent.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const regeneratorRuntime = require("regenerator-runtime");
"use strict";
var ReactFiberPersistentReconciler = require("react-reconciler/persistent"),
  _assign = require("object-assign"),
  Scheduler = require("scheduler/unstable_mock"),
  expect = require("expect"),
  React = require("react"),
  hasSymbol = "function" === typeof Symbol && Symbol.for,
  REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103,
  REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
  REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
function createPortal(children, containerInfo, implementation) {
  var key =
    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var enqueueTask;
try {
  var requireString = ("require" + Math.random()).slice(0, 7);
  enqueueTask = (module && module[requireString])("timers").setImmediate;
} catch (_err) {
  enqueueTask = function(callback) {
    var channel = new MessageChannel();
    channel.port1.onmessage = callback;
    channel.port2.postMessage(void 0);
  };
}
var enqueueTask$1 = enqueueTask,
  ReactSharedInternals =
    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher") ||
  (ReactSharedInternals.ReactCurrentDispatcher = { current: null });
ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig") ||
  (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null });
var IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing,
  NO_CONTEXT = {},
  UPPERCASE_CONTEXT = {},
  UPDATE_SIGNAL = {},
  ReactNoopPersistent = (function(reconciler, useMutation) {
    function appendChildToContainerOrInstance(parentInstance, child) {
      var index = parentInstance.children.indexOf(child);
      -1 !== index && parentInstance.children.splice(index, 1);
      parentInstance.children.push(child);
    }
    function appendChildToContainer(parentInstance, child) {
      if ("string" !== typeof parentInstance.rootID)
        throw Error(
          "appendChildToContainer() first argument is not a container."
        );
      appendChildToContainerOrInstance(parentInstance, child);
    }
    function appendChild(parentInstance, child) {
      if ("string" === typeof parentInstance.rootID)
        throw Error("appendChild() first argument is not an instance.");
      appendChildToContainerOrInstance(parentInstance, child);
    }
    function insertInContainerOrInstanceBefore(
      parentInstance,
      child,
      beforeChild
    ) {
      var index = parentInstance.children.indexOf(child);
      -1 !== index && parentInstance.children.splice(index, 1);
      beforeChild = parentInstance.children.indexOf(beforeChild);
      if (-1 === beforeChild) throw Error("This child does not exist.");
      parentInstance.children.splice(beforeChild, 0, child);
    }
    function insertInContainerBefore(parentInstance, child, beforeChild) {
      if ("string" !== typeof parentInstance.rootID)
        throw Error(
          "insertInContainerBefore() first argument is not a container."
        );
      insertInContainerOrInstanceBefore(parentInstance, child, beforeChild);
    }
    function insertBefore(parentInstance, child, beforeChild) {
      if ("string" === typeof parentInstance.rootID)
        throw Error("insertBefore() first argument is not an instance.");
      insertInContainerOrInstanceBefore(parentInstance, child, beforeChild);
    }
    function removeChildFromContainerOrInstance(parentInstance, child) {
      child = parentInstance.children.indexOf(child);
      if (-1 === child) throw Error("This child does not exist.");
      parentInstance.children.splice(child, 1);
    }
    function removeChildFromContainer(parentInstance, child) {
      if ("string" !== typeof parentInstance.rootID)
        throw Error(
          "removeChildFromContainer() first argument is not a container."
        );
      removeChildFromContainerOrInstance(parentInstance, child);
    }
    function removeChild(parentInstance, child) {
      if ("string" === typeof parentInstance.rootID)
        throw Error("removeChild() first argument is not an instance.");
      removeChildFromContainerOrInstance(parentInstance, child);
    }
    function cloneInstance(
      instance,
      updatePayload,
      type,
      oldProps,
      newProps,
      internalInstanceHandle,
      keepChildren
    ) {
      instance = {
        id: instance.id,
        type: type,
        children: keepChildren ? instance.children : [],
        text: shouldSetTextContent(type, newProps)
          ? computeText(newProps.children + "", instance.context)
          : null,
        prop: newProps.prop,
        hidden: !0 === newProps.hidden,
        context: instance.context
      };
      Object.defineProperty(instance, "id", {
        value: instance.id,
        enumerable: !1
      });
      Object.defineProperty(instance, "text", {
        value: instance.text,
        enumerable: !1
      });
      Object.defineProperty(instance, "context", {
        value: instance.context,
        enumerable: !1
      });
      hostCloneCounter++;
      return instance;
    }
    function shouldSetTextContent(type, props) {
      if ("errorInBeginPhase" === type) throw Error("Error in host config.");
      return (
        "string" === typeof props.children || "number" === typeof props.children
      );
    }
    function computeText(rawText, hostContext) {
      return hostContext === UPPERCASE_CONTEXT
        ? rawText.toUpperCase()
        : rawText;
    }
    function flushWorkAndMicroTasks(onDone) {
      try {
        flushWork(),
          enqueueTask$1(function() {
            flushWork() ? flushWorkAndMicroTasks(onDone) : onDone();
          });
      } catch (err) {
        onDone(err);
      }
    }
    function childToJSX(child, text) {
      if (null !== text) return text;
      if (null === child) return null;
      if ("string" === typeof child) return child;
      if (Array.isArray(child)) {
        if (0 === child.length) return null;
        if (1 === child.length) return childToJSX(child[0], null);
        child = child.map(function(c) {
          return childToJSX(c, null);
        });
        return child.every(function(c) {
          return "string" === typeof c || "number" === typeof c;
        })
          ? child.join("")
          : child;
      }
      if (Array.isArray(child.children)) {
        text = childToJSX(child.children, child.text);
        var props = { prop: child.prop };
        child.hidden && (props.hidden = !0);
        null !== text && (props.children = text);
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type: child.type,
          key: null,
          ref: null,
          props: props,
          _owner: null,
          _store: void 0
        };
      }
      return child.hidden ? "" : child.text;
    }
    function getChildrenAsJSX(root) {
      root = childToJSX(root ? root.children : null, null);
      return null === root
        ? null
        : Array.isArray(root)
          ? {
              $$typeof: REACT_ELEMENT_TYPE,
              type: REACT_FRAGMENT_TYPE,
              key: null,
              ref: null,
              props: { children: root },
              _owner: null,
              _store: void 0
            }
          : root;
    }
    var instanceCounter = 0,
      hostDiffCounter = 0,
      hostUpdateCounter = 0,
      hostCloneCounter = 0,
      sharedHostConfig = {
        getRootHostContext: function() {
          return NO_CONTEXT;
        },
        getChildHostContext: function(parentHostContext, type) {
          return "uppercase" === type ? UPPERCASE_CONTEXT : NO_CONTEXT;
        },
        getPublicInstance: function(instance) {
          return instance;
        },
        createInstance: function(
          type,
          props,
          rootContainerInstance,
          hostContext
        ) {
          if ("errorInCompletePhase" === type)
            throw Error("Error in host config.");
          type = {
            id: instanceCounter++,
            type: type,
            children: [],
            text: shouldSetTextContent(type, props)
              ? computeText(props.children + "", hostContext)
              : null,
            prop: props.prop,
            hidden: !0 === props.hidden,
            context: hostContext
          };
          Object.defineProperty(type, "id", { value: type.id, enumerable: !1 });
          Object.defineProperty(type, "text", {
            value: type.text,
            enumerable: !1
          });
          Object.defineProperty(type, "context", {
            value: type.context,
            enumerable: !1
          });
          return type;
        },
        appendInitialChild: function(parentInstance, child) {
          parentInstance.children.push(child);
        },
        finalizeInitialChildren: function() {
          return !1;
        },
        prepareUpdate: function(instance, type, oldProps, newProps) {
          if ("errorInCompletePhase" === type)
            throw Error("Error in host config.");
          if (null === oldProps) throw Error("Should have old props");
          if (null === newProps) throw Error("Should have new props");
          hostDiffCounter++;
          return UPDATE_SIGNAL;
        },
        shouldSetTextContent: shouldSetTextContent,
        shouldDeprioritizeSubtree: function(type, props) {
          return !!props.hidden;
        },
        createTextInstance: function(text, rootContainerInstance, hostContext) {
          hostContext === UPPERCASE_CONTEXT && (text = text.toUpperCase());
          text = {
            text: text,
            id: instanceCounter++,
            hidden: !1,
            context: hostContext
          };
          Object.defineProperty(text, "id", { value: text.id, enumerable: !1 });
          Object.defineProperty(text, "context", {
            value: text.context,
            enumerable: !1
          });
          return text;
        },
        scheduleTimeout: setTimeout,
        cancelTimeout: clearTimeout,
        noTimeout: -1,
        prepareForCommit: function() {},
        resetAfterCommit: function() {},
        now: Scheduler.unstable_now,
        isPrimaryRenderer: !0,
        warnsIfNotActing: !0,
        supportsHydration: !1,
        mountResponderInstance: function() {},
        unmountResponderInstance: function() {},
        getFundamentalComponentInstance: function(fundamentalInstance) {
          return fundamentalInstance.impl.getInstance(
            null,
            fundamentalInstance.props,
            fundamentalInstance.state
          );
        },
        mountFundamentalComponent: function(fundamentalInstance) {
          var instance = fundamentalInstance.instance,
            props = fundamentalInstance.props,
            state = fundamentalInstance.state;
          fundamentalInstance = fundamentalInstance.impl.onUpdate;
          void 0 !== fundamentalInstance &&
            fundamentalInstance(null, instance, props, state);
        },
        shouldUpdateFundamentalComponent: function(fundamentalInstance) {
          var instance = fundamentalInstance.instance,
            prevProps = fundamentalInstance.prevProps,
            props = fundamentalInstance.props,
            state = fundamentalInstance.state;
          fundamentalInstance = fundamentalInstance.impl.shouldUpdate;
          return void 0 !== fundamentalInstance
            ? fundamentalInstance(null, instance, prevProps, props, state)
            : !0;
        },
        updateFundamentalComponent: function(fundamentalInstance) {
          var instance = fundamentalInstance.instance,
            prevProps = fundamentalInstance.prevProps,
            props = fundamentalInstance.props,
            state = fundamentalInstance.state;
          fundamentalInstance = fundamentalInstance.impl.onUpdate;
          void 0 !== fundamentalInstance &&
            fundamentalInstance(null, instance, prevProps, props, state);
        },
        unmountFundamentalComponent: function(fundamentalInstance) {
          var instance = fundamentalInstance.instance,
            props = fundamentalInstance.props,
            state = fundamentalInstance.state;
          fundamentalInstance = fundamentalInstance.impl.onUnmount;
          void 0 !== fundamentalInstance &&
            fundamentalInstance(null, instance, props, state);
        },
        cloneFundamentalInstance: function(fundamentalInstance) {
          fundamentalInstance = fundamentalInstance.instance;
          return {
            children: [],
            text: fundamentalInstance.text,
            type: fundamentalInstance.type,
            prop: fundamentalInstance.prop,
            id: fundamentalInstance.id,
            context: fundamentalInstance.context,
            hidden: fundamentalInstance.hidden
          };
        }
      };
    sharedHostConfig = useMutation
      ? _assign({}, sharedHostConfig, {
          supportsMutation: !0,
          supportsPersistence: !1,
          commitMount: function() {},
          commitUpdate: function(
            instance,
            updatePayload,
            type,
            oldProps,
            newProps
          ) {
            if (null === oldProps) throw Error("Should have old props");
            hostUpdateCounter++;
            instance.prop = newProps.prop;
            instance.hidden = !0 === newProps.hidden;
            shouldSetTextContent(type, newProps) &&
              (instance.text = computeText(
                newProps.children + "",
                instance.context
              ));
          },
          commitTextUpdate: function(textInstance, oldText, newText) {
            hostUpdateCounter++;
            textInstance.text = computeText(newText, textInstance.context);
          },
          appendChild: appendChild,
          appendChildToContainer: appendChildToContainer,
          insertBefore: insertBefore,
          insertInContainerBefore: insertInContainerBefore,
          removeChild: removeChild,
          removeChildFromContainer: removeChildFromContainer,
          hideInstance: function(instance) {
            instance.hidden = !0;
          },
          hideTextInstance: function(textInstance) {
            textInstance.hidden = !0;
          },
          unhideInstance: function(instance, props) {
            props.hidden || (instance.hidden = !1);
          },
          unhideTextInstance: function(textInstance) {
            textInstance.hidden = !1;
          },
          resetTextContent: function(instance) {
            instance.text = null;
          }
        })
      : _assign({}, sharedHostConfig, {
          supportsMutation: !1,
          supportsPersistence: !0,
          cloneInstance: cloneInstance,
          createContainerChildSet: function() {
            return [];
          },
          appendChildToContainerChildSet: function(childSet, child) {
            childSet.push(child);
          },
          finalizeContainerChildren: function(container, newChildren) {
            container.pendingChildren = newChildren;
          },
          replaceContainerChildren: function(container, newChildren) {
            container.children = newChildren;
          },
          cloneHiddenInstance: function(
            instance,
            type,
            props,
            internalInstanceHandle
          ) {
            instance = cloneInstance(
              instance,
              null,
              type,
              props,
              props,
              internalInstanceHandle,
              !0,
              null
            );
            instance.hidden = !0;
            return instance;
          },
          cloneHiddenTextInstance: function(instance) {
            instance = {
              text: instance.text,
              id: instanceCounter++,
              hidden: !0,
              context: instance.context
            };
            Object.defineProperty(instance, "id", {
              value: instance.id,
              enumerable: !1
            });
            Object.defineProperty(instance, "context", {
              value: instance.context,
              enumerable: !1
            });
            return instance;
          }
        });
    var NoopRenderer = reconciler(sharedHostConfig),
      rootContainers = new Map(),
      roots = new Map(),
      flushPassiveEffects = NoopRenderer.flushPassiveEffects,
      batchedUpdates = NoopRenderer.batchedUpdates,
      IsThisRendererActing = NoopRenderer.IsThisRendererActing,
      isSchedulerMocked =
        "function" === typeof Scheduler.unstable_flushAllWithoutAsserting,
      flushWork =
        Scheduler.unstable_flushAllWithoutAsserting ||
        function() {
          for (var didFlushWork = !1; flushPassiveEffects(); )
            didFlushWork = !0;
          return didFlushWork;
        },
      actingUpdatesScopeDepth = 0,
      didWarnAboutUsingActInProd = !1,
      idCounter = 0,
      ReactNoop = {
        _Scheduler: Scheduler,
        getChildren: function() {
          var container = rootContainers.get(
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : "<default>"
          );
          return container ? container.children : null;
        },
        getPendingChildren: function() {
          var container = rootContainers.get(
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : "<default>"
          );
          container = container ? container.pendingChildren : null;
          return container;
        },
        getOrCreateRootContainer: function() {
          var rootID =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : "<default>",
            tag = 1 < arguments.length ? arguments[1] : void 0,
            root = roots.get(rootID);
          root ||
            ((root = { rootID: rootID, pendingChildren: [], children: [] }),
            rootContainers.set(rootID, root),
            (root = NoopRenderer.createContainer(root, tag, !1, null)),
            roots.set(rootID, root));
          return root.current.stateNode.containerInfo;
        },
        createRoot: function() {
          var container = {
              rootID: "" + idCounter++,
              pendingChildren: [],
              children: []
            },
            fiberRoot = NoopRenderer.createContainer(container, 2, !1, null);
          return {
            _Scheduler: Scheduler,
            render: function(children) {
              NoopRenderer.updateContainer(children, fiberRoot, null, null);
            },
            getChildren: function() {
              return container ? container.children : null;
            },
            getChildrenAsJSX: function() {
              return getChildrenAsJSX(container);
            }
          };
        },
        createSyncRoot: function() {
          var container = {
              rootID: "" + idCounter++,
              pendingChildren: [],
              children: []
            },
            fiberRoot = NoopRenderer.createContainer(container, 1, !1, null);
          return {
            _Scheduler: Scheduler,
            render: function(children) {
              NoopRenderer.updateContainer(children, fiberRoot, null, null);
            },
            getChildren: function() {
              return container ? container.children : null;
            },
            getChildrenAsJSX: function() {
              return getChildrenAsJSX(container);
            }
          };
        },
        getChildrenAsJSX: function() {
          var container = rootContainers.get(
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : "<default>"
          );
          return getChildrenAsJSX(container);
        },
        getPendingChildrenAsJSX: function() {
          var container = rootContainers.get(
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : "<default>"
          );
          container = childToJSX(container ? container.children : null, null);
          container =
            null === container
              ? null
              : Array.isArray(container)
                ? {
                    $$typeof: REACT_ELEMENT_TYPE,
                    type: REACT_FRAGMENT_TYPE,
                    key: null,
                    ref: null,
                    props: { children: container },
                    _owner: null,
                    _store: void 0
                  }
                : container;
          return container;
        },
        createPortal: function(children, container) {
          return createPortal(
            children,
            container,
            null,
            2 < arguments.length && void 0 !== arguments[2]
              ? arguments[2]
              : null
          );
        },
        render: function(element, callback) {
          ReactNoop.renderToRootWithID(element, "<default>", callback);
        },
        renderLegacySyncRoot: function(element, callback) {
          var container = ReactNoop.getOrCreateRootContainer("<default>", 0);
          container = roots.get(container.rootID);
          NoopRenderer.updateContainer(element, container, null, callback);
        },
        renderToRootWithID: function(element, rootID, callback) {
          rootID = ReactNoop.getOrCreateRootContainer(rootID, 2);
          rootID = roots.get(rootID.rootID);
          NoopRenderer.updateContainer(element, rootID, null, callback);
        },
        unmountRootWithID: function(rootID) {
          var root = roots.get(rootID);
          root &&
            NoopRenderer.updateContainer(null, root, null, function() {
              roots.delete(rootID);
              rootContainers.delete(rootID);
            });
        },
        findInstance: function(componentOrElement) {
          return null == componentOrElement
            ? null
            : "number" === typeof componentOrElement.id
              ? componentOrElement
              : NoopRenderer.findHostInstance(componentOrElement);
        },
        flushNextYield: function() {
          Scheduler.unstable_flushNumberOfYields(1);
          return Scheduler.unstable_clearYields();
        },
        flushWithHostCounters: function() {
          hostCloneCounter = hostUpdateCounter = hostDiffCounter = 0;
          try {
            return (
              Scheduler.unstable_flushAll(),
              useMutation
                ? {
                    hostDiffCounter: hostDiffCounter,
                    hostUpdateCounter: hostUpdateCounter
                  }
                : {
                    hostDiffCounter: hostDiffCounter,
                    hostCloneCounter: hostCloneCounter
                  }
            );
          } finally {
            hostCloneCounter = hostUpdateCounter = hostDiffCounter = 0;
          }
        },
        expire: Scheduler.unstable_advanceTime,
        flushExpired: function() {
          return Scheduler.unstable_flushExpired();
        },
        batchedUpdates: NoopRenderer.batchedUpdates,
        deferredUpdates: NoopRenderer.deferredUpdates,
        unbatchedUpdates: NoopRenderer.unbatchedUpdates,
        discreteUpdates: NoopRenderer.discreteUpdates,
        flushDiscreteUpdates: NoopRenderer.flushDiscreteUpdates,
        flushSync: function(fn) {
          NoopRenderer.flushSync(fn);
        },
        flushPassiveEffects: NoopRenderer.flushPassiveEffects,
        act: function(callback) {
          function onDone() {
            actingUpdatesScopeDepth--;
            IsSomeRendererActing.current = previousIsSomeRendererActing;
            IsThisRendererActing.current = previousIsThisRendererActing;
          }
          !1 === didWarnAboutUsingActInProd &&
            ((didWarnAboutUsingActInProd = !0),
            console.error(
              "act(...) is not supported in production builds of React, and might not behave as expected."
            ));
          actingUpdatesScopeDepth++;
          var previousIsSomeRendererActing = IsSomeRendererActing.current;
          var previousIsThisRendererActing = IsThisRendererActing.current;
          IsSomeRendererActing.current = !0;
          IsThisRendererActing.current = !0;
          try {
            var result = batchedUpdates(callback);
          } catch (error) {
            throw (onDone(), error);
          }
          if (
            null !== result &&
            "object" === typeof result &&
            "function" === typeof result.then
          )
            return {
              then: function(resolve, reject) {
                result.then(
                  function() {
                    1 < actingUpdatesScopeDepth ||
                    (!0 === isSchedulerMocked &&
                      !0 === previousIsSomeRendererActing)
                      ? (onDone(), resolve())
                      : flushWorkAndMicroTasks(function(err) {
                          onDone();
                          err ? reject(err) : resolve();
                        });
                  },
                  function(err) {
                    onDone();
                    reject(err);
                  }
                );
              }
            };
          try {
            1 !== actingUpdatesScopeDepth ||
              (!1 !== isSchedulerMocked &&
                !1 !== previousIsSomeRendererActing) ||
              flushWork(),
              onDone();
          } catch (err) {
            throw (onDone(), err);
          }
          return {
            then: function(resolve) {
              resolve();
            }
          };
        },
        dumpTree: function() {
          function log() {
            for (
              var _len = arguments.length, args = Array(_len), _key = 0;
              _key < _len;
              _key++
            )
              args[_key] = arguments[_key];
            bufferedLog.push.apply(bufferedLog, args.concat(["\n"]));
          }
          function logHostInstances(children, depth) {
            for (var i = 0; i < children.length; i++) {
              var child = children[i],
                indent = "  ".repeat(depth);
              "string" === typeof child.text
                ? log(indent + "- " + child.text)
                : (log(indent + "- " + child.type + "#" + child.id),
                  logHostInstances(child.children, depth + 1));
            }
          }
          function logFiber(fiber, depth) {
            log(
              "  ".repeat(depth) +
                "- " +
                (fiber.type
                  ? fiber.type.name || fiber.type.toString()
                  : "[root]"),
              "[" +
                fiber.childExpirationTime +
                (fiber.pendingProps ? "*" : "") +
                "]"
            );
            if (fiber.updateQueue) {
              var updateQueue = fiber.updateQueue;
              log("  ".repeat(depth + 1) + "QUEUED UPDATES");
              if ((updateQueue = updateQueue.firstUpdate))
                for (
                  log(
                    "  ".repeat(depth + 1) + "~",
                    "[" + updateQueue.expirationTime + "]"
                  );
                  updateQueue.next;

                )
                  log(
                    "  ".repeat(depth + 1) + "~",
                    "[" + updateQueue.expirationTime + "]"
                  );
            }
            fiber.child && logFiber(fiber.child, depth + 1);
            fiber.sibling && logFiber(fiber.sibling, depth);
          }
          var _console,
            rootID =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : "<default>",
            root = roots.get(rootID);
          rootID = rootContainers.get(rootID);
          if (root && rootID) {
            var bufferedLog = [];
            log("HOST INSTANCES:");
            (function(container, depth) {
              log("  ".repeat(depth) + "- [root#" + container.rootID + "]");
              logHostInstances(container.children, depth + 1);
            })(rootID, 0);
            log("FIBERS:");
            logFiber(root.current, 0);
            (_console = console).log.apply(_console, bufferedLog);
          } else console.log("Nothing rendered yet.");
        },
        flushWithoutCommitting: function(expectedFlush) {
          var root = roots.get(
              1 < arguments.length && void 0 !== arguments[1]
                ? arguments[1]
                : "<default>"
            ),
            expiration = NoopRenderer.computeUniqueAsyncExpiration(),
            batch = {
              _defer: !0,
              _expirationTime: expiration,
              _onComplete: function() {
                root.firstBatch = null;
              },
              _next: null
            };
          root.firstBatch = batch;
          Scheduler.unstable_flushAllWithoutAsserting();
          var actual = Scheduler.unstable_clearYields();
          expect(actual).toEqual(expectedFlush);
          return function(expectedCommit) {
            batch._defer = !1;
            NoopRenderer.flushRoot(root, expiration);
            expect(Scheduler.unstable_clearYields()).toEqual(expectedCommit);
          };
        },
        getRoot: function() {
          return roots.get(
            0 < arguments.length && void 0 !== arguments[0]
              ? arguments[0]
              : "<default>"
          );
        }
      };
    return ReactNoop;
  })(ReactFiberPersistentReconciler, !1),
  ReactNoopPersistent$2 = { default: ReactNoopPersistent },
  ReactNoopPersistent$3 =
    (ReactNoopPersistent$2 && ReactNoopPersistent) || ReactNoopPersistent$2;
module.exports = ReactNoopPersistent$3.default || ReactNoopPersistent$3;

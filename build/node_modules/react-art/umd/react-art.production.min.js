/** @license React vundefined
 * react-art.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";
(function(global, factory) {
  "object" === typeof exports && "undefined" !== typeof module
    ? (module.exports = factory(require("react")))
    : "function" === typeof define && define.amd
      ? define(["react"], factory)
      : (global.ReactART = factory(global.React));
})(this, function(React) {
  function _extends() {
    _extends =
      Object.assign ||
      function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i],
            key;
          for (key in source)
            Object.prototype.hasOwnProperty.call(source, key) &&
              (target[key] = source[key]);
        }
        return target;
      };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  function _assertThisInitialized(self) {
    if (void 0 === self)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return self;
  }
  function ReactErrorProd(error) {
    for (
      var code = error.message,
        url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code,
        i = 1;
      i < arguments.length;
      i++
    )
      url += "&args[]=" + encodeURIComponent(arguments[i]);
    error.message =
      "Minified React error #" +
      code +
      "; visit " +
      url +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ";
    return error;
  }
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable)
      return null;
    maybeIterable =
      (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
      maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  function initializeLazyComponentType(lazyComponent) {
    if (-1 === lazyComponent._status) {
      lazyComponent._status = 0;
      var ctor = lazyComponent._ctor;
      ctor = ctor();
      lazyComponent._result = ctor;
      ctor.then(
        function(moduleObject) {
          0 === lazyComponent._status &&
            ((moduleObject = moduleObject.default),
            (lazyComponent._status = 1),
            (lazyComponent._result = moduleObject));
        },
        function(error) {
          0 === lazyComponent._status &&
            ((lazyComponent._status = 2), (lazyComponent._result = error));
        }
      );
    }
  }
  function getComponentName(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          return "Context.Consumer";
        case REACT_PROVIDER_TYPE:
          return "Context.Provider";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          innerType = innerType.displayName || innerType.name || "";
          return (
            type.displayName ||
            ("" !== innerType ? "ForwardRef(" + innerType + ")" : "ForwardRef")
          );
        case REACT_MEMO_TYPE:
          return getComponentName(type.type);
        case REACT_LAZY_TYPE:
          if ((type = 1 === type._status ? type._result : null))
            return getComponentName(type);
      }
    return null;
  }
  function isFiberMountedImpl(fiber) {
    var node = fiber;
    if (fiber.alternate) for (; node.return; ) node = node.return;
    else {
      fiber = node;
      do {
        node = fiber;
        if (0 !== (node.effectTag & 1026)) return 1;
        fiber = node.return;
      } while (fiber);
    }
    return 3 === node.tag ? 2 : 3;
  }
  function assertIsMounted(fiber) {
    if (2 !== isFiberMountedImpl(fiber)) throw ReactErrorProd(Error(188));
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = isFiberMountedImpl(fiber);
      if (3 === alternate) throw ReactErrorProd(Error(188));
      return 1 === alternate ? null : fiber;
    }
    for (var a = fiber, b = alternate; ; ) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b = parentA.return;
        if (null !== b) {
          a = b;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB; ) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw ReactErrorProd(Error(188));
      }
      if (a.return !== b.return) (a = parentA), (b = parentB);
      else {
        for (var didFindChild = !1, _child = parentA.child; _child; ) {
          if (_child === a) {
            didFindChild = !0;
            a = parentA;
            b = parentB;
            break;
          }
          if (_child === b) {
            didFindChild = !0;
            b = parentA;
            a = parentB;
            break;
          }
          _child = _child.sibling;
        }
        if (!didFindChild) {
          for (_child = parentB.child; _child; ) {
            if (_child === a) {
              didFindChild = !0;
              a = parentB;
              b = parentA;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentB;
              a = parentA;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) throw ReactErrorProd(Error(189));
        }
      }
      if (a.alternate !== b) throw ReactErrorProd(Error(190));
    }
    if (3 !== a.tag) throw ReactErrorProd(Error(188));
    return a.stateNode.current === a ? fiber : alternate;
  }
  function findCurrentHostFiber(parent) {
    parent = findCurrentFiberUsingSlowPath(parent);
    if (!parent) return null;
    for (var node = parent; ; ) {
      if (5 === node.tag || 6 === node.tag) return node;
      if (node.child) (node.child.return = node), (node = node.child);
      else {
        if (node === parent) break;
        for (; !node.sibling; ) {
          if (!node.return || node.return === parent) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return null;
  }
  function Transform(xx, yx, xy, yy, x, y) {
    xx &&
      "object" == typeof xx &&
      ((yx = xx.yx),
      (yy = xx.yy),
      (y = xx.y),
      (xy = xx.xy),
      (x = xx.x),
      (xx = xx.xx));
    this.xx = null == xx ? 1 : xx;
    this.yx = yx || 0;
    this.xy = xy || 0;
    this.yy = null == yy ? 1 : yy;
    this.x = (null == x ? this.x : x) || 0;
    this.y = (null == y ? this.y : y) || 0;
    this._transform();
    return this;
  }
  function createCommonjsModule(fn, module) {
    return (
      (module = { exports: {} }), fn(module, module.exports), module.exports
    );
  }
  function childrenAsString(children) {
    return children
      ? "string" === typeof children
        ? children
        : children.length
          ? children.join("")
          : ""
      : "";
  }
  function shim$1() {
    throw ReactErrorProd(Error(305));
  }
  function createEventHandler(instance) {
    return function(event) {
      var listener = instance._listeners[event.type];
      listener &&
        ("function" === typeof listener
          ? listener.call(instance, event)
          : listener.handleEvent && listener.handleEvent(event));
    };
  }
  function destroyEventListeners(instance) {
    if (instance._subscriptions)
      for (var type in instance._subscriptions) instance._subscriptions[type]();
    instance._subscriptions = null;
    instance._listeners = null;
  }
  function applyClippingRectangleProps(instance, props) {
    applyNodeProps(
      instance,
      props,
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}
    );
    instance.width = props.width;
    instance.height = props.height;
  }
  function applyGroupProps(instance, props) {
    applyNodeProps(
      instance,
      props,
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}
    );
    instance.width = props.width;
    instance.height = props.height;
  }
  function applyNodeProps(instance, props) {
    var prevProps =
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
    var scaleX =
      null != props.scaleX
        ? props.scaleX
        : null != props.scale
          ? props.scale
          : 1;
    var scaleY =
      null != props.scaleY
        ? props.scaleY
        : null != props.scale
          ? props.scale
          : 1;
    pooledTransform
      .transformTo(1, 0, 0, 1, 0, 0)
      .move(props.x || 0, props.y || 0)
      .rotate(props.rotation || 0, props.originX, props.originY)
      .scale(scaleX, scaleY, props.originX, props.originY);
    null != props.transform && pooledTransform.transform(props.transform);
    (instance.xx === pooledTransform.xx &&
      instance.yx === pooledTransform.yx &&
      instance.xy === pooledTransform.xy &&
      instance.yy === pooledTransform.yy &&
      instance.x === pooledTransform.x &&
      instance.y === pooledTransform.y) ||
      instance.transformTo(pooledTransform);
    (props.cursor === prevProps.cursor && props.title === prevProps.title) ||
      instance.indicate(props.cursor, props.title);
    instance.blend &&
      props.opacity !== prevProps.opacity &&
      instance.blend(null == props.opacity ? 1 : props.opacity);
    props.visible !== prevProps.visible &&
      (null == props.visible || props.visible
        ? instance.show()
        : instance.hide());
    for (var type in EVENT_TYPES)
      (prevProps = instance),
        (scaleX = EVENT_TYPES[type]),
        (scaleY = props[type]),
        prevProps._listeners ||
          ((prevProps._listeners = {}), (prevProps._subscriptions = {})),
        (prevProps._listeners[scaleX] = scaleY)
          ? prevProps._subscriptions[scaleX] ||
            (prevProps._subscriptions[scaleX] = prevProps.subscribe(
              scaleX,
              createEventHandler(prevProps),
              prevProps
            ))
          : prevProps._subscriptions[scaleX] &&
            (prevProps._subscriptions[scaleX](),
            delete prevProps._subscriptions[scaleX]);
  }
  function applyRenderableNodeProps(instance, props) {
    var prevProps =
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
    applyNodeProps(instance, props, prevProps);
    prevProps.fill !== props.fill &&
      (props.fill && props.fill.applyFill
        ? props.fill.applyFill(instance)
        : instance.fill(props.fill));
    (prevProps.stroke === props.stroke &&
      prevProps.strokeWidth === props.strokeWidth &&
      prevProps.strokeCap === props.strokeCap &&
      prevProps.strokeJoin === props.strokeJoin &&
      prevProps.strokeDash === props.strokeDash) ||
      instance.stroke(
        props.stroke,
        props.strokeWidth,
        props.strokeCap,
        props.strokeJoin,
        props.strokeDash
      );
  }
  function applyShapeProps(instance, props) {
    var prevProps =
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
    applyRenderableNodeProps(instance, props, prevProps);
    var path = props.d || childrenAsString(props.children),
      prevDelta = instance._prevDelta;
    if (
      path !== instance._prevPath ||
      path.delta !== prevDelta ||
      prevProps.height !== props.height ||
      prevProps.width !== props.width
    )
      instance.draw(path, props.width, props.height),
        (instance._prevDelta = path.delta),
        (instance._prevPath = path);
  }
  function applyTextProps(instance, props) {
    var prevProps =
      2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
    applyRenderableNodeProps(instance, props, prevProps);
    var string = props.children,
      JSCompiler_temp;
    if (!(JSCompiler_temp = instance._currentString !== string)) {
      JSCompiler_temp = props.font;
      var newFont = prevProps.font;
      JSCompiler_temp =
        JSCompiler_temp === newFont
          ? !0
          : "string" === typeof newFont || "string" === typeof JSCompiler_temp
            ? !1
            : newFont.fontSize === JSCompiler_temp.fontSize &&
              newFont.fontStyle === JSCompiler_temp.fontStyle &&
              newFont.fontVariant === JSCompiler_temp.fontVariant &&
              newFont.fontWeight === JSCompiler_temp.fontWeight &&
              newFont.fontFamily === JSCompiler_temp.fontFamily;
      JSCompiler_temp = !JSCompiler_temp;
    }
    if (
      JSCompiler_temp ||
      props.alignment !== prevProps.alignment ||
      props.path !== prevProps.path
    )
      instance.draw(string, props.font, props.alignment, props.path),
        (instance._currentString = string);
  }
  function shouldSetTextContent(type, props) {
    return (
      "string" === typeof props.children || "number" === typeof props.children
    );
  }
  function getStackByFiberInDevAndProd(workInProgress) {
    var info = "";
    do {
      a: switch (workInProgress.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var JSCompiler_inline_result = "";
          break a;
        default:
          var owner = workInProgress._debugOwner,
            source = workInProgress._debugSource,
            name = getComponentName(workInProgress.type);
          JSCompiler_inline_result = null;
          owner && (JSCompiler_inline_result = getComponentName(owner.type));
          owner = name;
          name = "";
          source
            ? (name =
                " (at " +
                source.fileName.replace(BEFORE_SLASH_RE, "") +
                ":" +
                source.lineNumber +
                ")")
            : JSCompiler_inline_result &&
              (name = " (created by " + JSCompiler_inline_result + ")");
          JSCompiler_inline_result = "\n    in " + (owner || "Unknown") + name;
      }
      info += JSCompiler_inline_result;
      workInProgress = workInProgress.return;
    } while (workInProgress);
    return info;
  }
  function pop(cursor, fiber) {
    0 > index ||
      ((cursor.current = valueStack[index]),
      (valueStack[index] = null),
      index--);
  }
  function push(cursor, value, fiber) {
    index++;
    valueStack[index] = cursor.current;
    cursor.current = value;
  }
  function getMaskedContext(workInProgress, unmaskedContext) {
    var contextTypes = workInProgress.type.contextTypes;
    if (!contextTypes) return emptyContextObject;
    var instance = workInProgress.stateNode;
    if (
      instance &&
      instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
    )
      return instance.__reactInternalMemoizedMaskedChildContext;
    var context = {},
      key;
    for (key in contextTypes) context[key] = unmaskedContext[key];
    instance &&
      ((workInProgress = workInProgress.stateNode),
      (workInProgress.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext),
      (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
    return context;
  }
  function isContextProvider(type) {
    type = type.childContextTypes;
    return null !== type && void 0 !== type;
  }
  function popContext(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
  function popTopLevelContextObject(fiber) {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
  function pushTopLevelContextObject(fiber, context, didChange) {
    if (contextStackCursor.current !== emptyContextObject)
      throw ReactErrorProd(Error(168));
    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }
  function processChildContext(fiber, type, parentContext) {
    var instance = fiber.stateNode;
    fiber = type.childContextTypes;
    if ("function" !== typeof instance.getChildContext) return parentContext;
    instance = instance.getChildContext();
    for (var contextKey in instance)
      if (!(contextKey in fiber))
        throw ReactErrorProd(
          Error(108),
          getComponentName(type) || "Unknown",
          contextKey
        );
    return _assign({}, parentContext, {}, instance);
  }
  function pushContextProvider(workInProgress) {
    var instance = workInProgress.stateNode;
    instance =
      (instance && instance.__reactInternalMemoizedMergedChildContext) ||
      emptyContextObject;
    previousContext = contextStackCursor.current;
    push(contextStackCursor, instance, workInProgress);
    push(
      didPerformWorkStackCursor,
      didPerformWorkStackCursor.current,
      workInProgress
    );
    return !0;
  }
  function invalidateContextProvider(workInProgress, type, didChange) {
    var instance = workInProgress.stateNode;
    if (!instance) throw ReactErrorProd(Error(169));
    didChange
      ? ((type = processChildContext(workInProgress, type, previousContext)),
        (instance.__reactInternalMemoizedMergedChildContext = type),
        pop(didPerformWorkStackCursor, workInProgress),
        pop(contextStackCursor, workInProgress),
        push(contextStackCursor, type, workInProgress))
      : pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
  function getCurrentPriorityLevel() {
    switch (Scheduler_getCurrentPriorityLevel()) {
      case Scheduler_ImmediatePriority:
        return 99;
      case Scheduler_UserBlockingPriority:
        return 98;
      case Scheduler_NormalPriority:
        return 97;
      case Scheduler_LowPriority:
        return 96;
      case Scheduler_IdlePriority:
        return 95;
      default:
        throw ReactErrorProd(Error(332));
    }
  }
  function reactPriorityToSchedulerPriority(reactPriorityLevel) {
    switch (reactPriorityLevel) {
      case 99:
        return Scheduler_ImmediatePriority;
      case 98:
        return Scheduler_UserBlockingPriority;
      case 97:
        return Scheduler_NormalPriority;
      case 96:
        return Scheduler_LowPriority;
      case 95:
        return Scheduler_IdlePriority;
      default:
        throw ReactErrorProd(Error(332));
    }
  }
  function runWithPriority(reactPriorityLevel, fn) {
    reactPriorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
    return Scheduler_runWithPriority(reactPriorityLevel, fn);
  }
  function scheduleCallback(reactPriorityLevel, callback, options) {
    reactPriorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
    return Scheduler_scheduleCallback(reactPriorityLevel, callback, options);
  }
  function scheduleSyncCallback(callback) {
    null === syncQueue
      ? ((syncQueue = [callback]),
        (immediateQueueCallbackNode = Scheduler_scheduleCallback(
          Scheduler_ImmediatePriority,
          flushSyncCallbackQueueImpl
        )))
      : syncQueue.push(callback);
    return fakeCallbackNode;
  }
  function flushSyncCallbackQueue() {
    if (null !== immediateQueueCallbackNode) {
      var node = immediateQueueCallbackNode;
      immediateQueueCallbackNode = null;
      Scheduler_cancelCallback(node);
    }
    flushSyncCallbackQueueImpl();
  }
  function flushSyncCallbackQueueImpl() {
    if (!isFlushingSyncQueue && null !== syncQueue) {
      isFlushingSyncQueue = !0;
      var i = 0;
      try {
        var queue = syncQueue;
        runWithPriority(99, function() {
          for (; i < queue.length; i++) {
            var callback = queue[i];
            do callback = callback(!0);
            while (null !== callback);
          }
        });
        syncQueue = null;
      } catch (error) {
        throw (null !== syncQueue && (syncQueue = syncQueue.slice(i + 1)),
        Scheduler_scheduleCallback(
          Scheduler_ImmediatePriority,
          flushSyncCallbackQueue
        ),
        error);
      } finally {
        isFlushingSyncQueue = !1;
      }
    }
  }
  function inferPriorityFromExpirationTime(currentTime, expirationTime) {
    if (1073741823 === expirationTime) return 99;
    if (1 === expirationTime) return 95;
    currentTime =
      10 * (1073741821 - expirationTime) - 10 * (1073741821 - currentTime);
    return 0 >= currentTime
      ? 99
      : 250 >= currentTime
        ? 98
        : 5250 >= currentTime
          ? 97
          : 95;
  }
  function is(x, y) {
    return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) return !0;
    if (
      "object" !== typeof objA ||
      null === objA ||
      "object" !== typeof objB ||
      null === objB
    )
      return !1;
    var keysA = Object.keys(objA),
      keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;
    for (keysB = 0; keysB < keysA.length; keysB++)
      if (
        !hasOwnProperty.call(objB, keysA[keysB]) ||
        !is(objA[keysA[keysB]], objB[keysA[keysB]])
      )
        return !1;
    return !0;
  }
  function resolveDefaultProps(Component, baseProps) {
    if (Component && Component.defaultProps) {
      baseProps = _assign({}, baseProps);
      Component = Component.defaultProps;
      for (var propName in Component)
        void 0 === baseProps[propName] &&
          (baseProps[propName] = Component[propName]);
    }
    return baseProps;
  }
  function resetContextDependencies() {
    lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
  }
  function pushProvider(providerFiber, nextValue) {
    var context = providerFiber.type._context;
    push(valueCursor, context._currentValue2, providerFiber);
    context._currentValue2 = nextValue;
  }
  function popProvider(providerFiber) {
    var currentValue = valueCursor.current;
    pop(valueCursor, providerFiber);
    providerFiber.type._context._currentValue2 = currentValue;
  }
  function scheduleWorkOnParentPath(parent, renderExpirationTime) {
    for (; null !== parent; ) {
      var alternate = parent.alternate;
      if (parent.childExpirationTime < renderExpirationTime)
        (parent.childExpirationTime = renderExpirationTime),
          null !== alternate &&
            alternate.childExpirationTime < renderExpirationTime &&
            (alternate.childExpirationTime = renderExpirationTime);
      else if (
        null !== alternate &&
        alternate.childExpirationTime < renderExpirationTime
      )
        alternate.childExpirationTime = renderExpirationTime;
      else break;
      parent = parent.return;
    }
  }
  function prepareToReadContext(workInProgress, renderExpirationTime) {
    currentlyRenderingFiber = workInProgress;
    lastContextWithAllBitsObserved = lastContextDependency = null;
    workInProgress = workInProgress.dependencies;
    null !== workInProgress &&
      null !== workInProgress.firstContext &&
      (workInProgress.expirationTime >= renderExpirationTime &&
        (didReceiveUpdate = !0),
      (workInProgress.firstContext = null));
  }
  function readContext(context, observedBits) {
    if (
      lastContextWithAllBitsObserved !== context &&
      !1 !== observedBits &&
      0 !== observedBits
    ) {
      if ("number" !== typeof observedBits || 1073741823 === observedBits)
        (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
      observedBits = {
        context: context,
        observedBits: observedBits,
        next: null
      };
      if (null === lastContextDependency) {
        if (null === currentlyRenderingFiber) throw ReactErrorProd(Error(308));
        lastContextDependency = observedBits;
        currentlyRenderingFiber.dependencies = {
          expirationTime: 0,
          firstContext: observedBits,
          responders: null
        };
      } else lastContextDependency = lastContextDependency.next = observedBits;
    }
    return context._currentValue2;
  }
  function createUpdateQueue(baseState) {
    return {
      baseState: baseState,
      firstUpdate: null,
      lastUpdate: null,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }
  function cloneUpdateQueue(currentQueue) {
    return {
      baseState: currentQueue.baseState,
      firstUpdate: currentQueue.firstUpdate,
      lastUpdate: currentQueue.lastUpdate,
      firstCapturedUpdate: null,
      lastCapturedUpdate: null,
      firstEffect: null,
      lastEffect: null,
      firstCapturedEffect: null,
      lastCapturedEffect: null
    };
  }
  function createUpdate(expirationTime, suspenseConfig) {
    return {
      expirationTime: expirationTime,
      suspenseConfig: suspenseConfig,
      tag: UpdateState,
      payload: null,
      callback: null,
      next: null,
      nextEffect: null
    };
  }
  function appendUpdateToQueue(queue, update) {
    null === queue.lastUpdate
      ? (queue.firstUpdate = queue.lastUpdate = update)
      : ((queue.lastUpdate.next = update), (queue.lastUpdate = update));
  }
  function enqueueUpdate(fiber, update) {
    var alternate = fiber.alternate;
    if (null === alternate) {
      var queue1 = fiber.updateQueue;
      var queue2 = null;
      null === queue1 &&
        (queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState));
    } else (queue1 = fiber.updateQueue), (queue2 = alternate.updateQueue), null === queue1 ? (null === queue2 ? ((queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState)), (queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState))) : (queue1 = fiber.updateQueue = cloneUpdateQueue(queue2))) : null === queue2 && (queue2 = alternate.updateQueue = cloneUpdateQueue(queue1));
    null === queue2 || queue1 === queue2
      ? appendUpdateToQueue(queue1, update)
      : null === queue1.lastUpdate || null === queue2.lastUpdate
        ? (appendUpdateToQueue(queue1, update),
          appendUpdateToQueue(queue2, update))
        : (appendUpdateToQueue(queue1, update), (queue2.lastUpdate = update));
  }
  function enqueueCapturedUpdate(workInProgress, update) {
    var workInProgressQueue = workInProgress.updateQueue;
    workInProgressQueue =
      null === workInProgressQueue
        ? (workInProgress.updateQueue = createUpdateQueue(
            workInProgress.memoizedState
          ))
        : ensureWorkInProgressQueueIsAClone(
            workInProgress,
            workInProgressQueue
          );
    null === workInProgressQueue.lastCapturedUpdate
      ? (workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update)
      : ((workInProgressQueue.lastCapturedUpdate.next = update),
        (workInProgressQueue.lastCapturedUpdate = update));
  }
  function ensureWorkInProgressQueueIsAClone(workInProgress, queue) {
    var current = workInProgress.alternate;
    null !== current &&
      queue === current.updateQueue &&
      (queue = workInProgress.updateQueue = cloneUpdateQueue(queue));
    return queue;
  }
  function getStateFromUpdate(
    workInProgress,
    queue,
    update,
    prevState,
    nextProps,
    instance
  ) {
    switch (update.tag) {
      case 1:
        return (
          (workInProgress = update.payload),
          "function" === typeof workInProgress
            ? workInProgress.call(instance, prevState, nextProps)
            : workInProgress
        );
      case 3:
        workInProgress.effectTag = (workInProgress.effectTag & -4097) | 64;
      case UpdateState:
        workInProgress = update.payload;
        nextProps =
          "function" === typeof workInProgress
            ? workInProgress.call(instance, prevState, nextProps)
            : workInProgress;
        if (null === nextProps || void 0 === nextProps) break;
        return _assign({}, prevState, nextProps);
      case ForceUpdate:
        hasForceUpdate = !0;
    }
    return prevState;
  }
  function processUpdateQueue(
    workInProgress,
    queue,
    props,
    instance,
    renderExpirationTime
  ) {
    hasForceUpdate = !1;
    queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);
    for (
      var newBaseState = queue.baseState,
        newFirstUpdate = null,
        newExpirationTime = 0,
        update = queue.firstUpdate,
        resultState = newBaseState;
      null !== update;

    ) {
      var updateExpirationTime = update.expirationTime;
      updateExpirationTime < renderExpirationTime
        ? (null === newFirstUpdate &&
            ((newFirstUpdate = update), (newBaseState = resultState)),
          newExpirationTime < updateExpirationTime &&
            (newExpirationTime = updateExpirationTime))
        : (markRenderEventTimeAndConfig(
            updateExpirationTime,
            update.suspenseConfig
          ),
          (resultState = getStateFromUpdate(
            workInProgress,
            queue,
            update,
            resultState,
            props,
            instance
          )),
          null !== update.callback &&
            ((workInProgress.effectTag |= 32),
            (update.nextEffect = null),
            null === queue.lastEffect
              ? (queue.firstEffect = queue.lastEffect = update)
              : ((queue.lastEffect.nextEffect = update),
                (queue.lastEffect = update))));
      update = update.next;
    }
    updateExpirationTime = null;
    for (update = queue.firstCapturedUpdate; null !== update; ) {
      var _updateExpirationTime = update.expirationTime;
      _updateExpirationTime < renderExpirationTime
        ? (null === updateExpirationTime &&
            ((updateExpirationTime = update),
            null === newFirstUpdate && (newBaseState = resultState)),
          newExpirationTime < _updateExpirationTime &&
            (newExpirationTime = _updateExpirationTime))
        : ((resultState = getStateFromUpdate(
            workInProgress,
            queue,
            update,
            resultState,
            props,
            instance
          )),
          null !== update.callback &&
            ((workInProgress.effectTag |= 32),
            (update.nextEffect = null),
            null === queue.lastCapturedEffect
              ? (queue.firstCapturedEffect = queue.lastCapturedEffect = update)
              : ((queue.lastCapturedEffect.nextEffect = update),
                (queue.lastCapturedEffect = update))));
      update = update.next;
    }
    null === newFirstUpdate && (queue.lastUpdate = null);
    null === updateExpirationTime
      ? (queue.lastCapturedUpdate = null)
      : (workInProgress.effectTag |= 32);
    null === newFirstUpdate &&
      null === updateExpirationTime &&
      (newBaseState = resultState);
    queue.baseState = newBaseState;
    queue.firstUpdate = newFirstUpdate;
    queue.firstCapturedUpdate = updateExpirationTime;
    workInProgress.expirationTime = newExpirationTime;
    workInProgress.memoizedState = resultState;
  }
  function commitUpdateQueue(
    finishedWork,
    finishedQueue,
    instance,
    renderExpirationTime
  ) {
    null !== finishedQueue.firstCapturedUpdate &&
      (null !== finishedQueue.lastUpdate &&
        ((finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate),
        (finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate)),
      (finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null));
    commitUpdateEffects(finishedQueue.firstEffect, instance);
    finishedQueue.firstEffect = finishedQueue.lastEffect = null;
    commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);
    finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;
  }
  function commitUpdateEffects(effect, instance) {
    for (; null !== effect; ) {
      var callback = effect.callback;
      if (null !== callback) {
        effect.callback = null;
        var context = instance;
        if ("function" !== typeof callback)
          throw ReactErrorProd(Error(191), callback);
        callback.call(context);
      }
      effect = effect.nextEffect;
    }
  }
  function applyDerivedStateFromProps(
    workInProgress,
    ctor,
    getDerivedStateFromProps,
    nextProps
  ) {
    ctor = workInProgress.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps =
      null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
        ? ctor
        : _assign({}, ctor, getDerivedStateFromProps);
    workInProgress.memoizedState = getDerivedStateFromProps;
    nextProps = workInProgress.updateQueue;
    null !== nextProps &&
      0 === workInProgress.expirationTime &&
      (nextProps.baseState = getDerivedStateFromProps);
  }
  function checkShouldComponentUpdate(
    workInProgress,
    ctor,
    oldProps,
    newProps,
    oldState,
    newState,
    nextContext
  ) {
    workInProgress = workInProgress.stateNode;
    return "function" === typeof workInProgress.shouldComponentUpdate
      ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
      : ctor.prototype && ctor.prototype.isPureReactComponent
        ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
        : !0;
  }
  function constructClassInstance(
    workInProgress,
    ctor,
    props,
    renderExpirationTime
  ) {
    var isLegacyContextConsumer = !1;
    renderExpirationTime = emptyContextObject;
    var context = ctor.contextType;
    "object" === typeof context && null !== context
      ? (context = readContext(context))
      : ((renderExpirationTime = isContextProvider(ctor)
          ? previousContext
          : contextStackCursor.current),
        (isLegacyContextConsumer = ctor.contextTypes),
        (context = (isLegacyContextConsumer =
          null !== isLegacyContextConsumer &&
          void 0 !== isLegacyContextConsumer)
          ? getMaskedContext(workInProgress, renderExpirationTime)
          : emptyContextObject));
    ctor = new ctor(props, context);
    workInProgress.memoizedState =
      null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
    ctor.updater = classComponentUpdater;
    workInProgress.stateNode = ctor;
    ctor._reactInternalFiber = workInProgress;
    isLegacyContextConsumer &&
      ((workInProgress = workInProgress.stateNode),
      (workInProgress.__reactInternalMemoizedUnmaskedChildContext = renderExpirationTime),
      (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
    return ctor;
  }
  function callComponentWillReceiveProps(
    workInProgress,
    instance,
    newProps,
    nextContext
  ) {
    workInProgress = instance.state;
    "function" === typeof instance.componentWillReceiveProps &&
      instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
      instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress &&
      classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
  function mountClassInstance(
    workInProgress,
    ctor,
    newProps,
    renderExpirationTime
  ) {
    var instance = workInProgress.stateNode;
    instance.props = newProps;
    instance.state = workInProgress.memoizedState;
    instance.refs = emptyRefsObject;
    var contextType = ctor.contextType;
    "object" === typeof contextType && null !== contextType
      ? (instance.context = readContext(contextType))
      : ((contextType = isContextProvider(ctor)
          ? previousContext
          : contextStackCursor.current),
        (instance.context = getMaskedContext(workInProgress, contextType)));
    contextType = workInProgress.updateQueue;
    null !== contextType &&
      (processUpdateQueue(
        workInProgress,
        contextType,
        newProps,
        instance,
        renderExpirationTime
      ),
      (instance.state = workInProgress.memoizedState));
    contextType = ctor.getDerivedStateFromProps;
    "function" === typeof contextType &&
      (applyDerivedStateFromProps(workInProgress, ctor, contextType, newProps),
      (instance.state = workInProgress.memoizedState));
    "function" === typeof ctor.getDerivedStateFromProps ||
      "function" === typeof instance.getSnapshotBeforeUpdate ||
      ("function" !== typeof instance.UNSAFE_componentWillMount &&
        "function" !== typeof instance.componentWillMount) ||
      ((ctor = instance.state),
      "function" === typeof instance.componentWillMount &&
        instance.componentWillMount(),
      "function" === typeof instance.UNSAFE_componentWillMount &&
        instance.UNSAFE_componentWillMount(),
      ctor !== instance.state &&
        classComponentUpdater.enqueueReplaceState(
          instance,
          instance.state,
          null
        ),
      (contextType = workInProgress.updateQueue),
      null !== contextType &&
        (processUpdateQueue(
          workInProgress,
          contextType,
          newProps,
          instance,
          renderExpirationTime
        ),
        (instance.state = workInProgress.memoizedState)));
    "function" === typeof instance.componentDidMount &&
      (workInProgress.effectTag |= 4);
  }
  function coerceRef(returnFiber, current, element) {
    returnFiber = element.ref;
    if (
      null !== returnFiber &&
      "function" !== typeof returnFiber &&
      "object" !== typeof returnFiber
    ) {
      if (element._owner) {
        element = element._owner;
        if (element) {
          if (1 !== element.tag) throw ReactErrorProd(Error(309));
          var inst = element.stateNode;
        }
        if (!inst) throw ReactErrorProd(Error(147), returnFiber);
        var stringRef = "" + returnFiber;
        if (
          null !== current &&
          null !== current.ref &&
          "function" === typeof current.ref &&
          current.ref._stringRef === stringRef
        )
          return current.ref;
        current = function(value) {
          var refs = inst.refs;
          refs === emptyRefsObject && (refs = inst.refs = {});
          null === value ? delete refs[stringRef] : (refs[stringRef] = value);
        };
        current._stringRef = stringRef;
        return current;
      }
      if ("string" !== typeof returnFiber) throw ReactErrorProd(Error(284));
      if (!element._owner) throw ReactErrorProd(Error(290), returnFiber);
    }
    return returnFiber;
  }
  function throwOnInvalidObjectType(returnFiber, newChild) {
    if ("textarea" !== returnFiber.type)
      throw ReactErrorProd(
        Error(31),
        "[object Object]" === Object.prototype.toString.call(newChild)
          ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
          : newChild,
        ""
      );
  }
  function ChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var last = returnFiber.lastEffect;
        null !== last
          ? ((last.nextEffect = childToDelete),
            (returnFiber.lastEffect = childToDelete))
          : (returnFiber.firstEffect = returnFiber.lastEffect = childToDelete);
        childToDelete.nextEffect = null;
        childToDelete.effectTag = 8;
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild; )
        deleteChild(returnFiber, currentFirstChild),
          (currentFirstChild = currentFirstChild.sibling);
      return null;
    }
    function mapRemainingChildren(returnFiber, currentFirstChild) {
      for (returnFiber = new Map(); null !== currentFirstChild; )
        null !== currentFirstChild.key
          ? returnFiber.set(currentFirstChild.key, currentFirstChild)
          : returnFiber.set(currentFirstChild.index, currentFirstChild),
          (currentFirstChild = currentFirstChild.sibling);
      return returnFiber;
    }
    function useFiber(fiber, pendingProps, expirationTime) {
      fiber = createWorkInProgress(fiber, pendingProps, expirationTime);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex)
        return (
          (newIndex = newIndex.index),
          newIndex < lastPlacedIndex
            ? ((newFiber.effectTag = 2), lastPlacedIndex)
            : newIndex
        );
      newFiber.effectTag = 2;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects &&
        null === newFiber.alternate &&
        (newFiber.effectTag = 2);
      return newFiber;
    }
    function updateTextNode(returnFiber, current, textContent, expirationTime) {
      if (null === current || 6 !== current.tag)
        return (
          (current = createFiberFromText(
            textContent,
            returnFiber.mode,
            expirationTime
          )),
          (current.return = returnFiber),
          current
        );
      current = useFiber(current, textContent, expirationTime);
      current.return = returnFiber;
      return current;
    }
    function updateElement(returnFiber, current, element, expirationTime) {
      if (null !== current && current.elementType === element.type)
        return (
          (expirationTime = useFiber(current, element.props, expirationTime)),
          (expirationTime.ref = coerceRef(returnFiber, current, element)),
          (expirationTime.return = returnFiber),
          expirationTime
        );
      expirationTime = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        null,
        returnFiber.mode,
        expirationTime
      );
      expirationTime.ref = coerceRef(returnFiber, current, element);
      expirationTime.return = returnFiber;
      return expirationTime;
    }
    function updatePortal(returnFiber, current, portal, expirationTime) {
      if (
        null === current ||
        4 !== current.tag ||
        current.stateNode.containerInfo !== portal.containerInfo ||
        current.stateNode.implementation !== portal.implementation
      )
        return (
          (current = createFiberFromPortal(
            portal,
            returnFiber.mode,
            expirationTime
          )),
          (current.return = returnFiber),
          current
        );
      current = useFiber(current, portal.children || [], expirationTime);
      current.return = returnFiber;
      return current;
    }
    function updateFragment(
      returnFiber,
      current,
      fragment,
      expirationTime,
      key
    ) {
      if (null === current || 7 !== current.tag)
        return (
          (current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            expirationTime,
            key
          )),
          (current.return = returnFiber),
          current
        );
      current = useFiber(current, fragment, expirationTime);
      current.return = returnFiber;
      return current;
    }
    function createChild(returnFiber, newChild, expirationTime) {
      if ("string" === typeof newChild || "number" === typeof newChild)
        return (
          (newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            expirationTime
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE$1:
            return (
              (expirationTime = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                expirationTime
              )),
              (expirationTime.ref = coerceRef(returnFiber, null, newChild)),
              (expirationTime.return = returnFiber),
              expirationTime
            );
          case REACT_PORTAL_TYPE:
            return (
              (newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                expirationTime
              )),
              (newChild.return = returnFiber),
              newChild
            );
        }
        if (isArray(newChild) || getIteratorFn(newChild))
          return (
            (newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              expirationTime,
              null
            )),
            (newChild.return = returnFiber),
            newChild
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild || "number" === typeof newChild)
        return null !== key
          ? null
          : updateTextNode(
              returnFiber,
              oldFiber,
              "" + newChild,
              expirationTime
            );
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE$1:
            return newChild.key === key
              ? newChild.type === REACT_FRAGMENT_TYPE
                ? updateFragment(
                    returnFiber,
                    oldFiber,
                    newChild.props.children,
                    expirationTime,
                    key
                  )
                : updateElement(returnFiber, oldFiber, newChild, expirationTime)
              : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key
              ? updatePortal(returnFiber, oldFiber, newChild, expirationTime)
              : null;
        }
        if (isArray(newChild) || getIteratorFn(newChild))
          return null !== key
            ? null
            : updateFragment(
                returnFiber,
                oldFiber,
                newChild,
                expirationTime,
                null
              );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function updateFromMap(
      existingChildren,
      returnFiber,
      newIdx,
      newChild,
      expirationTime
    ) {
      if ("string" === typeof newChild || "number" === typeof newChild)
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateTextNode(
            returnFiber,
            existingChildren,
            "" + newChild,
            expirationTime
          )
        );
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE$1:
            return (
              (existingChildren =
                existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null),
              newChild.type === REACT_FRAGMENT_TYPE
                ? updateFragment(
                    returnFiber,
                    existingChildren,
                    newChild.props.children,
                    expirationTime,
                    newChild.key
                  )
                : updateElement(
                    returnFiber,
                    existingChildren,
                    newChild,
                    expirationTime
                  )
            );
          case REACT_PORTAL_TYPE:
            return (
              (existingChildren =
                existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null),
              updatePortal(
                returnFiber,
                existingChildren,
                newChild,
                expirationTime
              )
            );
        }
        if (isArray(newChild) || getIteratorFn(newChild))
          return (
            (existingChildren = existingChildren.get(newIdx) || null),
            updateFragment(
              returnFiber,
              existingChildren,
              newChild,
              expirationTime,
              null
            )
          );
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      return null;
    }
    function reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChildren,
      expirationTime
    ) {
      for (
        var resultingFirstChild = null,
          previousNewFiber = null,
          oldFiber = currentFirstChild,
          newIdx = (currentFirstChild = 0),
          nextOldFiber = null;
        null !== oldFiber && newIdx < newChildren.length;
        newIdx++
      ) {
        oldFiber.index > newIdx
          ? ((nextOldFiber = oldFiber), (oldFiber = null))
          : (nextOldFiber = oldFiber.sibling);
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          newChildren[newIdx],
          expirationTime
        );
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects &&
          oldFiber &&
          null === newFiber.alternate &&
          deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber
          ? (resultingFirstChild = newFiber)
          : (previousNewFiber.sibling = newFiber);
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length)
        return (
          deleteRemainingChildren(returnFiber, oldFiber), resultingFirstChild
        );
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++)
          (oldFiber = createChild(
            returnFiber,
            newChildren[newIdx],
            expirationTime
          )),
            null !== oldFiber &&
              ((currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (resultingFirstChild = oldFiber)
                : (previousNewFiber.sibling = oldFiber),
              (previousNewFiber = oldFiber));
        return resultingFirstChild;
      }
      for (
        oldFiber = mapRemainingChildren(returnFiber, oldFiber);
        newIdx < newChildren.length;
        newIdx++
      )
        (nextOldFiber = updateFromMap(
          oldFiber,
          returnFiber,
          newIdx,
          newChildren[newIdx],
          expirationTime
        )),
          null !== nextOldFiber &&
            (shouldTrackSideEffects &&
              null !== nextOldFiber.alternate &&
              oldFiber.delete(
                null === nextOldFiber.key ? newIdx : nextOldFiber.key
              ),
            (currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = nextOldFiber)
              : (previousNewFiber.sibling = nextOldFiber),
            (previousNewFiber = nextOldFiber));
      shouldTrackSideEffects &&
        oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChildrenIterable,
      expirationTime
    ) {
      var iteratorFn = getIteratorFn(newChildrenIterable);
      if ("function" !== typeof iteratorFn) throw ReactErrorProd(Error(150));
      newChildrenIterable = iteratorFn.call(newChildrenIterable);
      if (null == newChildrenIterable) throw ReactErrorProd(Error(151));
      for (
        var previousNewFiber = (iteratorFn = null),
          oldFiber = currentFirstChild,
          newIdx = (currentFirstChild = 0),
          nextOldFiber = null,
          step = newChildrenIterable.next();
        null !== oldFiber && !step.done;
        newIdx++, step = newChildrenIterable.next()
      ) {
        oldFiber.index > newIdx
          ? ((nextOldFiber = oldFiber), (oldFiber = null))
          : (nextOldFiber = oldFiber.sibling);
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          step.value,
          expirationTime
        );
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects &&
          oldFiber &&
          null === newFiber.alternate &&
          deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber
          ? (iteratorFn = newFiber)
          : (previousNewFiber.sibling = newFiber);
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done)
        return deleteRemainingChildren(returnFiber, oldFiber), iteratorFn;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildrenIterable.next())
          (step = createChild(returnFiber, step.value, expirationTime)),
            null !== step &&
              ((currentFirstChild = placeChild(
                step,
                currentFirstChild,
                newIdx
              )),
              null === previousNewFiber
                ? (iteratorFn = step)
                : (previousNewFiber.sibling = step),
              (previousNewFiber = step));
        return iteratorFn;
      }
      for (
        oldFiber = mapRemainingChildren(returnFiber, oldFiber);
        !step.done;
        newIdx++, step = newChildrenIterable.next()
      )
        (step = updateFromMap(
          oldFiber,
          returnFiber,
          newIdx,
          step.value,
          expirationTime
        )),
          null !== step &&
            (shouldTrackSideEffects &&
              null !== step.alternate &&
              oldFiber.delete(null === step.key ? newIdx : step.key),
            (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (iteratorFn = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      shouldTrackSideEffects &&
        oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
      return iteratorFn;
    }
    return function(returnFiber, currentFirstChild, newChild, expirationTime) {
      var isUnkeyedTopLevelFragment =
        "object" === typeof newChild &&
        null !== newChild &&
        newChild.type === REACT_FRAGMENT_TYPE &&
        null === newChild.key;
      isUnkeyedTopLevelFragment && (newChild = newChild.props.children);
      var isObject = "object" === typeof newChild && null !== newChild;
      if (isObject)
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE$1:
            a: {
              isObject = newChild.key;
              for (
                isUnkeyedTopLevelFragment = currentFirstChild;
                null !== isUnkeyedTopLevelFragment;

              ) {
                if (isUnkeyedTopLevelFragment.key === isObject) {
                  if (
                    7 === isUnkeyedTopLevelFragment.tag
                      ? newChild.type === REACT_FRAGMENT_TYPE
                      : isUnkeyedTopLevelFragment.elementType === newChild.type
                  ) {
                    deleteRemainingChildren(
                      returnFiber,
                      isUnkeyedTopLevelFragment.sibling
                    );
                    currentFirstChild = useFiber(
                      isUnkeyedTopLevelFragment,
                      newChild.type === REACT_FRAGMENT_TYPE
                        ? newChild.props.children
                        : newChild.props,
                      expirationTime
                    );
                    currentFirstChild.ref = coerceRef(
                      returnFiber,
                      isUnkeyedTopLevelFragment,
                      newChild
                    );
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  }
                  deleteRemainingChildren(
                    returnFiber,
                    isUnkeyedTopLevelFragment
                  );
                  break;
                } else deleteChild(returnFiber, isUnkeyedTopLevelFragment);
                isUnkeyedTopLevelFragment = isUnkeyedTopLevelFragment.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE
                ? ((currentFirstChild = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    expirationTime,
                    newChild.key
                  )),
                  (currentFirstChild.return = returnFiber),
                  (returnFiber = currentFirstChild))
                : ((expirationTime = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    expirationTime
                  )),
                  (expirationTime.ref = coerceRef(
                    returnFiber,
                    currentFirstChild,
                    newChild
                  )),
                  (expirationTime.return = returnFiber),
                  (returnFiber = expirationTime));
            }
            return placeSingleChild(returnFiber);
          case REACT_PORTAL_TYPE:
            a: {
              for (
                isUnkeyedTopLevelFragment = newChild.key;
                null !== currentFirstChild;

              ) {
                if (currentFirstChild.key === isUnkeyedTopLevelFragment) {
                  if (
                    4 === currentFirstChild.tag &&
                    currentFirstChild.stateNode.containerInfo ===
                      newChild.containerInfo &&
                    currentFirstChild.stateNode.implementation ===
                      newChild.implementation
                  ) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    currentFirstChild = useFiber(
                      currentFirstChild,
                      newChild.children || [],
                      expirationTime
                    );
                    currentFirstChild.return = returnFiber;
                    returnFiber = currentFirstChild;
                    break a;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              currentFirstChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                expirationTime
              );
              currentFirstChild.return = returnFiber;
              returnFiber = currentFirstChild;
            }
            return placeSingleChild(returnFiber);
        }
      if ("string" === typeof newChild || "number" === typeof newChild)
        return (
          (newChild = "" + newChild),
          null !== currentFirstChild && 6 === currentFirstChild.tag
            ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
              (currentFirstChild = useFiber(
                currentFirstChild,
                newChild,
                expirationTime
              )),
              (currentFirstChild.return = returnFiber),
              (returnFiber = currentFirstChild))
            : (deleteRemainingChildren(returnFiber, currentFirstChild),
              (currentFirstChild = createFiberFromText(
                newChild,
                returnFiber.mode,
                expirationTime
              )),
              (currentFirstChild.return = returnFiber),
              (returnFiber = currentFirstChild)),
          placeSingleChild(returnFiber)
        );
      if (isArray(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          expirationTime
        );
      if (getIteratorFn(newChild))
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          expirationTime
        );
      isObject && throwOnInvalidObjectType(returnFiber, newChild);
      if ("undefined" === typeof newChild && !isUnkeyedTopLevelFragment)
        switch (returnFiber.tag) {
          case 1:
          case 0:
            throw ((returnFiber = returnFiber.type),
            ReactErrorProd(
              Error(152),
              returnFiber.displayName || returnFiber.name || "Component"
            ));
        }
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    };
  }
  function requiredContext(c) {
    if (c === NO_CONTEXT$1) throw ReactErrorProd(Error(174));
    return c;
  }
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance, fiber);
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor$1, NO_CONTEXT$1, fiber);
    nextRootInstance = NO_CONTEXT;
    pop(contextStackCursor$1, fiber);
    push(contextStackCursor$1, nextRootInstance, fiber);
  }
  function popHostContainer(fiber) {
    pop(contextStackCursor$1, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }
  function pushHostContext(fiber) {
    requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor$1.current),
      nextContext = NO_CONTEXT;
    context !== nextContext &&
      (push(contextFiberStackCursor, fiber, fiber),
      push(contextStackCursor$1, nextContext, fiber));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber &&
      (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
  }
  function findFirstSuspended(row) {
    for (var node = row; null !== node; ) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (
          null !== state &&
          ((state = state.dehydrated),
          null === state ||
            isSuspenseInstancePending(state) ||
            isSuspenseInstanceFallback(state))
        )
          return node;
      } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
        if (0 !== (node.effectTag & 64)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === row) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  function createResponderListener(responder, props) {
    return { responder: responder, props: props };
  }
  function throwInvalidHookError() {
    throw ReactErrorProd(Error(321));
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return !1;
    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
      if (!is(nextDeps[i], prevDeps[i])) return !1;
    return !0;
  }
  function renderWithHooks(
    current,
    workInProgress,
    Component,
    props,
    refOrContext,
    nextRenderExpirationTime
  ) {
    renderExpirationTime$1 = nextRenderExpirationTime;
    currentlyRenderingFiber$1 = workInProgress;
    nextCurrentHook = null !== current ? current.memoizedState : null;
    ReactCurrentDispatcher$1.current =
      null === nextCurrentHook
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;
    workInProgress = Component(props, refOrContext);
    if (didScheduleRenderPhaseUpdate) {
      do
        (didScheduleRenderPhaseUpdate = !1),
          (numberOfReRenders += 1),
          (nextCurrentHook = null !== current ? current.memoizedState : null),
          (nextWorkInProgressHook = firstWorkInProgressHook),
          (componentUpdateQueue = workInProgressHook = currentHook = null),
          (ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdate),
          (workInProgress = Component(props, refOrContext));
      while (didScheduleRenderPhaseUpdate);
      renderPhaseUpdates = null;
      numberOfReRenders = 0;
    }
    ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
    current = currentlyRenderingFiber$1;
    current.memoizedState = firstWorkInProgressHook;
    current.expirationTime = remainingExpirationTime;
    current.updateQueue = componentUpdateQueue;
    current.effectTag |= sideEffectTag;
    current = null !== currentHook && null !== currentHook.next;
    renderExpirationTime$1 = 0;
    nextWorkInProgressHook = workInProgressHook = firstWorkInProgressHook = nextCurrentHook = currentHook = currentlyRenderingFiber$1 = null;
    remainingExpirationTime = 0;
    componentUpdateQueue = null;
    sideEffectTag = 0;
    if (current) throw ReactErrorProd(Error(300));
    return workInProgress;
  }
  function resetHooks() {
    ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
    renderExpirationTime$1 = 0;
    nextWorkInProgressHook = workInProgressHook = firstWorkInProgressHook = nextCurrentHook = currentHook = currentlyRenderingFiber$1 = null;
    remainingExpirationTime = 0;
    componentUpdateQueue = null;
    sideEffectTag = 0;
    didScheduleRenderPhaseUpdate = !1;
    renderPhaseUpdates = null;
    numberOfReRenders = 0;
  }
  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      queue: null,
      baseUpdate: null,
      next: null
    };
    null === workInProgressHook
      ? (firstWorkInProgressHook = workInProgressHook = hook)
      : (workInProgressHook = workInProgressHook.next = hook);
    return workInProgressHook;
  }
  function updateWorkInProgressHook() {
    if (null !== nextWorkInProgressHook)
      (workInProgressHook = nextWorkInProgressHook),
        (nextWorkInProgressHook = workInProgressHook.next),
        (currentHook = nextCurrentHook),
        (nextCurrentHook = null !== currentHook ? currentHook.next : null);
    else {
      if (null === nextCurrentHook) throw ReactErrorProd(Error(310));
      currentHook = nextCurrentHook;
      var newHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        queue: currentHook.queue,
        baseUpdate: currentHook.baseUpdate,
        next: null
      };
      workInProgressHook =
        null === workInProgressHook
          ? (firstWorkInProgressHook = newHook)
          : (workInProgressHook.next = newHook);
      nextCurrentHook = currentHook.next;
    }
    return workInProgressHook;
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  function updateReducer(reducer, initialArg, init) {
    initialArg = updateWorkInProgressHook();
    init = initialArg.queue;
    if (null === init) throw ReactErrorProd(Error(311));
    init.lastRenderedReducer = reducer;
    if (0 < numberOfReRenders) {
      var _dispatch = init.dispatch;
      if (null !== renderPhaseUpdates) {
        var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);
        if (void 0 !== firstRenderPhaseUpdate) {
          renderPhaseUpdates.delete(init);
          var newState = initialArg.memoizedState;
          do
            (newState = reducer(newState, firstRenderPhaseUpdate.action)),
              (firstRenderPhaseUpdate = firstRenderPhaseUpdate.next);
          while (null !== firstRenderPhaseUpdate);
          is(newState, initialArg.memoizedState) || (didReceiveUpdate = !0);
          initialArg.memoizedState = newState;
          initialArg.baseUpdate === init.last &&
            (initialArg.baseState = newState);
          init.lastRenderedState = newState;
          return [newState, _dispatch];
        }
      }
      return [initialArg.memoizedState, _dispatch];
    }
    _dispatch = init.last;
    var baseUpdate = initialArg.baseUpdate;
    newState = initialArg.baseState;
    null !== baseUpdate
      ? (null !== _dispatch && (_dispatch.next = null),
        (_dispatch = baseUpdate.next))
      : (_dispatch = null !== _dispatch ? _dispatch.next : null);
    if (null !== _dispatch) {
      var newBaseUpdate = (firstRenderPhaseUpdate = null),
        _update = _dispatch,
        didSkip = !1;
      do {
        var updateExpirationTime = _update.expirationTime;
        updateExpirationTime < renderExpirationTime$1
          ? (didSkip ||
              ((didSkip = !0),
              (newBaseUpdate = baseUpdate),
              (firstRenderPhaseUpdate = newState)),
            updateExpirationTime > remainingExpirationTime &&
              (remainingExpirationTime = updateExpirationTime))
          : (markRenderEventTimeAndConfig(
              updateExpirationTime,
              _update.suspenseConfig
            ),
            (newState =
              _update.eagerReducer === reducer
                ? _update.eagerState
                : reducer(newState, _update.action)));
        baseUpdate = _update;
        _update = _update.next;
      } while (null !== _update && _update !== _dispatch);
      didSkip ||
        ((newBaseUpdate = baseUpdate), (firstRenderPhaseUpdate = newState));
      is(newState, initialArg.memoizedState) || (didReceiveUpdate = !0);
      initialArg.memoizedState = newState;
      initialArg.baseUpdate = newBaseUpdate;
      initialArg.baseState = firstRenderPhaseUpdate;
      init.lastRenderedState = newState;
    }
    return [initialArg.memoizedState, init.dispatch];
  }
  function pushEffect(tag, create, destroy, deps) {
    tag = {
      tag: tag,
      create: create,
      destroy: destroy,
      deps: deps,
      next: null
    };
    null === componentUpdateQueue
      ? ((componentUpdateQueue = { lastEffect: null }),
        (componentUpdateQueue.lastEffect = tag.next = tag))
      : ((create = componentUpdateQueue.lastEffect),
        null === create
          ? (componentUpdateQueue.lastEffect = tag.next = tag)
          : ((destroy = create.next),
            (create.next = tag),
            (tag.next = destroy),
            (componentUpdateQueue.lastEffect = tag)));
    return tag;
  }
  function mountEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
    var hook = mountWorkInProgressHook();
    sideEffectTag |= fiberEffectTag;
    hook.memoizedState = pushEffect(
      hookEffectTag,
      create,
      void 0,
      void 0 === deps ? null : deps
    );
  }
  function updateEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var destroy = void 0;
    if (null !== currentHook) {
      var prevEffect = currentHook.memoizedState;
      destroy = prevEffect.destroy;
      if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
        pushEffect(0, create, destroy, deps);
        return;
      }
    }
    sideEffectTag |= fiberEffectTag;
    hook.memoizedState = pushEffect(hookEffectTag, create, destroy, deps);
  }
  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref)
      return (
        (create = create()),
        ref(create),
        function() {
          ref(null);
        }
      );
    if (null !== ref && void 0 !== ref)
      return (
        (create = create()),
        (ref.current = create),
        function() {
          ref.current = null;
        }
      );
  }
  function mountDebugValue(value, formatterFn) {}
  function dispatchAction(fiber, queue, action) {
    if (!(25 > numberOfReRenders)) throw ReactErrorProd(Error(301));
    var alternate = fiber.alternate;
    if (
      fiber === currentlyRenderingFiber$1 ||
      (null !== alternate && alternate === currentlyRenderingFiber$1)
    )
      if (
        ((didScheduleRenderPhaseUpdate = !0),
        (fiber = {
          expirationTime: renderExpirationTime$1,
          suspenseConfig: null,
          action: action,
          eagerReducer: null,
          eagerState: null,
          next: null
        }),
        null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
        (action = renderPhaseUpdates.get(queue)),
        void 0 === action)
      )
        renderPhaseUpdates.set(queue, fiber);
      else {
        for (queue = action; null !== queue.next; ) queue = queue.next;
        queue.next = fiber;
      }
    else {
      var currentTime = requestCurrentTime(),
        suspenseConfig = ReactCurrentBatchConfig.suspense;
      currentTime = computeExpirationForFiber(
        currentTime,
        fiber,
        suspenseConfig
      );
      suspenseConfig = {
        expirationTime: currentTime,
        suspenseConfig: suspenseConfig,
        action: action,
        eagerReducer: null,
        eagerState: null,
        next: null
      };
      var last = queue.last;
      if (null === last) suspenseConfig.next = suspenseConfig;
      else {
        var first = last.next;
        null !== first && (suspenseConfig.next = first);
        last.next = suspenseConfig;
      }
      queue.last = suspenseConfig;
      if (
        0 === fiber.expirationTime &&
        (null === alternate || 0 === alternate.expirationTime) &&
        ((alternate = queue.lastRenderedReducer), null !== alternate)
      )
        try {
          var currentState = queue.lastRenderedState,
            eagerState = alternate(currentState, action);
          suspenseConfig.eagerReducer = alternate;
          suspenseConfig.eagerState = eagerState;
          if (is(eagerState, currentState)) return;
        } catch (error) {
        } finally {
        }
      scheduleWork(fiber, currentTime);
    }
  }
  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case 5:
        return (
          (nextInstance = canHydrateInstance(
            nextInstance,
            fiber.type,
            fiber.pendingProps
          )),
          null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
        );
      case 6:
        return (
          (nextInstance = canHydrateTextInstance(
            nextInstance,
            fiber.pendingProps
          )),
          null !== nextInstance ? ((fiber.stateNode = nextInstance), !0) : !1
        );
      case 13:
        return !1;
      default:
        return !1;
    }
  }
  function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
    if (isHydrating) {
      var nextInstance = nextHydratableInstance;
      if (nextInstance) {
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber$jscomp$0, nextInstance)) {
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          if (!nextInstance || !tryHydrate(fiber$jscomp$0, nextInstance)) {
            fiber$jscomp$0.effectTag |= 2;
            isHydrating = !1;
            hydrationParentFiber = fiber$jscomp$0;
            return;
          }
          var returnFiber = hydrationParentFiber,
            fiber = createFiber(5, null, null, 0);
          fiber.elementType = "DELETED";
          fiber.type = "DELETED";
          fiber.stateNode = firstAttemptedInstance;
          fiber.return = returnFiber;
          fiber.effectTag = 8;
          null !== returnFiber.lastEffect
            ? ((returnFiber.lastEffect.nextEffect = fiber),
              (returnFiber.lastEffect = fiber))
            : (returnFiber.firstEffect = returnFiber.lastEffect = fiber);
        }
        hydrationParentFiber = fiber$jscomp$0;
        nextHydratableInstance = getFirstHydratableChild(nextInstance);
      } else
        (fiber$jscomp$0.effectTag |= 2),
          (isHydrating = !1),
          (hydrationParentFiber = fiber$jscomp$0);
    }
  }
  function reconcileChildren(
    current,
    workInProgress,
    nextChildren,
    renderExpirationTime
  ) {
    workInProgress.child =
      null === current
        ? mountChildFibers(
            workInProgress,
            null,
            nextChildren,
            renderExpirationTime
          )
        : reconcileChildFibers(
            workInProgress,
            current.child,
            nextChildren,
            renderExpirationTime
          );
  }
  function updateForwardRef(
    current,
    workInProgress,
    Component,
    nextProps,
    renderExpirationTime
  ) {
    Component = Component.render;
    var ref = workInProgress.ref;
    prepareToReadContext(workInProgress, renderExpirationTime);
    nextProps = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      ref,
      renderExpirationTime
    );
    if (null !== current && !didReceiveUpdate)
      return (
        (workInProgress.updateQueue = current.updateQueue),
        (workInProgress.effectTag &= -517),
        current.expirationTime <= renderExpirationTime &&
          (current.expirationTime = 0),
        bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderExpirationTime
        )
      );
    workInProgress.effectTag |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderExpirationTime);
    return workInProgress.child;
  }
  function updateMemoComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    updateExpirationTime,
    renderExpirationTime
  ) {
    if (null === current) {
      var type = Component.type;
      if (
        "function" === typeof type &&
        !shouldConstruct(type) &&
        void 0 === type.defaultProps &&
        null === Component.compare &&
        void 0 === Component.defaultProps
      )
        return (
          (workInProgress.tag = 15),
          (workInProgress.type = type),
          updateSimpleMemoComponent(
            current,
            workInProgress,
            type,
            nextProps,
            updateExpirationTime,
            renderExpirationTime
          )
        );
      current = createFiberFromTypeAndProps(
        Component.type,
        null,
        nextProps,
        null,
        workInProgress.mode,
        renderExpirationTime
      );
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return (workInProgress.child = current);
    }
    type = current.child;
    if (
      updateExpirationTime < renderExpirationTime &&
      ((updateExpirationTime = type.memoizedProps),
      (Component = Component.compare),
      (Component = null !== Component ? Component : shallowEqual),
      Component(updateExpirationTime, nextProps) &&
        current.ref === workInProgress.ref)
    )
      return bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderExpirationTime
      );
    workInProgress.effectTag |= 1;
    current = createWorkInProgress(type, nextProps, renderExpirationTime);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return (workInProgress.child = current);
  }
  function updateSimpleMemoComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    updateExpirationTime,
    renderExpirationTime
  ) {
    return null !== current &&
      shallowEqual(current.memoizedProps, nextProps) &&
      current.ref === workInProgress.ref &&
      ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
      ? bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderExpirationTime
        )
      : updateFunctionComponent(
          current,
          workInProgress,
          Component,
          nextProps,
          renderExpirationTime
        );
  }
  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (
      (null === current && null !== ref) ||
      (null !== current && current.ref !== ref)
    )
      workInProgress.effectTag |= 128;
  }
  function updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderExpirationTime
  ) {
    var context = isContextProvider(Component)
      ? previousContext
      : contextStackCursor.current;
    context = getMaskedContext(workInProgress, context);
    prepareToReadContext(workInProgress, renderExpirationTime);
    Component = renderWithHooks(
      current,
      workInProgress,
      Component,
      nextProps,
      context,
      renderExpirationTime
    );
    if (null !== current && !didReceiveUpdate)
      return (
        (workInProgress.updateQueue = current.updateQueue),
        (workInProgress.effectTag &= -517),
        current.expirationTime <= renderExpirationTime &&
          (current.expirationTime = 0),
        bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderExpirationTime
        )
      );
    workInProgress.effectTag |= 1;
    reconcileChildren(current, workInProgress, Component, renderExpirationTime);
    return workInProgress.child;
  }
  function updateClassComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderExpirationTime
  ) {
    if (isContextProvider(Component)) {
      var hasContext = !0;
      pushContextProvider(workInProgress);
    } else hasContext = !1;
    prepareToReadContext(workInProgress, renderExpirationTime);
    if (null === workInProgress.stateNode)
      null !== current &&
        ((current.alternate = null),
        (workInProgress.alternate = null),
        (workInProgress.effectTag |= 2)),
        constructClassInstance(
          workInProgress,
          Component,
          nextProps,
          renderExpirationTime
        ),
        mountClassInstance(
          workInProgress,
          Component,
          nextProps,
          renderExpirationTime
        ),
        (nextProps = !0);
    else if (null === current) {
      var instance = workInProgress.stateNode,
        oldProps = workInProgress.memoizedProps;
      instance.props = oldProps;
      var oldContext = instance.context,
        contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType
        ? (contextType = readContext(contextType))
        : ((contextType = isContextProvider(Component)
            ? previousContext
            : contextStackCursor.current),
          (contextType = getMaskedContext(workInProgress, contextType)));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps,
        hasNewLifecycles =
          "function" === typeof getDerivedStateFromProps ||
          "function" === typeof instance.getSnapshotBeforeUpdate;
      hasNewLifecycles ||
        ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
          "function" !== typeof instance.componentWillReceiveProps) ||
        ((oldProps !== nextProps || oldContext !== contextType) &&
          callComponentWillReceiveProps(
            workInProgress,
            instance,
            nextProps,
            contextType
          ));
      hasForceUpdate = !1;
      var oldState = workInProgress.memoizedState;
      oldContext = instance.state = oldState;
      var updateQueue = workInProgress.updateQueue;
      null !== updateQueue &&
        (processUpdateQueue(
          workInProgress,
          updateQueue,
          nextProps,
          instance,
          renderExpirationTime
        ),
        (oldContext = workInProgress.memoizedState));
      oldProps !== nextProps ||
      oldState !== oldContext ||
      didPerformWorkStackCursor.current ||
      hasForceUpdate
        ? ("function" === typeof getDerivedStateFromProps &&
            (applyDerivedStateFromProps(
              workInProgress,
              Component,
              getDerivedStateFromProps,
              nextProps
            ),
            (oldContext = workInProgress.memoizedState)),
          (oldProps =
            hasForceUpdate ||
            checkShouldComponentUpdate(
              workInProgress,
              Component,
              oldProps,
              nextProps,
              oldState,
              oldContext,
              contextType
            ))
            ? (hasNewLifecycles ||
                ("function" !== typeof instance.UNSAFE_componentWillMount &&
                  "function" !== typeof instance.componentWillMount) ||
                ("function" === typeof instance.componentWillMount &&
                  instance.componentWillMount(),
                "function" === typeof instance.UNSAFE_componentWillMount &&
                  instance.UNSAFE_componentWillMount()),
              "function" === typeof instance.componentDidMount &&
                (workInProgress.effectTag |= 4))
            : ("function" === typeof instance.componentDidMount &&
                (workInProgress.effectTag |= 4),
              (workInProgress.memoizedProps = nextProps),
              (workInProgress.memoizedState = oldContext)),
          (instance.props = nextProps),
          (instance.state = oldContext),
          (instance.context = contextType),
          (nextProps = oldProps))
        : ("function" === typeof instance.componentDidMount &&
            (workInProgress.effectTag |= 4),
          (nextProps = !1));
    } else
      (instance = workInProgress.stateNode),
        (oldProps = workInProgress.memoizedProps),
        (instance.props =
          workInProgress.type === workInProgress.elementType
            ? oldProps
            : resolveDefaultProps(workInProgress.type, oldProps)),
        (oldContext = instance.context),
        (contextType = Component.contextType),
        "object" === typeof contextType && null !== contextType
          ? (contextType = readContext(contextType))
          : ((contextType = isContextProvider(Component)
              ? previousContext
              : contextStackCursor.current),
            (contextType = getMaskedContext(workInProgress, contextType))),
        (getDerivedStateFromProps = Component.getDerivedStateFromProps),
        (hasNewLifecycles =
          "function" === typeof getDerivedStateFromProps ||
          "function" === typeof instance.getSnapshotBeforeUpdate) ||
          ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
            "function" !== typeof instance.componentWillReceiveProps) ||
          ((oldProps !== nextProps || oldContext !== contextType) &&
            callComponentWillReceiveProps(
              workInProgress,
              instance,
              nextProps,
              contextType
            )),
        (hasForceUpdate = !1),
        (oldContext = workInProgress.memoizedState),
        (oldState = instance.state = oldContext),
        (updateQueue = workInProgress.updateQueue),
        null !== updateQueue &&
          (processUpdateQueue(
            workInProgress,
            updateQueue,
            nextProps,
            instance,
            renderExpirationTime
          ),
          (oldState = workInProgress.memoizedState)),
        oldProps !== nextProps ||
        oldContext !== oldState ||
        didPerformWorkStackCursor.current ||
        hasForceUpdate
          ? ("function" === typeof getDerivedStateFromProps &&
              (applyDerivedStateFromProps(
                workInProgress,
                Component,
                getDerivedStateFromProps,
                nextProps
              ),
              (oldState = workInProgress.memoizedState)),
            (getDerivedStateFromProps =
              hasForceUpdate ||
              checkShouldComponentUpdate(
                workInProgress,
                Component,
                oldProps,
                nextProps,
                oldContext,
                oldState,
                contextType
              ))
              ? (hasNewLifecycles ||
                  ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
                    "function" !== typeof instance.componentWillUpdate) ||
                  ("function" === typeof instance.componentWillUpdate &&
                    instance.componentWillUpdate(
                      nextProps,
                      oldState,
                      contextType
                    ),
                  "function" === typeof instance.UNSAFE_componentWillUpdate &&
                    instance.UNSAFE_componentWillUpdate(
                      nextProps,
                      oldState,
                      contextType
                    )),
                "function" === typeof instance.componentDidUpdate &&
                  (workInProgress.effectTag |= 4),
                "function" === typeof instance.getSnapshotBeforeUpdate &&
                  (workInProgress.effectTag |= 256))
              : ("function" !== typeof instance.componentDidUpdate ||
                  (oldProps === current.memoizedProps &&
                    oldContext === current.memoizedState) ||
                  (workInProgress.effectTag |= 4),
                "function" !== typeof instance.getSnapshotBeforeUpdate ||
                  (oldProps === current.memoizedProps &&
                    oldContext === current.memoizedState) ||
                  (workInProgress.effectTag |= 256),
                (workInProgress.memoizedProps = nextProps),
                (workInProgress.memoizedState = oldState)),
            (instance.props = nextProps),
            (instance.state = oldState),
            (instance.context = contextType),
            (nextProps = getDerivedStateFromProps))
          : ("function" !== typeof instance.componentDidUpdate ||
              (oldProps === current.memoizedProps &&
                oldContext === current.memoizedState) ||
              (workInProgress.effectTag |= 4),
            "function" !== typeof instance.getSnapshotBeforeUpdate ||
              (oldProps === current.memoizedProps &&
                oldContext === current.memoizedState) ||
              (workInProgress.effectTag |= 256),
            (nextProps = !1));
    return finishClassComponent(
      current,
      workInProgress,
      Component,
      nextProps,
      hasContext,
      renderExpirationTime
    );
  }
  function finishClassComponent(
    current,
    workInProgress,
    Component,
    shouldUpdate,
    hasContext,
    renderExpirationTime
  ) {
    markRef(current, workInProgress);
    var didCaptureError = 0 !== (workInProgress.effectTag & 64);
    if (!shouldUpdate && !didCaptureError)
      return (
        hasContext && invalidateContextProvider(workInProgress, Component, !1),
        bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderExpirationTime
        )
      );
    shouldUpdate = workInProgress.stateNode;
    ReactCurrentOwner$2.current = workInProgress;
    var nextChildren =
      didCaptureError &&
      "function" !== typeof Component.getDerivedStateFromError
        ? null
        : shouldUpdate.render();
    workInProgress.effectTag |= 1;
    null !== current && didCaptureError
      ? ((workInProgress.child = reconcileChildFibers(
          workInProgress,
          current.child,
          null,
          renderExpirationTime
        )),
        (workInProgress.child = reconcileChildFibers(
          workInProgress,
          null,
          nextChildren,
          renderExpirationTime
        )))
      : reconcileChildren(
          current,
          workInProgress,
          nextChildren,
          renderExpirationTime
        );
    workInProgress.memoizedState = shouldUpdate.state;
    hasContext && invalidateContextProvider(workInProgress, Component, !0);
    return workInProgress.child;
  }
  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    root.pendingContext
      ? pushTopLevelContextObject(
          workInProgress,
          root.pendingContext,
          root.pendingContext !== root.context
        )
      : root.context &&
        pushTopLevelContextObject(workInProgress, root.context, !1);
    pushHostContainer(workInProgress, root.containerInfo);
  }
  function updateSuspenseComponent(
    current,
    workInProgress,
    renderExpirationTime
  ) {
    var mode = workInProgress.mode,
      nextProps = workInProgress.pendingProps,
      suspenseContext = suspenseStackCursor.current,
      nextDidTimeout = !1,
      JSCompiler_temp;
    (JSCompiler_temp = 0 !== (workInProgress.effectTag & 64)) ||
      (JSCompiler_temp =
        0 !== (suspenseContext & 2) &&
        (null === current || null !== current.memoizedState));
    JSCompiler_temp
      ? ((nextDidTimeout = !0), (workInProgress.effectTag &= -65))
      : (null !== current && null === current.memoizedState) ||
        void 0 === nextProps.fallback ||
        !0 === nextProps.unstable_avoidThisFallback ||
        (suspenseContext |= 1);
    push(suspenseStackCursor, suspenseContext & 1, workInProgress);
    if (null === current) {
      if (nextDidTimeout) {
        nextDidTimeout = nextProps.fallback;
        nextProps = createFiberFromFragment(null, mode, 0, null);
        nextProps.return = workInProgress;
        if (0 === (workInProgress.mode & 2))
          for (
            current =
              null !== workInProgress.memoizedState
                ? workInProgress.child.child
                : workInProgress.child,
              nextProps.child = current;
            null !== current;

          )
            (current.return = nextProps), (current = current.sibling);
        renderExpirationTime = createFiberFromFragment(
          nextDidTimeout,
          mode,
          renderExpirationTime,
          null
        );
        renderExpirationTime.return = workInProgress;
        nextProps.sibling = renderExpirationTime;
        workInProgress.memoizedState = SUSPENDED_MARKER;
        workInProgress.child = nextProps;
        return renderExpirationTime;
      }
      mode = nextProps.children;
      workInProgress.memoizedState = null;
      return (workInProgress.child = mountChildFibers(
        workInProgress,
        null,
        mode,
        renderExpirationTime
      ));
    }
    if (null !== current.memoizedState) {
      current = current.child;
      mode = current.sibling;
      if (nextDidTimeout) {
        nextProps = nextProps.fallback;
        renderExpirationTime = createWorkInProgress(
          current,
          current.pendingProps,
          0
        );
        renderExpirationTime.return = workInProgress;
        if (
          0 === (workInProgress.mode & 2) &&
          ((nextDidTimeout =
            null !== workInProgress.memoizedState
              ? workInProgress.child.child
              : workInProgress.child),
          nextDidTimeout !== current.child)
        )
          for (
            renderExpirationTime.child = nextDidTimeout;
            null !== nextDidTimeout;

          )
            (nextDidTimeout.return = renderExpirationTime),
              (nextDidTimeout = nextDidTimeout.sibling);
        mode = createWorkInProgress(mode, nextProps, mode.expirationTime);
        mode.return = workInProgress;
        renderExpirationTime.sibling = mode;
        renderExpirationTime.childExpirationTime = 0;
        workInProgress.memoizedState = SUSPENDED_MARKER;
        workInProgress.child = renderExpirationTime;
        return mode;
      }
      renderExpirationTime = reconcileChildFibers(
        workInProgress,
        current.child,
        nextProps.children,
        renderExpirationTime
      );
      workInProgress.memoizedState = null;
      return (workInProgress.child = renderExpirationTime);
    }
    current = current.child;
    if (nextDidTimeout) {
      nextDidTimeout = nextProps.fallback;
      nextProps = createFiberFromFragment(null, mode, 0, null);
      nextProps.return = workInProgress;
      nextProps.child = current;
      null !== current && (current.return = nextProps);
      if (0 === (workInProgress.mode & 2))
        for (
          current =
            null !== workInProgress.memoizedState
              ? workInProgress.child.child
              : workInProgress.child,
            nextProps.child = current;
          null !== current;

        )
          (current.return = nextProps), (current = current.sibling);
      renderExpirationTime = createFiberFromFragment(
        nextDidTimeout,
        mode,
        renderExpirationTime,
        null
      );
      renderExpirationTime.return = workInProgress;
      nextProps.sibling = renderExpirationTime;
      renderExpirationTime.effectTag |= 2;
      nextProps.childExpirationTime = 0;
      workInProgress.memoizedState = SUSPENDED_MARKER;
      workInProgress.child = nextProps;
      return renderExpirationTime;
    }
    workInProgress.memoizedState = null;
    return (workInProgress.child = reconcileChildFibers(
      workInProgress,
      current,
      nextProps.children,
      renderExpirationTime
    ));
  }
  function initSuspenseListRenderState(
    workInProgress,
    isBackwards,
    tail,
    lastContentRow,
    tailMode
  ) {
    var renderState = workInProgress.memoizedState;
    null === renderState
      ? (workInProgress.memoizedState = {
          isBackwards: isBackwards,
          rendering: null,
          last: lastContentRow,
          tail: tail,
          tailExpiration: 0,
          tailMode: tailMode
        })
      : ((renderState.isBackwards = isBackwards),
        (renderState.rendering = null),
        (renderState.last = lastContentRow),
        (renderState.tail = tail),
        (renderState.tailExpiration = 0),
        (renderState.tailMode = tailMode));
  }
  function updateSuspenseListComponent(
    current,
    workInProgress,
    renderExpirationTime
  ) {
    var nextProps = workInProgress.pendingProps,
      revealOrder = nextProps.revealOrder,
      tailMode = nextProps.tail;
    reconcileChildren(
      current,
      workInProgress,
      nextProps.children,
      renderExpirationTime
    );
    nextProps = suspenseStackCursor.current;
    if (0 !== (nextProps & 2))
      (nextProps = (nextProps & 1) | 2), (workInProgress.effectTag |= 64);
    else {
      if (null !== current && 0 !== (current.effectTag & 64))
        a: for (current = workInProgress.child; null !== current; ) {
          if (13 === current.tag) {
            if (null !== current.memoizedState) {
              current.expirationTime < renderExpirationTime &&
                (current.expirationTime = renderExpirationTime);
              var alternate = current.alternate;
              null !== alternate &&
                alternate.expirationTime < renderExpirationTime &&
                (alternate.expirationTime = renderExpirationTime);
              scheduleWorkOnParentPath(current.return, renderExpirationTime);
            }
          } else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      nextProps &= 1;
    }
    push(suspenseStackCursor, nextProps, workInProgress);
    if (0 === (workInProgress.mode & 2)) workInProgress.memoizedState = null;
    else
      switch (revealOrder) {
        case "forwards":
          renderExpirationTime = workInProgress.child;
          for (revealOrder = null; null !== renderExpirationTime; )
            (nextProps = renderExpirationTime.alternate),
              null !== nextProps &&
                null === findFirstSuspended(nextProps) &&
                (revealOrder = renderExpirationTime),
              (renderExpirationTime = renderExpirationTime.sibling);
          renderExpirationTime = revealOrder;
          null === renderExpirationTime
            ? ((revealOrder = workInProgress.child),
              (workInProgress.child = null))
            : ((revealOrder = renderExpirationTime.sibling),
              (renderExpirationTime.sibling = null));
          initSuspenseListRenderState(
            workInProgress,
            !1,
            revealOrder,
            renderExpirationTime,
            tailMode
          );
          break;
        case "backwards":
          renderExpirationTime = null;
          revealOrder = workInProgress.child;
          for (workInProgress.child = null; null !== revealOrder; ) {
            nextProps = revealOrder.alternate;
            if (null !== nextProps && null === findFirstSuspended(nextProps)) {
              workInProgress.child = revealOrder;
              break;
            }
            nextProps = revealOrder.sibling;
            revealOrder.sibling = renderExpirationTime;
            renderExpirationTime = revealOrder;
            revealOrder = nextProps;
          }
          initSuspenseListRenderState(
            workInProgress,
            !0,
            renderExpirationTime,
            null,
            tailMode
          );
          break;
        case "together":
          initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
          break;
        default:
          workInProgress.memoizedState = null;
      }
    return workInProgress.child;
  }
  function bailoutOnAlreadyFinishedWork(
    current,
    workInProgress,
    renderExpirationTime
  ) {
    null !== current && (workInProgress.dependencies = current.dependencies);
    if (workInProgress.childExpirationTime < renderExpirationTime) return null;
    if (null !== current && workInProgress.child !== current.child)
      throw ReactErrorProd(Error(153));
    if (null !== workInProgress.child) {
      current = workInProgress.child;
      renderExpirationTime = createWorkInProgress(
        current,
        current.pendingProps,
        current.expirationTime
      );
      workInProgress.child = renderExpirationTime;
      for (
        renderExpirationTime.return = workInProgress;
        null !== current.sibling;

      )
        (current = current.sibling),
          (renderExpirationTime = renderExpirationTime.sibling = createWorkInProgress(
            current,
            current.pendingProps,
            current.expirationTime
          )),
          (renderExpirationTime.return = workInProgress);
      renderExpirationTime.sibling = null;
    }
    return workInProgress.child;
  }
  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate &&
            (lastTailNode = hasRenderedATailFallback),
            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
        null === lastTailNode
          ? (renderState.tail = null)
          : (lastTailNode.sibling = null);
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var _lastTailNode = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (_lastTailNode = lastTailNode),
            (lastTailNode = lastTailNode.sibling);
        null === _lastTailNode
          ? hasRenderedATailFallback || null === renderState.tail
            ? (renderState.tail = null)
            : (renderState.tail.sibling = null)
          : (_lastTailNode.sibling = null);
    }
  }
  function unwindWork(workInProgress, renderExpirationTime) {
    switch (workInProgress.tag) {
      case 1:
        return (
          isContextProvider(workInProgress.type) && popContext(workInProgress),
          (renderExpirationTime = workInProgress.effectTag),
          renderExpirationTime & 4096
            ? ((workInProgress.effectTag = (renderExpirationTime & -4097) | 64),
              workInProgress)
            : null
        );
      case 3:
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        renderExpirationTime = workInProgress.effectTag;
        if (0 !== (renderExpirationTime & 64)) throw ReactErrorProd(Error(285));
        workInProgress.effectTag = (renderExpirationTime & -4097) | 64;
        return workInProgress;
      case 5:
        return popHostContext(workInProgress), null;
      case 13:
        return (
          pop(suspenseStackCursor, workInProgress),
          (renderExpirationTime = workInProgress.effectTag),
          renderExpirationTime & 4096
            ? ((workInProgress.effectTag = (renderExpirationTime & -4097) | 64),
              workInProgress)
            : null
        );
      case 19:
        return pop(suspenseStackCursor, workInProgress), null;
      case 4:
        return popHostContainer(workInProgress), null;
      case 10:
        return popProvider(workInProgress), null;
      default:
        return null;
    }
  }
  function createCapturedValue(value, source) {
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  function logError(boundary, errorInfo) {
    var source = errorInfo.source,
      stack = errorInfo.stack;
    null === stack &&
      null !== source &&
      (stack = getStackByFiberInDevAndProd(source));
    null !== source && getComponentName(source.type);
    errorInfo = errorInfo.value;
    null !== boundary && 1 === boundary.tag && getComponentName(boundary.type);
    try {
      console.error(errorInfo);
    } catch (e) {
      setTimeout(function() {
        throw e;
      });
    }
  }
  function safelyCallComponentWillUnmount(current, instance) {
    try {
      (instance.props = current.memoizedProps),
        (instance.state = current.memoizedState),
        instance.componentWillUnmount();
    } catch (unmountError) {
      captureCommitPhaseError(current, unmountError);
    }
  }
  function safelyDetachRef(current) {
    var ref = current.ref;
    if (null !== ref)
      if ("function" === typeof ref)
        try {
          ref(null);
        } catch (refError) {
          captureCommitPhaseError(current, refError);
        }
      else ref.current = null;
  }
  function commitHookEffectList(unmountTag, mountTag, finishedWork) {
    finishedWork = finishedWork.updateQueue;
    finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
    if (null !== finishedWork) {
      var effect = (finishedWork = finishedWork.next);
      do {
        if (0 !== (effect.tag & unmountTag)) {
          var destroy = effect.destroy;
          effect.destroy = void 0;
          void 0 !== destroy && destroy();
        }
        0 !== (effect.tag & mountTag) &&
          ((destroy = effect.create), (effect.destroy = destroy()));
        effect = effect.next;
      } while (effect !== finishedWork);
    }
  }
  function commitUnmount(finishedRoot, current$jscomp$0, renderPriorityLevel) {
    "function" === typeof onCommitFiberUnmount &&
      onCommitFiberUnmount(current$jscomp$0);
    switch (current$jscomp$0.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        finishedRoot = current$jscomp$0.updateQueue;
        if (
          null !== finishedRoot &&
          ((finishedRoot = finishedRoot.lastEffect), null !== finishedRoot)
        ) {
          var firstEffect = finishedRoot.next;
          runWithPriority(
            97 < renderPriorityLevel ? 97 : renderPriorityLevel,
            function() {
              var effect = firstEffect;
              do {
                var destroy = effect.destroy;
                if (void 0 !== destroy) {
                  var current = current$jscomp$0;
                  try {
                    destroy();
                  } catch (error) {
                    captureCommitPhaseError(current, error);
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          );
        }
        break;
      case 1:
        safelyDetachRef(current$jscomp$0);
        renderPriorityLevel = current$jscomp$0.stateNode;
        "function" === typeof renderPriorityLevel.componentWillUnmount &&
          safelyCallComponentWillUnmount(current$jscomp$0, renderPriorityLevel);
        break;
      case 5:
        safelyDetachRef(current$jscomp$0);
        break;
      case 4:
        unmountHostComponents(
          finishedRoot,
          current$jscomp$0,
          renderPriorityLevel
        );
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
  }
  function commitPlacement(finishedWork) {
    a: {
      for (var parent = finishedWork.return; null !== parent; ) {
        if (isHostParent(parent)) {
          var parentFiber = parent;
          break a;
        }
        parent = parent.return;
      }
      throw ReactErrorProd(Error(160));
    }
    parent = parentFiber.stateNode;
    switch (parentFiber.tag) {
      case 5:
        var isContainer = !1;
        break;
      case 3:
        parent = parent.containerInfo;
        isContainer = !0;
        break;
      case 4:
        parent = parent.containerInfo;
        isContainer = !0;
        break;
      default:
        throw ReactErrorProd(Error(161));
    }
    parentFiber.effectTag & 16 && (parentFiber.effectTag &= -17);
    a: b: for (parentFiber = finishedWork; ; ) {
      for (; null === parentFiber.sibling; ) {
        if (null === parentFiber.return || isHostParent(parentFiber.return)) {
          parentFiber = null;
          break a;
        }
        parentFiber = parentFiber.return;
      }
      parentFiber.sibling.return = parentFiber.return;
      for (
        parentFiber = parentFiber.sibling;
        5 !== parentFiber.tag &&
        6 !== parentFiber.tag &&
        18 !== parentFiber.tag;

      ) {
        if (parentFiber.effectTag & 2) continue b;
        if (null === parentFiber.child || 4 === parentFiber.tag) continue b;
        else
          (parentFiber.child.return = parentFiber),
            (parentFiber = parentFiber.child);
      }
      if (!(parentFiber.effectTag & 2)) {
        parentFiber = parentFiber.stateNode;
        break a;
      }
    }
    for (var node = finishedWork; ; ) {
      var isHost = 5 === node.tag || 6 === node.tag;
      if (isHost)
        if (
          ((isHost = isHost ? node.stateNode : node.stateNode.instance),
          parentFiber)
        )
          if (isContainer) {
            var beforeChild = parentFiber;
            if (isHost === beforeChild) throw ReactErrorProd(Error(218));
            isHost.injectBefore(beforeChild);
          } else {
            beforeChild = parentFiber;
            if (isHost === beforeChild) throw ReactErrorProd(Error(218));
            isHost.injectBefore(beforeChild);
          }
        else
          (beforeChild = parent),
            isHost.parentNode === beforeChild && isHost.eject(),
            isHost.inject(beforeChild);
      else if (4 !== node.tag && null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  function unmountHostComponents(
    finishedRoot$jscomp$0,
    current,
    renderPriorityLevel$jscomp$0
  ) {
    for (
      var node = current, currentParentIsValid = !1, currentParentIsContainer;
      ;

    ) {
      if (!currentParentIsValid) {
        currentParentIsValid = node.return;
        a: for (;;) {
          if (null === currentParentIsValid) throw ReactErrorProd(Error(160));
          switch (currentParentIsValid.tag) {
            case 5:
              currentParentIsContainer = !1;
              break a;
            case 3:
              currentParentIsContainer = !0;
              break a;
            case 4:
              currentParentIsContainer = !0;
              break a;
          }
          currentParentIsValid = currentParentIsValid.return;
        }
        currentParentIsValid = !0;
      }
      if (5 === node.tag || 6 === node.tag) {
        a: for (
          var finishedRoot = finishedRoot$jscomp$0,
            root = node,
            renderPriorityLevel = renderPriorityLevel$jscomp$0,
            node$jscomp$0 = root;
          ;

        )
          if (
            (commitUnmount(finishedRoot, node$jscomp$0, renderPriorityLevel),
            null !== node$jscomp$0.child && 4 !== node$jscomp$0.tag)
          )
            (node$jscomp$0.child.return = node$jscomp$0),
              (node$jscomp$0 = node$jscomp$0.child);
          else {
            if (node$jscomp$0 === root) break;
            for (; null === node$jscomp$0.sibling; ) {
              if (
                null === node$jscomp$0.return ||
                node$jscomp$0.return === root
              )
                break a;
              node$jscomp$0 = node$jscomp$0.return;
            }
            node$jscomp$0.sibling.return = node$jscomp$0.return;
            node$jscomp$0 = node$jscomp$0.sibling;
          }
        (finishedRoot = node.stateNode),
          destroyEventListeners(finishedRoot),
          finishedRoot.eject();
      } else if (4 === node.tag) {
        if (null !== node.child) {
          currentParentIsContainer = !0;
          node.child.return = node;
          node = node.child;
          continue;
        }
      } else if (
        (commitUnmount(
          finishedRoot$jscomp$0,
          node,
          renderPriorityLevel$jscomp$0
        ),
        null !== node.child)
      ) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === current) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === current) return;
        node = node.return;
        4 === node.tag && (currentParentIsValid = !1);
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectList(4, 8, finishedWork);
        break;
      case 1:
        break;
      case 5:
        var instance = finishedWork.stateNode;
        if (null != instance) {
          var newProps = finishedWork.memoizedProps;
          current = null !== current ? current.memoizedProps : newProps;
          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;
          null !== updatePayload &&
            instance._applyProps(instance, newProps, current);
        }
        break;
      case 6:
        if (null === finishedWork.stateNode) throw ReactErrorProd(Error(162));
        break;
      case 3:
        break;
      case 12:
        break;
      case 13:
        instance = finishedWork;
        null === finishedWork.memoizedState
          ? (newProps = !1)
          : ((newProps = !0),
            (instance = finishedWork.child),
            (globalMostRecentFallbackTime = now()));
        if (null !== instance)
          a: for (current = instance; ; ) {
            if (5 === current.tag)
              (updatePayload = current.stateNode),
                newProps
                  ? updatePayload.hide()
                  : ((updatePayload = current.memoizedProps),
                    (null == updatePayload.visible || updatePayload.visible) &&
                      current.stateNode.show());
            else if (6 !== current.tag)
              if (
                13 === current.tag &&
                null !== current.memoizedState &&
                null === current.memoizedState.dehydrated
              ) {
                updatePayload = current.child.sibling;
                updatePayload.return = current;
                current = updatePayload;
                continue;
              } else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
            if (current === instance) break a;
            for (; null === current.sibling; ) {
              if (null === current.return || current.return === instance)
                break a;
              current = current.return;
            }
            current.sibling.return = current.return;
            current = current.sibling;
          }
        attachSuspenseRetryListeners(finishedWork);
        break;
      case 19:
        attachSuspenseRetryListeners(finishedWork);
        break;
      case 17:
        break;
      case 20:
        break;
      default:
        throw ReactErrorProd(Error(163));
    }
  }
  function attachSuspenseRetryListeners(finishedWork) {
    var thenables = finishedWork.updateQueue;
    if (null !== thenables) {
      finishedWork.updateQueue = null;
      var retryCache = finishedWork.stateNode;
      null === retryCache &&
        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      thenables.forEach(function(thenable) {
        var retry = resolveRetryThenable.bind(null, finishedWork, thenable);
        retryCache.has(thenable) ||
          (retryCache.add(thenable), thenable.then(retry, retry));
      });
    }
  }
  function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime, null);
    expirationTime.tag = 3;
    expirationTime.payload = { element: null };
    var error = errorInfo.value;
    expirationTime.callback = function() {
      hasUncaughtError ||
        ((hasUncaughtError = !0), (firstUncaughtError = error));
      logError(fiber, errorInfo);
    };
    return expirationTime;
  }
  function createClassErrorUpdate(fiber, errorInfo, expirationTime) {
    expirationTime = createUpdate(expirationTime, null);
    expirationTime.tag = 3;
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;
      expirationTime.payload = function() {
        logError(fiber, errorInfo);
        return getDerivedStateFromError(error);
      };
    }
    var inst = fiber.stateNode;
    null !== inst &&
      "function" === typeof inst.componentDidCatch &&
      (expirationTime.callback = function() {
        "function" !== typeof getDerivedStateFromError &&
          (null === legacyErrorBoundariesThatAlreadyFailed
            ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
            : legacyErrorBoundariesThatAlreadyFailed.add(this),
          logError(fiber, errorInfo));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    return expirationTime;
  }
  function requestCurrentTime() {
    return (executionContext & (RenderContext | CommitContext)) !== NoContext
      ? 1073741821 - ((now() / 10) | 0)
      : 0 !== currentEventTime
        ? currentEventTime
        : (currentEventTime = 1073741821 - ((now() / 10) | 0));
  }
  function computeExpirationForFiber(currentTime, fiber, suspenseConfig) {
    fiber = fiber.mode;
    if (0 === (fiber & 2)) return 1073741823;
    var priorityLevel = getCurrentPriorityLevel();
    if (0 === (fiber & 4))
      return 99 === priorityLevel ? 1073741823 : 1073741822;
    if ((executionContext & RenderContext) !== NoContext)
      return renderExpirationTime;
    if (null !== suspenseConfig)
      currentTime =
        1073741821 -
        25 *
          ((((1073741821 -
            currentTime +
            (suspenseConfig.timeoutMs | 0 || 5e3) / 10) /
            25) |
            0) +
            1);
    else
      switch (priorityLevel) {
        case 99:
          currentTime = 1073741823;
          break;
        case 98:
          currentTime =
            1073741821 -
            10 * ((((1073741821 - currentTime + 15) / 10) | 0) + 1);
          break;
        case 97:
        case 96:
          currentTime =
            1073741821 -
            25 * ((((1073741821 - currentTime + 500) / 25) | 0) + 1);
          break;
        case 95:
          currentTime = 1;
          break;
        default:
          throw ReactErrorProd(Error(326));
      }
    null !== workInProgressRoot &&
      currentTime === renderExpirationTime &&
      --currentTime;
    return currentTime;
  }
  function markUpdateTimeFromFiberToRoot(fiber, expirationTime) {
    fiber.expirationTime < expirationTime &&
      (fiber.expirationTime = expirationTime);
    var alternate = fiber.alternate;
    null !== alternate &&
      alternate.expirationTime < expirationTime &&
      (alternate.expirationTime = expirationTime);
    var node = fiber.return,
      root = null;
    if (null === node && 3 === fiber.tag) root = fiber.stateNode;
    else
      for (; null !== node; ) {
        alternate = node.alternate;
        node.childExpirationTime < expirationTime &&
          (node.childExpirationTime = expirationTime);
        null !== alternate &&
          alternate.childExpirationTime < expirationTime &&
          (alternate.childExpirationTime = expirationTime);
        if (null === node.return && 3 === node.tag) {
          root = node.stateNode;
          break;
        }
        node = node.return;
      }
    null !== root &&
      (expirationTime > root.firstPendingTime &&
        (root.firstPendingTime = expirationTime),
      (fiber = root.lastPendingTime),
      0 === fiber || expirationTime < fiber) &&
      (root.lastPendingTime = expirationTime);
    return root;
  }
  function scheduleCallbackForRoot(root, priorityLevel, expirationTime) {
    if (root.callbackExpirationTime < expirationTime) {
      var existingCallbackNode = root.callbackNode;
      null !== existingCallbackNode &&
        existingCallbackNode !== fakeCallbackNode &&
        Scheduler_cancelCallback(existingCallbackNode);
      root.callbackExpirationTime = expirationTime;
      1073741823 === expirationTime
        ? (root.callbackNode = scheduleSyncCallback(
            runRootCallback.bind(
              null,
              root,
              renderRoot.bind(null, root, expirationTime)
            )
          ))
        : ((existingCallbackNode = null),
          1 !== expirationTime &&
            (existingCallbackNode = {
              timeout: 10 * (1073741821 - expirationTime) - now()
            }),
          (root.callbackNode = scheduleCallback(
            priorityLevel,
            runRootCallback.bind(
              null,
              root,
              renderRoot.bind(null, root, expirationTime)
            ),
            existingCallbackNode
          )));
    }
  }
  function runRootCallback(root, callback, isSync) {
    var prevCallbackNode = root.callbackNode,
      continuation = null;
    try {
      return (
        (continuation = callback(isSync)),
        null !== continuation
          ? runRootCallback.bind(null, root, continuation)
          : null
      );
    } finally {
      null === continuation &&
        prevCallbackNode === root.callbackNode &&
        ((root.callbackNode = null), (root.callbackExpirationTime = 0));
    }
  }
  function resolveLocksOnRoot(root, expirationTime) {
    var firstBatch = root.firstBatch;
    return null !== firstBatch &&
      firstBatch._defer &&
      firstBatch._expirationTime >= expirationTime
      ? (scheduleCallback(97, function() {
          firstBatch._onComplete();
          return null;
        }),
        !0)
      : !1;
  }
  function prepareFreshStack(root, expirationTime) {
    root.finishedWork = null;
    root.finishedExpirationTime = 0;
    var timeoutHandle = root.timeoutHandle;
    -1 !== timeoutHandle &&
      ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
    if (null !== workInProgress)
      for (timeoutHandle = workInProgress.return; null !== timeoutHandle; ) {
        var interruptedWork = timeoutHandle;
        switch (interruptedWork.tag) {
          case 1:
            var childContextTypes = interruptedWork.type.childContextTypes;
            null !== childContextTypes &&
              void 0 !== childContextTypes &&
              popContext(interruptedWork);
            break;
          case 3:
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            break;
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer(interruptedWork);
            break;
          case 13:
            pop(suspenseStackCursor, interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor, interruptedWork);
            break;
          case 10:
            popProvider(interruptedWork);
        }
        timeoutHandle = timeoutHandle.return;
      }
    workInProgressRoot = root;
    workInProgress = createWorkInProgress(root.current, null, expirationTime);
    renderExpirationTime = expirationTime;
    workInProgressRootExitStatus = RootIncomplete;
    workInProgressRootLatestSuspenseTimeout = workInProgressRootLatestProcessedExpirationTime = 1073741823;
    workInProgressRootCanSuspendUsingConfig = null;
    workInProgressRootHasPendingPing = !1;
  }
  function renderRoot(root$jscomp$0, expirationTime, isSync) {
    if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
      throw ReactErrorProd(Error(327));
    if (root$jscomp$0.firstPendingTime < expirationTime) return null;
    if (isSync && root$jscomp$0.finishedExpirationTime === expirationTime)
      return commitRoot.bind(null, root$jscomp$0);
    flushPassiveEffects();
    if (
      root$jscomp$0 !== workInProgressRoot ||
      expirationTime !== renderExpirationTime
    )
      prepareFreshStack(root$jscomp$0, expirationTime);
    else if (workInProgressRootExitStatus === RootSuspendedWithDelay)
      if (workInProgressRootHasPendingPing)
        prepareFreshStack(root$jscomp$0, expirationTime);
      else {
        var lastPendingTime = root$jscomp$0.lastPendingTime;
        if (lastPendingTime < expirationTime)
          return renderRoot.bind(null, root$jscomp$0, lastPendingTime);
      }
    if (null !== workInProgress) {
      lastPendingTime = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = ReactCurrentDispatcher.current;
      null === prevDispatcher && (prevDispatcher = ContextOnlyDispatcher);
      ReactCurrentDispatcher.current = ContextOnlyDispatcher;
      if (isSync) {
        if (1073741823 !== expirationTime) {
          var currentTime = requestCurrentTime();
          if (currentTime < expirationTime)
            return (
              (executionContext = lastPendingTime),
              resetContextDependencies(),
              (ReactCurrentDispatcher.current = prevDispatcher),
              renderRoot.bind(null, root$jscomp$0, currentTime)
            );
        }
      } else currentEventTime = 0;
      do
        try {
          if (isSync)
            for (; null !== workInProgress; )
              workInProgress = performUnitOfWork(workInProgress);
          else
            for (; null !== workInProgress && !shouldYield(); )
              workInProgress = performUnitOfWork(workInProgress);
          break;
        } catch (thrownValue) {
          resetContextDependencies();
          resetHooks();
          currentTime = workInProgress;
          if (null === currentTime || null === currentTime.return)
            throw (prepareFreshStack(root$jscomp$0, expirationTime),
            (executionContext = lastPendingTime),
            thrownValue);
          a: {
            var root = root$jscomp$0,
              returnFiber = currentTime.return,
              sourceFiber = currentTime,
              value = thrownValue,
              renderExpirationTime$jscomp$0 = renderExpirationTime;
            sourceFiber.effectTag |= 2048;
            sourceFiber.firstEffect = sourceFiber.lastEffect = null;
            if (
              null !== value &&
              "object" === typeof value &&
              "function" === typeof value.then
            ) {
              var thenable = value,
                hasInvisibleParentBoundary =
                  0 !== (suspenseStackCursor.current & 1);
              value = returnFiber;
              do {
                var JSCompiler_temp;
                if ((JSCompiler_temp = 13 === value.tag))
                  (JSCompiler_temp = value.memoizedState),
                    null !== JSCompiler_temp
                      ? (JSCompiler_temp =
                          null !== JSCompiler_temp.dehydrated ? !0 : !1)
                      : ((JSCompiler_temp = value.memoizedProps),
                        (JSCompiler_temp =
                          void 0 === JSCompiler_temp.fallback
                            ? !1
                            : !0 !== JSCompiler_temp.unstable_avoidThisFallback
                              ? !0
                              : hasInvisibleParentBoundary
                                ? !1
                                : !0));
                if (JSCompiler_temp) {
                  returnFiber = value.updateQueue;
                  null === returnFiber
                    ? ((returnFiber = new Set()),
                      returnFiber.add(thenable),
                      (value.updateQueue = returnFiber))
                    : returnFiber.add(thenable);
                  if (0 === (value.mode & 2)) {
                    value.effectTag |= 64;
                    sourceFiber.effectTag &= -2981;
                    1 === sourceFiber.tag &&
                      (null === sourceFiber.alternate
                        ? (sourceFiber.tag = 17)
                        : ((renderExpirationTime$jscomp$0 = createUpdate(
                            1073741823,
                            null
                          )),
                          (renderExpirationTime$jscomp$0.tag = ForceUpdate),
                          enqueueUpdate(
                            sourceFiber,
                            renderExpirationTime$jscomp$0
                          )));
                    sourceFiber.expirationTime = 1073741823;
                    break a;
                  }
                  sourceFiber = root;
                  root = renderExpirationTime$jscomp$0;
                  hasInvisibleParentBoundary = sourceFiber.pingCache;
                  null === hasInvisibleParentBoundary
                    ? ((hasInvisibleParentBoundary = sourceFiber.pingCache = new PossiblyWeakMap()),
                      (returnFiber = new Set()),
                      hasInvisibleParentBoundary.set(thenable, returnFiber))
                    : ((returnFiber = hasInvisibleParentBoundary.get(thenable)),
                      void 0 === returnFiber &&
                        ((returnFiber = new Set()),
                        hasInvisibleParentBoundary.set(thenable, returnFiber)));
                  returnFiber.has(root) ||
                    (returnFiber.add(root),
                    (sourceFiber = pingSuspendedRoot.bind(
                      null,
                      sourceFiber,
                      thenable,
                      root
                    )),
                    thenable.then(sourceFiber, sourceFiber));
                  value.effectTag |= 4096;
                  value.expirationTime = renderExpirationTime$jscomp$0;
                  break a;
                }
                value = value.return;
              } while (null !== value);
              value = Error(
                (getComponentName(sourceFiber.type) || "A React component") +
                  " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." +
                  getStackByFiberInDevAndProd(sourceFiber)
              );
            }
            workInProgressRootExitStatus !== RootCompleted &&
              (workInProgressRootExitStatus = RootErrored);
            value = createCapturedValue(value, sourceFiber);
            sourceFiber = returnFiber;
            do {
              switch (sourceFiber.tag) {
                case 3:
                  sourceFiber.effectTag |= 4096;
                  sourceFiber.expirationTime = renderExpirationTime$jscomp$0;
                  renderExpirationTime$jscomp$0 = createRootErrorUpdate(
                    sourceFiber,
                    value,
                    renderExpirationTime$jscomp$0
                  );
                  enqueueCapturedUpdate(
                    sourceFiber,
                    renderExpirationTime$jscomp$0
                  );
                  break a;
                case 1:
                  if (
                    ((thenable = value),
                    (root = sourceFiber.type),
                    (returnFiber = sourceFiber.stateNode),
                    0 === (sourceFiber.effectTag & 64) &&
                      ("function" === typeof root.getDerivedStateFromError ||
                        (null !== returnFiber &&
                          "function" === typeof returnFiber.componentDidCatch &&
                          (null === legacyErrorBoundariesThatAlreadyFailed ||
                            !legacyErrorBoundariesThatAlreadyFailed.has(
                              returnFiber
                            )))))
                  ) {
                    sourceFiber.effectTag |= 4096;
                    sourceFiber.expirationTime = renderExpirationTime$jscomp$0;
                    renderExpirationTime$jscomp$0 = createClassErrorUpdate(
                      sourceFiber,
                      thenable,
                      renderExpirationTime$jscomp$0
                    );
                    enqueueCapturedUpdate(
                      sourceFiber,
                      renderExpirationTime$jscomp$0
                    );
                    break a;
                  }
              }
              sourceFiber = sourceFiber.return;
            } while (null !== sourceFiber);
          }
          workInProgress = completeUnitOfWork(currentTime);
        }
      while (1);
      executionContext = lastPendingTime;
      resetContextDependencies();
      ReactCurrentDispatcher.current = prevDispatcher;
      if (null !== workInProgress)
        return renderRoot.bind(null, root$jscomp$0, expirationTime);
    }
    root$jscomp$0.finishedWork = root$jscomp$0.current.alternate;
    root$jscomp$0.finishedExpirationTime = expirationTime;
    if (resolveLocksOnRoot(root$jscomp$0, expirationTime)) return null;
    workInProgressRoot = null;
    switch (workInProgressRootExitStatus) {
      case RootIncomplete:
        throw ReactErrorProd(Error(328));
      case RootErrored:
        return (
          (lastPendingTime = root$jscomp$0.lastPendingTime),
          lastPendingTime < expirationTime
            ? renderRoot.bind(null, root$jscomp$0, lastPendingTime)
            : isSync
              ? commitRoot.bind(null, root$jscomp$0)
              : (prepareFreshStack(root$jscomp$0, expirationTime),
                scheduleSyncCallback(
                  renderRoot.bind(null, root$jscomp$0, expirationTime)
                ),
                null)
        );
      case RootSuspended:
        if (
          1073741823 === workInProgressRootLatestProcessedExpirationTime &&
          !isSync &&
          ((isSync =
            globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now()),
          10 < isSync)
        ) {
          if (workInProgressRootHasPendingPing)
            return (
              prepareFreshStack(root$jscomp$0, expirationTime),
              renderRoot.bind(null, root$jscomp$0, expirationTime)
            );
          lastPendingTime = root$jscomp$0.lastPendingTime;
          if (lastPendingTime < expirationTime)
            return renderRoot.bind(null, root$jscomp$0, lastPendingTime);
          root$jscomp$0.timeoutHandle = scheduleTimeout(
            commitRoot.bind(null, root$jscomp$0),
            isSync
          );
          return null;
        }
        return commitRoot.bind(null, root$jscomp$0);
      case RootSuspendedWithDelay:
        if (!isSync) {
          if (workInProgressRootHasPendingPing)
            return (
              prepareFreshStack(root$jscomp$0, expirationTime),
              renderRoot.bind(null, root$jscomp$0, expirationTime)
            );
          isSync = root$jscomp$0.lastPendingTime;
          if (isSync < expirationTime)
            return renderRoot.bind(null, root$jscomp$0, isSync);
          1073741823 !== workInProgressRootLatestSuspenseTimeout
            ? (isSync =
                10 * (1073741821 - workInProgressRootLatestSuspenseTimeout) -
                now())
            : 1073741823 === workInProgressRootLatestProcessedExpirationTime
              ? (isSync = 0)
              : ((isSync =
                  10 *
                    (1073741821 -
                      workInProgressRootLatestProcessedExpirationTime) -
                  5e3),
                (lastPendingTime = now()),
                (expirationTime =
                  10 * (1073741821 - expirationTime) - lastPendingTime),
                (isSync = lastPendingTime - isSync),
                0 > isSync && (isSync = 0),
                (isSync =
                  (120 > isSync
                    ? 120
                    : 480 > isSync
                      ? 480
                      : 1080 > isSync
                        ? 1080
                        : 1920 > isSync
                          ? 1920
                          : 3e3 > isSync
                            ? 3e3
                            : 4320 > isSync
                              ? 4320
                              : 1960 * ceil(isSync / 1960)) - isSync),
                expirationTime < isSync && (isSync = expirationTime));
          if (10 < isSync)
            return (
              (root$jscomp$0.timeoutHandle = scheduleTimeout(
                commitRoot.bind(null, root$jscomp$0),
                isSync
              )),
              null
            );
        }
        return commitRoot.bind(null, root$jscomp$0);
      case RootCompleted:
        return !isSync &&
          1073741823 !== workInProgressRootLatestProcessedExpirationTime &&
          null !== workInProgressRootCanSuspendUsingConfig &&
          ((lastPendingTime = workInProgressRootLatestProcessedExpirationTime),
          (prevDispatcher = workInProgressRootCanSuspendUsingConfig),
          (expirationTime = prevDispatcher.busyMinDurationMs | 0),
          0 >= expirationTime
            ? (expirationTime = 0)
            : ((isSync = prevDispatcher.busyDelayMs | 0),
              (lastPendingTime =
                now() -
                (10 * (1073741821 - lastPendingTime) -
                  (prevDispatcher.timeoutMs | 0 || 5e3))),
              (expirationTime =
                lastPendingTime <= isSync
                  ? 0
                  : isSync + expirationTime - lastPendingTime)),
          10 < expirationTime)
          ? ((root$jscomp$0.timeoutHandle = scheduleTimeout(
              commitRoot.bind(null, root$jscomp$0),
              expirationTime
            )),
            null)
          : commitRoot.bind(null, root$jscomp$0);
      default:
        throw ReactErrorProd(Error(329));
    }
  }
  function markRenderEventTimeAndConfig(expirationTime, suspenseConfig) {
    expirationTime < workInProgressRootLatestProcessedExpirationTime &&
      1 < expirationTime &&
      (workInProgressRootLatestProcessedExpirationTime = expirationTime);
    null !== suspenseConfig &&
      expirationTime < workInProgressRootLatestSuspenseTimeout &&
      1 < expirationTime &&
      ((workInProgressRootLatestSuspenseTimeout = expirationTime),
      (workInProgressRootCanSuspendUsingConfig = suspenseConfig));
  }
  function performUnitOfWork(unitOfWork) {
    var next = beginWork$$1(
      unitOfWork.alternate,
      unitOfWork,
      renderExpirationTime
    );
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next && (next = completeUnitOfWork(unitOfWork));
    ReactCurrentOwner$1.current = null;
    return next;
  }
  function completeUnitOfWork(unitOfWork) {
    workInProgress = unitOfWork;
    do {
      var current$jscomp$0 = workInProgress.alternate;
      unitOfWork = workInProgress.return;
      if (0 === (workInProgress.effectTag & 2048)) {
        a: {
          var instance = void 0;
          var _instance5 = current$jscomp$0;
          current$jscomp$0 = workInProgress;
          var renderExpirationTime$jscomp$0 = renderExpirationTime,
            newProps = current$jscomp$0.pendingProps;
          switch (current$jscomp$0.tag) {
            case 2:
              break;
            case 16:
              break;
            case 15:
            case 0:
              break;
            case 1:
              isContextProvider(current$jscomp$0.type) &&
                popContext(current$jscomp$0);
              break;
            case 3:
              popHostContainer(current$jscomp$0);
              popTopLevelContextObject(current$jscomp$0);
              _instance5 = current$jscomp$0.stateNode;
              _instance5.pendingContext &&
                ((_instance5.context = _instance5.pendingContext),
                (_instance5.pendingContext = null));
              updateHostContainer(current$jscomp$0);
              break;
            case 5:
              popHostContext(current$jscomp$0);
              renderExpirationTime$jscomp$0 = requiredContext(
                rootInstanceStackCursor.current
              );
              var type = current$jscomp$0.type;
              if (null !== _instance5 && null != current$jscomp$0.stateNode)
                updateHostComponent$1(
                  _instance5,
                  current$jscomp$0,
                  type,
                  newProps,
                  renderExpirationTime$jscomp$0
                ),
                  _instance5.ref !== current$jscomp$0.ref &&
                    (current$jscomp$0.effectTag |= 128);
              else if (newProps) {
                requiredContext(contextStackCursor$1.current);
                switch (type) {
                  case TYPES.CLIPPING_RECTANGLE:
                    instance = current.ClippingRectangle();
                    instance._applyProps = applyClippingRectangleProps;
                    break;
                  case TYPES.GROUP:
                    instance = current.Group();
                    instance._applyProps = applyGroupProps;
                    break;
                  case TYPES.SHAPE:
                    instance = current.Shape();
                    instance._applyProps = applyShapeProps;
                    break;
                  case TYPES.TEXT:
                    (instance = current.Text(
                      newProps.children,
                      newProps.font,
                      newProps.alignment,
                      newProps.path
                    )),
                      (instance._applyProps = applyTextProps);
                }
                if (!instance) throw ReactErrorProd(Error(217), type);
                instance._applyProps(instance, newProps);
                _instance5 = instance;
                appendAllChildren(_instance5, current$jscomp$0, !1, !1);
                current$jscomp$0.stateNode = _instance5;
                null !== current$jscomp$0.ref &&
                  (current$jscomp$0.effectTag |= 128);
              } else if (null === current$jscomp$0.stateNode)
                throw ReactErrorProd(Error(166));
              break;
            case 6:
              if (_instance5 && null != current$jscomp$0.stateNode)
                updateHostText$1(
                  _instance5,
                  current$jscomp$0,
                  _instance5.memoizedProps,
                  newProps
                );
              else {
                if (
                  "string" !== typeof newProps &&
                  null === current$jscomp$0.stateNode
                )
                  throw ReactErrorProd(Error(166));
                requiredContext(rootInstanceStackCursor.current);
                requiredContext(contextStackCursor$1.current);
                current$jscomp$0.stateNode = newProps;
              }
              break;
            case 11:
              break;
            case 13:
              pop(suspenseStackCursor, current$jscomp$0);
              instance = current$jscomp$0.memoizedState;
              if (0 !== (current$jscomp$0.effectTag & 64)) {
                current$jscomp$0.expirationTime = renderExpirationTime$jscomp$0;
                break a;
              }
              renderExpirationTime$jscomp$0 = null !== instance;
              instance = !1;
              null !== _instance5 &&
                ((newProps = _instance5.memoizedState),
                (instance = null !== newProps),
                renderExpirationTime$jscomp$0 ||
                  null === newProps ||
                  ((newProps = _instance5.child.sibling),
                  null !== newProps &&
                    ((type = current$jscomp$0.firstEffect),
                    null !== type
                      ? ((current$jscomp$0.firstEffect = newProps),
                        (newProps.nextEffect = type))
                      : ((current$jscomp$0.firstEffect = current$jscomp$0.lastEffect = newProps),
                        (newProps.nextEffect = null)),
                    (newProps.effectTag = 8))));
              if (
                renderExpirationTime$jscomp$0 &&
                !instance &&
                0 !== (current$jscomp$0.mode & 2)
              )
                if (
                  (null === _instance5 &&
                    !0 !==
                      current$jscomp$0.memoizedProps
                        .unstable_avoidThisFallback) ||
                  0 !== (suspenseStackCursor.current & 1)
                )
                  workInProgressRootExitStatus === RootIncomplete &&
                    (workInProgressRootExitStatus = RootSuspended);
                else if (
                  workInProgressRootExitStatus === RootIncomplete ||
                  workInProgressRootExitStatus === RootSuspended
                )
                  workInProgressRootExitStatus = RootSuspendedWithDelay;
              if (renderExpirationTime$jscomp$0 || instance)
                current$jscomp$0.effectTag |= 4;
              break;
            case 7:
              break;
            case 8:
              break;
            case 12:
              break;
            case 4:
              popHostContainer(current$jscomp$0);
              updateHostContainer(current$jscomp$0);
              break;
            case 10:
              popProvider(current$jscomp$0);
              break;
            case 9:
              break;
            case 14:
              break;
            case 17:
              isContextProvider(current$jscomp$0.type) &&
                popContext(current$jscomp$0);
              break;
            case 19:
              pop(suspenseStackCursor, current$jscomp$0);
              instance = current$jscomp$0.memoizedState;
              if (null === instance) break;
              newProps = 0 !== (current$jscomp$0.effectTag & 64);
              type = instance.rendering;
              if (null === type)
                if (newProps) cutOffTailIfNeeded(instance, !1);
                else {
                  if (
                    workInProgressRootExitStatus !== RootIncomplete ||
                    (null !== _instance5 && 0 !== (_instance5.effectTag & 64))
                  )
                    for (
                      _instance5 = current$jscomp$0.child;
                      null !== _instance5;

                    ) {
                      type = findFirstSuspended(_instance5);
                      if (null !== type) {
                        current$jscomp$0.effectTag |= 64;
                        cutOffTailIfNeeded(instance, !1);
                        _instance5 = type.updateQueue;
                        null !== _instance5 &&
                          ((current$jscomp$0.updateQueue = _instance5),
                          (current$jscomp$0.effectTag |= 4));
                        current$jscomp$0.firstEffect = current$jscomp$0.lastEffect = null;
                        _instance5 = renderExpirationTime$jscomp$0;
                        for (
                          renderExpirationTime$jscomp$0 =
                            current$jscomp$0.child;
                          null !== renderExpirationTime$jscomp$0;

                        )
                          (instance = renderExpirationTime$jscomp$0),
                            (newProps = _instance5),
                            (instance.effectTag &= 2),
                            (instance.nextEffect = null),
                            (instance.firstEffect = null),
                            (instance.lastEffect = null),
                            (type = instance.alternate),
                            null === type
                              ? ((instance.childExpirationTime = 0),
                                (instance.expirationTime = newProps),
                                (instance.child = null),
                                (instance.memoizedProps = null),
                                (instance.memoizedState = null),
                                (instance.updateQueue = null),
                                (instance.dependencies = null))
                              : ((instance.childExpirationTime =
                                  type.childExpirationTime),
                                (instance.expirationTime = type.expirationTime),
                                (instance.child = type.child),
                                (instance.memoizedProps = type.memoizedProps),
                                (instance.memoizedState = type.memoizedState),
                                (instance.updateQueue = type.updateQueue),
                                (newProps = type.dependencies),
                                (instance.dependencies =
                                  null === newProps
                                    ? null
                                    : {
                                        expirationTime: newProps.expirationTime,
                                        firstContext: newProps.firstContext,
                                        responders: newProps.responders
                                      })),
                            (renderExpirationTime$jscomp$0 =
                              renderExpirationTime$jscomp$0.sibling);
                        push(
                          suspenseStackCursor,
                          (suspenseStackCursor.current & 1) | 2,
                          current$jscomp$0
                        );
                        current$jscomp$0 = current$jscomp$0.child;
                        break a;
                      }
                      _instance5 = _instance5.sibling;
                    }
                }
              else {
                if (!newProps)
                  if (
                    ((_instance5 = findFirstSuspended(type)),
                    null !== _instance5)
                  ) {
                    if (
                      ((current$jscomp$0.effectTag |= 64),
                      (newProps = !0),
                      cutOffTailIfNeeded(instance, !0),
                      null === instance.tail && "hidden" === instance.tailMode)
                    ) {
                      _instance5 = _instance5.updateQueue;
                      null !== _instance5 &&
                        ((current$jscomp$0.updateQueue = _instance5),
                        (current$jscomp$0.effectTag |= 4));
                      current$jscomp$0 = current$jscomp$0.lastEffect =
                        instance.lastEffect;
                      null !== current$jscomp$0 &&
                        (current$jscomp$0.nextEffect = null);
                      break;
                    }
                  } else
                    now() > instance.tailExpiration &&
                      1 < renderExpirationTime$jscomp$0 &&
                      ((current$jscomp$0.effectTag |= 64),
                      (newProps = !0),
                      cutOffTailIfNeeded(instance, !1),
                      (current$jscomp$0.expirationTime = current$jscomp$0.childExpirationTime =
                        renderExpirationTime$jscomp$0 - 1));
                instance.isBackwards
                  ? ((type.sibling = current$jscomp$0.child),
                    (current$jscomp$0.child = type))
                  : ((_instance5 = instance.last),
                    null !== _instance5
                      ? (_instance5.sibling = type)
                      : (current$jscomp$0.child = type),
                    (instance.last = type));
              }
              if (null !== instance.tail) {
                0 === instance.tailExpiration &&
                  (instance.tailExpiration = now() + 500);
                _instance5 = instance.tail;
                instance.rendering = _instance5;
                instance.tail = _instance5.sibling;
                instance.lastEffect = current$jscomp$0.lastEffect;
                _instance5.sibling = null;
                renderExpirationTime$jscomp$0 = suspenseStackCursor.current;
                renderExpirationTime$jscomp$0 = newProps
                  ? (renderExpirationTime$jscomp$0 & 1) | 2
                  : renderExpirationTime$jscomp$0 & 1;
                push(
                  suspenseStackCursor,
                  renderExpirationTime$jscomp$0,
                  current$jscomp$0
                );
                current$jscomp$0 = _instance5;
                break a;
              }
              break;
            case 20:
              break;
            default:
              throw ReactErrorProd(Error(156));
          }
          current$jscomp$0 = null;
        }
        _instance5 = workInProgress;
        if (
          1 === renderExpirationTime ||
          1 !== _instance5.childExpirationTime
        ) {
          renderExpirationTime$jscomp$0 = 0;
          for (instance = _instance5.child; null !== instance; )
            (newProps = instance.expirationTime),
              (type = instance.childExpirationTime),
              newProps > renderExpirationTime$jscomp$0 &&
                (renderExpirationTime$jscomp$0 = newProps),
              type > renderExpirationTime$jscomp$0 &&
                (renderExpirationTime$jscomp$0 = type),
              (instance = instance.sibling);
          _instance5.childExpirationTime = renderExpirationTime$jscomp$0;
        }
        if (null !== current$jscomp$0) return current$jscomp$0;
        null !== unitOfWork &&
          0 === (unitOfWork.effectTag & 2048) &&
          (null === unitOfWork.firstEffect &&
            (unitOfWork.firstEffect = workInProgress.firstEffect),
          null !== workInProgress.lastEffect &&
            (null !== unitOfWork.lastEffect &&
              (unitOfWork.lastEffect.nextEffect = workInProgress.firstEffect),
            (unitOfWork.lastEffect = workInProgress.lastEffect)),
          1 < workInProgress.effectTag &&
            (null !== unitOfWork.lastEffect
              ? (unitOfWork.lastEffect.nextEffect = workInProgress)
              : (unitOfWork.firstEffect = workInProgress),
            (unitOfWork.lastEffect = workInProgress)));
      } else {
        current$jscomp$0 = unwindWork(workInProgress, renderExpirationTime);
        if (null !== current$jscomp$0)
          return (current$jscomp$0.effectTag &= 2047), current$jscomp$0;
        null !== unitOfWork &&
          ((unitOfWork.firstEffect = unitOfWork.lastEffect = null),
          (unitOfWork.effectTag |= 2048));
      }
      current$jscomp$0 = workInProgress.sibling;
      if (null !== current$jscomp$0) return current$jscomp$0;
      workInProgress = unitOfWork;
    } while (null !== workInProgress);
    workInProgressRootExitStatus === RootIncomplete &&
      (workInProgressRootExitStatus = RootCompleted);
    return null;
  }
  function commitRoot(root) {
    var renderPriorityLevel = getCurrentPriorityLevel();
    runWithPriority(99, commitRootImpl.bind(null, root, renderPriorityLevel));
    null !== rootWithPendingPassiveEffects &&
      scheduleCallback(97, function() {
        flushPassiveEffects();
        return null;
      });
    return null;
  }
  function commitRootImpl(root, renderPriorityLevel) {
    flushPassiveEffects();
    if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
      throw ReactErrorProd(Error(327));
    var finishedWork = root.finishedWork,
      expirationTime = root.finishedExpirationTime;
    if (null === finishedWork) return null;
    root.finishedWork = null;
    root.finishedExpirationTime = 0;
    if (finishedWork === root.current) throw ReactErrorProd(Error(177));
    root.callbackNode = null;
    root.callbackExpirationTime = 0;
    var updateExpirationTimeBeforeCommit = finishedWork.expirationTime,
      childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;
    updateExpirationTimeBeforeCommit =
      childExpirationTimeBeforeCommit > updateExpirationTimeBeforeCommit
        ? childExpirationTimeBeforeCommit
        : updateExpirationTimeBeforeCommit;
    root.firstPendingTime = updateExpirationTimeBeforeCommit;
    updateExpirationTimeBeforeCommit < root.lastPendingTime &&
      (root.lastPendingTime = updateExpirationTimeBeforeCommit);
    root === workInProgressRoot &&
      ((workInProgress = workInProgressRoot = null),
      (renderExpirationTime = 0));
    1 < finishedWork.effectTag
      ? null !== finishedWork.lastEffect
        ? ((finishedWork.lastEffect.nextEffect = finishedWork),
          (updateExpirationTimeBeforeCommit = finishedWork.firstEffect))
        : (updateExpirationTimeBeforeCommit = finishedWork)
      : (updateExpirationTimeBeforeCommit = finishedWork.firstEffect);
    if (null !== updateExpirationTimeBeforeCommit) {
      childExpirationTimeBeforeCommit = executionContext;
      executionContext |= CommitContext;
      ReactCurrentOwner$1.current = null;
      nextEffect = updateExpirationTimeBeforeCommit;
      do
        try {
          for (; null !== nextEffect; ) {
            if (0 !== (nextEffect.effectTag & 256)) {
              var current = nextEffect.alternate,
                finishedWork$jscomp$0 = nextEffect;
              switch (finishedWork$jscomp$0.tag) {
                case 0:
                case 11:
                case 15:
                  commitHookEffectList(2, 0, finishedWork$jscomp$0);
                  break;
                case 1:
                  if (
                    finishedWork$jscomp$0.effectTag & 256 &&
                    null !== current
                  ) {
                    var prevProps = current.memoizedProps,
                      prevState = current.memoizedState,
                      instance = finishedWork$jscomp$0.stateNode,
                      snapshot = instance.getSnapshotBeforeUpdate(
                        finishedWork$jscomp$0.elementType ===
                        finishedWork$jscomp$0.type
                          ? prevProps
                          : resolveDefaultProps(
                              finishedWork$jscomp$0.type,
                              prevProps
                            ),
                        prevState
                      );
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                case 3:
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw ReactErrorProd(Error(163));
              }
            }
            nextEffect = nextEffect.nextEffect;
          }
        } catch (error) {
          if (null === nextEffect) throw ReactErrorProd(Error(330));
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      while (null !== nextEffect);
      nextEffect = updateExpirationTimeBeforeCommit;
      do
        try {
          for (
            current = root, prevProps = renderPriorityLevel;
            null !== nextEffect;

          ) {
            var effectTag = nextEffect.effectTag;
            if (effectTag & 128) {
              var current$jscomp$0 = nextEffect.alternate;
              if (null !== current$jscomp$0) {
                var currentRef = current$jscomp$0.ref;
                null !== currentRef &&
                  ("function" === typeof currentRef
                    ? currentRef(null)
                    : (currentRef.current = null));
              }
            }
            switch (effectTag & 1038) {
              case 2:
                commitPlacement(nextEffect);
                nextEffect.effectTag &= -3;
                break;
              case 6:
                commitPlacement(nextEffect);
                nextEffect.effectTag &= -3;
                commitWork(nextEffect.alternate, nextEffect);
                break;
              case 1024:
                nextEffect.effectTag &= -1025;
                break;
              case 1028:
                nextEffect.effectTag &= -1025;
                commitWork(nextEffect.alternate, nextEffect);
                break;
              case 4:
                commitWork(nextEffect.alternate, nextEffect);
                break;
              case 8:
                prevState = nextEffect;
                unmountHostComponents(current, prevState, prevProps);
                prevState.return = null;
                prevState.child = null;
                prevState.memoizedState = null;
                prevState.updateQueue = null;
                prevState.dependencies = null;
                var alternate = prevState.alternate;
                null !== alternate &&
                  ((alternate.return = null),
                  (alternate.child = null),
                  (alternate.memoizedState = null),
                  (alternate.updateQueue = null),
                  (alternate.dependencies = null));
            }
            nextEffect = nextEffect.nextEffect;
          }
        } catch (error) {
          if (null === nextEffect) throw ReactErrorProd(Error(330));
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      while (null !== nextEffect);
      root.current = finishedWork;
      nextEffect = updateExpirationTimeBeforeCommit;
      do
        try {
          for (effectTag = expirationTime; null !== nextEffect; ) {
            var effectTag$jscomp$0 = nextEffect.effectTag;
            if (effectTag$jscomp$0 & 36) {
              var current$jscomp$1 = nextEffect.alternate;
              current$jscomp$0 = nextEffect;
              currentRef = effectTag;
              switch (current$jscomp$0.tag) {
                case 0:
                case 11:
                case 15:
                  commitHookEffectList(16, 32, current$jscomp$0);
                  break;
                case 1:
                  var instance$jscomp$0 = current$jscomp$0.stateNode;
                  if (current$jscomp$0.effectTag & 4)
                    if (null === current$jscomp$1)
                      instance$jscomp$0.componentDidMount();
                    else {
                      var prevProps$jscomp$0 =
                        current$jscomp$0.elementType === current$jscomp$0.type
                          ? current$jscomp$1.memoizedProps
                          : resolveDefaultProps(
                              current$jscomp$0.type,
                              current$jscomp$1.memoizedProps
                            );
                      instance$jscomp$0.componentDidUpdate(
                        prevProps$jscomp$0,
                        current$jscomp$1.memoizedState,
                        instance$jscomp$0.__reactInternalSnapshotBeforeUpdate
                      );
                    }
                  var updateQueue = current$jscomp$0.updateQueue;
                  null !== updateQueue &&
                    commitUpdateQueue(
                      current$jscomp$0,
                      updateQueue,
                      instance$jscomp$0,
                      currentRef
                    );
                  break;
                case 3:
                  var _updateQueue = current$jscomp$0.updateQueue;
                  if (null !== _updateQueue) {
                    alternate = null;
                    if (null !== current$jscomp$0.child)
                      switch (current$jscomp$0.child.tag) {
                        case 5:
                          alternate = current$jscomp$0.child.stateNode;
                          break;
                        case 1:
                          alternate = current$jscomp$0.child.stateNode;
                      }
                    commitUpdateQueue(
                      current$jscomp$0,
                      _updateQueue,
                      alternate,
                      currentRef
                    );
                  }
                  break;
                case 5:
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  break;
                case 19:
                case 17:
                case 20:
                  break;
                default:
                  throw ReactErrorProd(Error(163));
              }
            }
            if (effectTag$jscomp$0 & 128) {
              var ref = nextEffect.ref;
              if (null !== ref) {
                var instance$jscomp$1 = nextEffect.stateNode;
                switch (nextEffect.tag) {
                  case 5:
                    var instanceToUse = instance$jscomp$1;
                    break;
                  default:
                    instanceToUse = instance$jscomp$1;
                }
                "function" === typeof ref
                  ? ref(instanceToUse)
                  : (ref.current = instanceToUse);
              }
            }
            effectTag$jscomp$0 & 512 && (rootDoesHavePassiveEffects = !0);
            nextEffect = nextEffect.nextEffect;
          }
        } catch (error) {
          if (null === nextEffect) throw ReactErrorProd(Error(330));
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      while (null !== nextEffect);
      nextEffect = null;
      requestPaint();
      executionContext = childExpirationTimeBeforeCommit;
    } else root.current = finishedWork;
    if (rootDoesHavePassiveEffects)
      (rootDoesHavePassiveEffects = !1),
        (rootWithPendingPassiveEffects = root),
        (pendingPassiveEffectsExpirationTime = expirationTime),
        (pendingPassiveEffectsRenderPriority = renderPriorityLevel);
    else
      for (nextEffect = updateExpirationTimeBeforeCommit; null !== nextEffect; )
        (renderPriorityLevel = nextEffect.nextEffect),
          (nextEffect.nextEffect = null),
          (nextEffect = renderPriorityLevel);
    renderPriorityLevel = root.firstPendingTime;
    0 !== renderPriorityLevel
      ? ((effectTag$jscomp$0 = requestCurrentTime()),
        (effectTag$jscomp$0 = inferPriorityFromExpirationTime(
          effectTag$jscomp$0,
          renderPriorityLevel
        )),
        scheduleCallbackForRoot(root, effectTag$jscomp$0, renderPriorityLevel))
      : (legacyErrorBoundariesThatAlreadyFailed = null);
    "function" === typeof onCommitFiberRoot &&
      onCommitFiberRoot(finishedWork.stateNode, expirationTime);
    1073741823 === renderPriorityLevel
      ? root === rootWithNestedUpdates
        ? nestedUpdateCount++
        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
      : (nestedUpdateCount = 0);
    if (hasUncaughtError)
      throw ((hasUncaughtError = !1),
      (root = firstUncaughtError),
      (firstUncaughtError = null),
      root);
    if ((executionContext & LegacyUnbatchedContext) !== NoContext) return null;
    flushSyncCallbackQueue();
    return null;
  }
  function flushPassiveEffects() {
    if (null === rootWithPendingPassiveEffects) return !1;
    var root = rootWithPendingPassiveEffects,
      expirationTime = pendingPassiveEffectsExpirationTime,
      renderPriorityLevel = pendingPassiveEffectsRenderPriority;
    rootWithPendingPassiveEffects = null;
    pendingPassiveEffectsExpirationTime = 0;
    pendingPassiveEffectsRenderPriority = 90;
    return runWithPriority(
      97 < renderPriorityLevel ? 97 : renderPriorityLevel,
      flushPassiveEffectsImpl.bind(null, root, expirationTime)
    );
  }
  function flushPassiveEffectsImpl(root, expirationTime) {
    if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
      throw ReactErrorProd(Error(331));
    expirationTime = executionContext;
    executionContext |= CommitContext;
    for (root = root.current.firstEffect; null !== root; ) {
      try {
        var finishedWork = root;
        if (0 !== (finishedWork.effectTag & 512))
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectList(128, 0, finishedWork),
                commitHookEffectList(0, 64, finishedWork);
          }
      } catch (error) {
        if (null === root) throw ReactErrorProd(Error(330));
        captureCommitPhaseError(root, error);
      }
      finishedWork = root.nextEffect;
      root.nextEffect = null;
      root = finishedWork;
    }
    executionContext = expirationTime;
    flushSyncCallbackQueue();
    return !0;
  }
  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValue(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 1073741823);
    enqueueUpdate(rootFiber, sourceFiber);
    rootFiber = markUpdateTimeFromFiberToRoot(rootFiber, 1073741823);
    null !== rootFiber && scheduleCallbackForRoot(rootFiber, 99, 1073741823);
  }
  function captureCommitPhaseError(sourceFiber, error) {
    if (3 === sourceFiber.tag)
      captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    else
      for (var fiber = sourceFiber.return; null !== fiber; ) {
        if (3 === fiber.tag) {
          captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
          break;
        } else if (1 === fiber.tag) {
          var instance = fiber.stateNode;
          if (
            "function" === typeof fiber.type.getDerivedStateFromError ||
            ("function" === typeof instance.componentDidCatch &&
              (null === legacyErrorBoundariesThatAlreadyFailed ||
                !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
          ) {
            sourceFiber = createCapturedValue(error, sourceFiber);
            sourceFiber = createClassErrorUpdate(
              fiber,
              sourceFiber,
              1073741823
            );
            enqueueUpdate(fiber, sourceFiber);
            fiber = markUpdateTimeFromFiberToRoot(fiber, 1073741823);
            null !== fiber && scheduleCallbackForRoot(fiber, 99, 1073741823);
            break;
          }
        }
        fiber = fiber.return;
      }
  }
  function pingSuspendedRoot(root, thenable, suspendedTime) {
    var pingCache = root.pingCache;
    null !== pingCache && pingCache.delete(thenable);
    workInProgressRoot === root && renderExpirationTime === suspendedTime
      ? workInProgressRootExitStatus === RootSuspendedWithDelay ||
        (workInProgressRootExitStatus === RootSuspended &&
          1073741823 === workInProgressRootLatestProcessedExpirationTime &&
          now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS)
        ? prepareFreshStack(root, renderExpirationTime)
        : (workInProgressRootHasPendingPing = !0)
      : root.lastPendingTime < suspendedTime ||
        ((thenable = root.pingTime),
        (0 !== thenable && thenable < suspendedTime) ||
          ((root.pingTime = suspendedTime),
          root.finishedExpirationTime === suspendedTime &&
            ((root.finishedExpirationTime = 0), (root.finishedWork = null)),
          (thenable = requestCurrentTime()),
          (thenable = inferPriorityFromExpirationTime(thenable, suspendedTime)),
          scheduleCallbackForRoot(root, thenable, suspendedTime)));
  }
  function resolveRetryThenable(boundaryFiber, thenable) {
    var retryCache = boundaryFiber.stateNode;
    null !== retryCache && retryCache.delete(thenable);
    thenable = 1;
    retryCache = requestCurrentTime();
    1 === thenable &&
      (thenable = computeExpirationForFiber(retryCache, boundaryFiber, null));
    retryCache = inferPriorityFromExpirationTime(retryCache, thenable);
    boundaryFiber = markUpdateTimeFromFiberToRoot(boundaryFiber, thenable);
    null !== boundaryFiber &&
      scheduleCallbackForRoot(boundaryFiber, retryCache, thenable);
  }
  function injectInternals(internals) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled || !hook.supportsFiber) return !0;
    try {
      var rendererID = hook.inject(internals);
      onCommitFiberRoot = function(root, expirationTime) {
        try {
          hook.onCommitFiberRoot(
            rendererID,
            root,
            void 0,
            64 === (root.current.effectTag & 64)
          );
        } catch (err) {}
      };
      onCommitFiberUnmount = function(fiber) {
        try {
          hook.onCommitFiberUnmount(rendererID, fiber);
        } catch (err) {}
      };
    } catch (err) {}
    return !0;
  }
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childExpirationTime = this.expirationTime = 0;
    this.alternate = null;
  }
  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }
  function resolveLazyComponentTag(Component) {
    if ("function" === typeof Component)
      return shouldConstruct(Component) ? 1 : 0;
    if (void 0 !== Component && null !== Component) {
      Component = Component.$$typeof;
      if (Component === REACT_FORWARD_REF_TYPE) return 11;
      if (Component === REACT_MEMO_TYPE) return 14;
    }
    return 2;
  }
  function createWorkInProgress(current, pendingProps, expirationTime) {
    expirationTime = current.alternate;
    null === expirationTime
      ? ((expirationTime = createFiber(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        )),
        (expirationTime.elementType = current.elementType),
        (expirationTime.type = current.type),
        (expirationTime.stateNode = current.stateNode),
        (expirationTime.alternate = current),
        (current.alternate = expirationTime))
      : ((expirationTime.pendingProps = pendingProps),
        (expirationTime.effectTag = 0),
        (expirationTime.nextEffect = null),
        (expirationTime.firstEffect = null),
        (expirationTime.lastEffect = null));
    expirationTime.childExpirationTime = current.childExpirationTime;
    expirationTime.expirationTime = current.expirationTime;
    expirationTime.child = current.child;
    expirationTime.memoizedProps = current.memoizedProps;
    expirationTime.memoizedState = current.memoizedState;
    expirationTime.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    expirationTime.dependencies =
      null === pendingProps
        ? null
        : {
            expirationTime: pendingProps.expirationTime,
            firstContext: pendingProps.firstContext,
            responders: pendingProps.responders
          };
    expirationTime.sibling = current.sibling;
    expirationTime.index = current.index;
    expirationTime.ref = current.ref;
    return expirationTime;
  }
  function createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    expirationTime
  ) {
    var fiberTag = 2;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
    else if ("string" === typeof type) fiberTag = 5;
    else
      a: switch (type) {
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(
            pendingProps.children,
            mode,
            expirationTime,
            key
          );
        case REACT_CONCURRENT_MODE_TYPE:
          fiberTag = 8;
          mode |= 7;
          break;
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 8;
          mode |= 1;
          break;
        case REACT_PROFILER_TYPE:
          return (
            (type = createFiber(12, pendingProps, key, mode | 8)),
            (type.elementType = REACT_PROFILER_TYPE),
            (type.type = REACT_PROFILER_TYPE),
            (type.expirationTime = expirationTime),
            type
          );
        case REACT_SUSPENSE_TYPE:
          return (
            (type = createFiber(13, pendingProps, key, mode)),
            (type.type = REACT_SUSPENSE_TYPE),
            (type.elementType = REACT_SUSPENSE_TYPE),
            (type.expirationTime = expirationTime),
            type
          );
        case REACT_SUSPENSE_LIST_TYPE:
          return (
            (type = createFiber(19, pendingProps, key, mode)),
            (type.elementType = REACT_SUSPENSE_LIST_TYPE),
            (type.expirationTime = expirationTime),
            type
          );
        default:
          if ("object" === typeof type && null !== type)
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = 10;
                break a;
              case REACT_CONTEXT_TYPE:
                fiberTag = 9;
                break a;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = 11;
                break a;
              case REACT_MEMO_TYPE:
                fiberTag = 14;
                break a;
              case REACT_LAZY_TYPE:
                fiberTag = 16;
                owner = null;
                break a;
            }
          throw ReactErrorProd(
            Error(130),
            null == type ? type : typeof type,
            ""
          );
      }
    key = createFiber(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.expirationTime = expirationTime;
    return key;
  }
  function createFiberFromFragment(elements, mode, expirationTime, key) {
    elements = createFiber(7, elements, key, mode);
    elements.expirationTime = expirationTime;
    return elements;
  }
  function createFiberFromText(content, mode, expirationTime) {
    content = createFiber(6, content, null, mode);
    content.expirationTime = expirationTime;
    return content;
  }
  function createFiberFromPortal(portal, mode, expirationTime) {
    mode = createFiber(
      4,
      null !== portal.children ? portal.children : [],
      portal.key,
      mode
    );
    mode.expirationTime = expirationTime;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  function FiberRootNode(containerInfo, tag, hydrate) {
    this.tag = tag;
    this.current = null;
    this.containerInfo = containerInfo;
    this.pingCache = this.pendingChildren = null;
    this.finishedExpirationTime = 0;
    this.finishedWork = null;
    this.timeoutHandle = -1;
    this.pendingContext = this.context = null;
    this.hydrate = hydrate;
    this.callbackNode = this.firstBatch = null;
    this.pingTime = this.lastPendingTime = this.firstPendingTime = this.callbackExpirationTime = 0;
  }
  function updateContainer(element, container, parentComponent, callback) {
    var current$$1 = container.current,
      currentTime = requestCurrentTime(),
      suspenseConfig = ReactCurrentBatchConfig.suspense;
    current$$1 = computeExpirationForFiber(
      currentTime,
      current$$1,
      suspenseConfig
    );
    currentTime = container.current;
    a: if (parentComponent) {
      parentComponent = parentComponent._reactInternalFiber;
      b: {
        if (
          2 !== isFiberMountedImpl(parentComponent) ||
          1 !== parentComponent.tag
        )
          throw ReactErrorProd(Error(170));
        var parentContext = parentComponent;
        do {
          switch (parentContext.tag) {
            case 3:
              parentContext = parentContext.stateNode.context;
              break b;
            case 1:
              if (isContextProvider(parentContext.type)) {
                parentContext =
                  parentContext.stateNode
                    .__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          parentContext = parentContext.return;
        } while (null !== parentContext);
        throw ReactErrorProd(Error(171));
      }
      if (1 === parentComponent.tag) {
        var Component = parentComponent.type;
        if (isContextProvider(Component)) {
          parentComponent = processChildContext(
            parentComponent,
            Component,
            parentContext
          );
          break a;
        }
      }
      parentComponent = parentContext;
    } else parentComponent = emptyContextObject;
    null === container.context
      ? (container.context = parentComponent)
      : (container.pendingContext = parentComponent);
    container = callback;
    suspenseConfig = createUpdate(current$$1, suspenseConfig);
    suspenseConfig.payload = { element: element };
    container = void 0 === container ? null : container;
    null !== container && (suspenseConfig.callback = container);
    enqueueUpdate(currentTime, suspenseConfig);
    scheduleWork(currentTime, current$$1);
    return current$$1;
  }
  function elementFrom(node) {
    return node.toElement
      ? node.toElement()
      : node.getDOMNode
        ? node.getDOMNode()
        : node.getNode
          ? node.getNode()
          : node;
  }
  var _assign = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
    ReactSharedInternals =
      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher") ||
    (ReactSharedInternals.ReactCurrentDispatcher = { current: null });
  ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig") ||
    (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null });
  var hasSymbol = "function" === typeof Symbol && Symbol.for,
    REACT_ELEMENT_TYPE$1 = hasSymbol ? Symbol.for("react.element") : 60103,
    REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106,
    REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107,
    REACT_STRICT_MODE_TYPE = hasSymbol
      ? Symbol.for("react.strict_mode")
      : 60108,
    REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114,
    REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109,
    REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110,
    REACT_CONCURRENT_MODE_TYPE = hasSymbol
      ? Symbol.for("react.concurrent_mode")
      : 60111,
    REACT_FORWARD_REF_TYPE = hasSymbol
      ? Symbol.for("react.forward_ref")
      : 60112,
    REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113,
    REACT_SUSPENSE_LIST_TYPE = hasSymbol
      ? Symbol.for("react.suspense_list")
      : 60120,
    REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115,
    REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
  hasSymbol && Symbol.for("react.fundamental");
  hasSymbol && Symbol.for("react.responder");
  var MAYBE_ITERATOR_SYMBOL = "function" === typeof Symbol && Symbol.iterator,
    _class = function(mixins) {
      for (var proto = {}, i = 0, l = arguments.length; i < l; i++) {
        var mixin = arguments[i];
        "function" == typeof mixin && (mixin = mixin.prototype);
        for (var key in mixin) proto[key] = mixin[key];
      }
      proto.initialize || (proto.initialize = function() {});
      proto.constructor = function(a, b, c, d, e, f, g, h) {
        return new proto.initialize(a, b, c, d, e, f, g, h);
      };
      proto.constructor.prototype = proto.initialize.prototype = proto;
      return proto.constructor;
    },
    transform = _class({
      initialize: Transform,
      _transform: function() {},
      xx: 1,
      yx: 0,
      x: 0,
      xy: 0,
      yy: 1,
      y: 0,
      transform: function(xx, yx, xy, yy, x, y) {
        xx &&
          "object" == typeof xx &&
          ((yx = xx.yx),
          (yy = xx.yy),
          (y = xx.y),
          (xy = xx.xy),
          (x = xx.x),
          (xx = xx.xx));
        x || (x = 0);
        y || (y = 0);
        return this.transformTo(
          this.xx * xx + this.xy * yx,
          this.yx * xx + this.yy * yx,
          this.xx * xy + this.xy * yy,
          this.yx * xy + this.yy * yy,
          this.xx * x + this.xy * y + this.x,
          this.yx * x + this.yy * y + this.y
        );
      },
      transformTo: Transform,
      translate: function(x, y) {
        return this.transform(1, 0, 0, 1, x, y);
      },
      move: function(x, y) {
        this.x += x || 0;
        this.y += y || 0;
        this._transform();
        return this;
      },
      scale: function(x, y) {
        null == y && (y = x);
        return this.transform(x, 0, 0, y, 0, 0);
      },
      rotate: function(deg, x, y) {
        if (null == x || null == y)
          (x = (this.left || 0) + (this.width || 0) / 2),
            (y = (this.top || 0) + (this.height || 0) / 2);
        var rad = (deg * Math.PI) / 180;
        deg = Math.sin(rad);
        rad = Math.cos(rad);
        this.transform(1, 0, 0, 1, x, y);
        return this.transformTo(
          rad * this.xx - deg * this.yx,
          deg * this.xx + rad * this.yx,
          rad * this.xy - deg * this.yy,
          deg * this.xy + rad * this.yy,
          this.x,
          this.y
        ).transform(1, 0, 0, 1, -x, -y);
      },
      moveTo: function(x, y) {
        return this.transformTo(this.xx, this.yx, this.xy, this.yy, x, y);
      },
      rotateTo: function(deg, x, y) {
        var flip = this.yx / this.xx > this.yy / this.xy ? -1 : 1;
        if (0 > this.xx ? 0 <= this.xy : 0 > this.xy) flip = -flip;
        return this.rotate(
          deg - (180 * Math.atan2(flip * this.yx, flip * this.xx)) / Math.PI,
          x,
          y
        );
      },
      scaleTo: function(x, y) {
        var h = Math.sqrt(this.xx * this.xx + this.yx * this.yx);
        this.xx /= h;
        this.yx /= h;
        h = Math.sqrt(this.yy * this.yy + this.xy * this.xy);
        this.yy /= h;
        this.xy /= h;
        return this.scale(x, y);
      },
      resizeTo: function(width, height) {
        var w = this.width,
          h = this.height;
        return w && h ? this.scaleTo(width / w, height / h) : this;
      },
      inversePoint: function(x, y) {
        var a = this.xx,
          b = this.yx,
          c = this.xy,
          d = this.yy,
          e = this.x,
          f = this.y,
          det = b * c - a * d;
        return 0 == det
          ? null
          : {
              x: (d * (e - x) + c * (y - f)) / det,
              y: (a * (f - y) + b * (x - e)) / det
            };
      },
      point: function(x, y) {
        return {
          x: this.xx * x + this.xy * y + this.x,
          y: this.yx * x + this.yy * y + this.y
        };
      }
    }),
    commonjsGlobal =
      "undefined" !== typeof window
        ? window
        : "undefined" !== typeof global
          ? global
          : "undefined" !== typeof self
            ? self
            : {},
    current = createCommonjsModule(function(module, exports) {
      function warning() {
        throw Error("You must require a mode before requiring anything else.");
      }
      exports.Surface = warning;
      exports.Path = warning;
      exports.Shape = warning;
      exports.Group = warning;
      exports.ClippingRectangle = warning;
      exports.Text = warning;
      exports.setCurrent = function(mode) {
        for (var key in mode) exports[key] = mode[key];
      };
    }),
    TYPES = {
      CLIPPING_RECTANGLE: "ClippingRectangle",
      GROUP: "Group",
      SHAPE: "Shape",
      TEXT: "Text"
    },
    EVENT_TYPES = {
      onClick: "click",
      onMouseMove: "mousemove",
      onMouseOver: "mouseover",
      onMouseOut: "mouseout",
      onMouseUp: "mouseup",
      onMouseDown: "mousedown"
    },
    canHydrateInstance = shim$1,
    canHydrateTextInstance = shim$1,
    isSuspenseInstancePending = shim$1,
    isSuspenseInstanceFallback = shim$1,
    getNextHydratableSibling = shim$1,
    getFirstHydratableChild = shim$1,
    pooledTransform = new transform(),
    NO_CONTEXT = {},
    UPDATE_SIGNAL = {},
    scheduleTimeout = setTimeout,
    cancelTimeout = clearTimeout,
    BEFORE_SLASH_RE = /^(.*)[\\\/]/;
  new Set();
  var valueStack = [],
    index = -1,
    emptyContextObject = {},
    contextStackCursor = { current: emptyContextObject },
    didPerformWorkStackCursor = { current: !1 },
    previousContext = emptyContextObject,
    _ReactInternals$Sched =
      React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,
    unstable_now = _ReactInternals$Sched.unstable_now,
    Scheduler_runWithPriority = _ReactInternals$Sched.unstable_runWithPriority,
    Scheduler_scheduleCallback =
      _ReactInternals$Sched.unstable_scheduleCallback,
    Scheduler_cancelCallback = _ReactInternals$Sched.unstable_cancelCallback,
    Scheduler_requestPaint = _ReactInternals$Sched.unstable_requestPaint,
    Scheduler_getCurrentPriorityLevel =
      _ReactInternals$Sched.unstable_getCurrentPriorityLevel,
    Scheduler_ImmediatePriority =
      _ReactInternals$Sched.unstable_ImmediatePriority,
    Scheduler_UserBlockingPriority =
      _ReactInternals$Sched.unstable_UserBlockingPriority,
    Scheduler_NormalPriority = _ReactInternals$Sched.unstable_NormalPriority,
    Scheduler_LowPriority = _ReactInternals$Sched.unstable_LowPriority,
    Scheduler_IdlePriority = _ReactInternals$Sched.unstable_IdlePriority,
    fakeCallbackNode = {},
    shouldYield = _ReactInternals$Sched.unstable_shouldYield,
    requestPaint =
      void 0 !== Scheduler_requestPaint
        ? Scheduler_requestPaint
        : function() {},
    syncQueue = null,
    immediateQueueCallbackNode = null,
    isFlushingSyncQueue = !1,
    initialTimeMs = unstable_now(),
    now =
      1e4 > initialTimeMs
        ? unstable_now
        : function() {
            return unstable_now() - initialTimeMs;
          },
    hasOwnProperty = Object.prototype.hasOwnProperty,
    valueCursor = { current: null },
    currentlyRenderingFiber = null,
    lastContextDependency = null,
    lastContextWithAllBitsObserved = null,
    UpdateState = 0,
    ForceUpdate = 2,
    hasForceUpdate = !1,
    ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
    emptyRefsObject = new React.Component().refs,
    classComponentUpdater = {
      isMounted: function(component) {
        return (component = component._reactInternalFiber)
          ? 2 === isFiberMountedImpl(component)
          : !1;
      },
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternalFiber;
        var currentTime = requestCurrentTime(),
          suspenseConfig = ReactCurrentBatchConfig.suspense;
        currentTime = computeExpirationForFiber(
          currentTime,
          inst,
          suspenseConfig
        );
        suspenseConfig = createUpdate(currentTime, suspenseConfig);
        suspenseConfig.payload = payload;
        void 0 !== callback &&
          null !== callback &&
          (suspenseConfig.callback = callback);
        enqueueUpdate(inst, suspenseConfig);
        scheduleWork(inst, currentTime);
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternalFiber;
        var currentTime = requestCurrentTime(),
          suspenseConfig = ReactCurrentBatchConfig.suspense;
        currentTime = computeExpirationForFiber(
          currentTime,
          inst,
          suspenseConfig
        );
        suspenseConfig = createUpdate(currentTime, suspenseConfig);
        suspenseConfig.tag = 1;
        suspenseConfig.payload = payload;
        void 0 !== callback &&
          null !== callback &&
          (suspenseConfig.callback = callback);
        enqueueUpdate(inst, suspenseConfig);
        scheduleWork(inst, currentTime);
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternalFiber;
        var currentTime = requestCurrentTime(),
          suspenseConfig = ReactCurrentBatchConfig.suspense;
        currentTime = computeExpirationForFiber(
          currentTime,
          inst,
          suspenseConfig
        );
        suspenseConfig = createUpdate(currentTime, suspenseConfig);
        suspenseConfig.tag = ForceUpdate;
        void 0 !== callback &&
          null !== callback &&
          (suspenseConfig.callback = callback);
        enqueueUpdate(inst, suspenseConfig);
        scheduleWork(inst, currentTime);
      }
    },
    isArray = Array.isArray,
    reconcileChildFibers = ChildReconciler(!0),
    mountChildFibers = ChildReconciler(!1),
    NO_CONTEXT$1 = {},
    contextStackCursor$1 = { current: NO_CONTEXT$1 },
    contextFiberStackCursor = { current: NO_CONTEXT$1 },
    rootInstanceStackCursor = { current: NO_CONTEXT$1 },
    suspenseStackCursor = { current: 0 },
    ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
    renderExpirationTime$1 = 0,
    currentlyRenderingFiber$1 = null,
    currentHook = null,
    nextCurrentHook = null,
    firstWorkInProgressHook = null,
    workInProgressHook = null,
    nextWorkInProgressHook = null,
    remainingExpirationTime = 0,
    componentUpdateQueue = null,
    sideEffectTag = 0,
    didScheduleRenderPhaseUpdate = !1,
    renderPhaseUpdates = null,
    numberOfReRenders = 0,
    ContextOnlyDispatcher = {
      readContext: readContext,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useResponder: throwInvalidHookError
    },
    HooksDispatcherOnMount = {
      readContext: readContext,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: function(create, deps) {
        return mountEffectImpl(516, 192, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        return mountEffectImpl(
          4,
          36,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      },
      useLayoutEffect: function(create, deps) {
        return mountEffectImpl(4, 36, create, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        nextCreate = nextCreate();
        hook.memoizedState = [nextCreate, deps];
        return nextCreate;
      },
      useReducer: function(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        initialArg = void 0 !== init ? init(initialArg) : initialArg;
        hook.memoizedState = hook.baseState = initialArg;
        reducer = hook.queue = {
          last: null,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialArg
        };
        reducer = reducer.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingFiber$1,
          reducer
        );
        return [hook.memoizedState, reducer];
      },
      useRef: function(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return (hook.memoizedState = initialValue);
      },
      useState: function(initialState) {
        var hook = mountWorkInProgressHook();
        "function" === typeof initialState && (initialState = initialState());
        hook.memoizedState = hook.baseState = initialState;
        initialState = hook.queue = {
          last: null,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        initialState = initialState.dispatch = dispatchAction.bind(
          null,
          currentlyRenderingFiber$1,
          initialState
        );
        return [hook.memoizedState, initialState];
      },
      useDebugValue: mountDebugValue,
      useResponder: createResponderListener
    },
    HooksDispatcherOnUpdate = {
      readContext: readContext,
      useCallback: function(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (
          null !== prevState &&
          null !== deps &&
          areHookInputsEqual(deps, prevState[1])
        )
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      },
      useContext: readContext,
      useEffect: function(create, deps) {
        return updateEffectImpl(516, 192, create, deps);
      },
      useImperativeHandle: function(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        return updateEffectImpl(
          4,
          36,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      },
      useLayoutEffect: function(create, deps) {
        return updateEffectImpl(4, 36, create, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (
          null !== prevState &&
          null !== deps &&
          areHookInputsEqual(deps, prevState[1])
        )
          return prevState[0];
        nextCreate = nextCreate();
        hook.memoizedState = [nextCreate, deps];
        return nextCreate;
      },
      useReducer: updateReducer,
      useRef: function(initialValue) {
        return updateWorkInProgressHook().memoizedState;
      },
      useState: function(initialState) {
        return updateReducer(basicStateReducer, initialState);
      },
      useDebugValue: mountDebugValue,
      useResponder: createResponderListener
    },
    hydrationParentFiber = null,
    nextHydratableInstance = null,
    isHydrating = !1,
    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
    didReceiveUpdate = !1,
    SUSPENDED_MARKER = { dehydrated: null, retryTime: 1 };
  var appendAllChildren = function(
    parent,
    workInProgress,
    needsVisibilityToggle,
    isHidden
  ) {
    for (
      needsVisibilityToggle = workInProgress.child;
      null !== needsVisibilityToggle;

    ) {
      if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) {
        isHidden = parent;
        var child = needsVisibilityToggle.stateNode;
        if ("string" === typeof child) throw ReactErrorProd(Error(216));
        child.inject(isHidden);
      } else if (
        4 !== needsVisibilityToggle.tag &&
        null !== needsVisibilityToggle.child
      ) {
        needsVisibilityToggle.child.return = needsVisibilityToggle;
        needsVisibilityToggle = needsVisibilityToggle.child;
        continue;
      }
      if (needsVisibilityToggle === workInProgress) break;
      for (; null === needsVisibilityToggle.sibling; ) {
        if (
          null === needsVisibilityToggle.return ||
          needsVisibilityToggle.return === workInProgress
        )
          return;
        needsVisibilityToggle = needsVisibilityToggle.return;
      }
      needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;
      needsVisibilityToggle = needsVisibilityToggle.sibling;
    }
  };
  var updateHostContainer = function(workInProgress) {};
  var updateHostComponent$1 = function(
    current,
    workInProgress,
    type,
    newProps,
    rootContainerInstance
  ) {
    current.memoizedProps !== newProps &&
      (requiredContext(contextStackCursor$1.current),
      (workInProgress.updateQueue = UPDATE_SIGNAL)) &&
      (workInProgress.effectTag |= 4);
  };
  var updateHostText$1 = function(current, workInProgress, oldText, newText) {
    oldText !== newText && (workInProgress.effectTag |= 4);
  };
  var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
    PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
    ceil = Math.ceil,
    ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner,
    NoContext = 0,
    LegacyUnbatchedContext = 8,
    RenderContext = 16,
    CommitContext = 32,
    RootIncomplete = 0,
    RootErrored = 1,
    RootSuspended = 2,
    RootSuspendedWithDelay = 3,
    RootCompleted = 4,
    executionContext = NoContext,
    workInProgressRoot = null,
    workInProgress = null,
    renderExpirationTime = 0,
    workInProgressRootExitStatus = RootIncomplete,
    workInProgressRootLatestProcessedExpirationTime = 1073741823,
    workInProgressRootLatestSuspenseTimeout = 1073741823,
    workInProgressRootCanSuspendUsingConfig = null,
    workInProgressRootHasPendingPing = !1,
    globalMostRecentFallbackTime = 0,
    FALLBACK_THROTTLE_MS = 500,
    nextEffect = null,
    hasUncaughtError = !1,
    firstUncaughtError = null,
    legacyErrorBoundariesThatAlreadyFailed = null,
    rootDoesHavePassiveEffects = !1,
    rootWithPendingPassiveEffects = null,
    pendingPassiveEffectsRenderPriority = 90,
    pendingPassiveEffectsExpirationTime = 0,
    rootsWithPendingDiscreteUpdates = null,
    nestedUpdateCount = 0,
    rootWithNestedUpdates = null,
    currentEventTime = 0,
    scheduleWork = function(fiber, expirationTime) {
      if (50 < nestedUpdateCount)
        throw ((nestedUpdateCount = 0),
        (rootWithNestedUpdates = null),
        ReactErrorProd(Error(185)));
      fiber = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
      if (null !== fiber) {
        fiber.pingTime = 0;
        var priorityLevel = getCurrentPriorityLevel();
        if (1073741823 === expirationTime)
          if (
            (executionContext & LegacyUnbatchedContext) !== NoContext &&
            (executionContext & (RenderContext | CommitContext)) === NoContext
          )
            for (
              var callback = renderRoot(fiber, 1073741823, !0);
              null !== callback;

            )
              callback = callback(!0);
          else
            scheduleCallbackForRoot(fiber, 99, 1073741823),
              executionContext === NoContext && flushSyncCallbackQueue();
        else scheduleCallbackForRoot(fiber, priorityLevel, expirationTime);
        (executionContext & 4) === NoContext ||
          (98 !== priorityLevel && 99 !== priorityLevel) ||
          (null === rootsWithPendingDiscreteUpdates
            ? (rootsWithPendingDiscreteUpdates = new Map([
                [fiber, expirationTime]
              ]))
            : ((priorityLevel = rootsWithPendingDiscreteUpdates.get(fiber)),
              (void 0 === priorityLevel || priorityLevel > expirationTime) &&
                rootsWithPendingDiscreteUpdates.set(fiber, expirationTime)));
      }
    };
  var beginWork$$1 = function(current, workInProgress, renderExpirationTime) {
    var updateExpirationTime = workInProgress.expirationTime;
    if (null !== current)
      if (
        current.memoizedProps !== workInProgress.pendingProps ||
        didPerformWorkStackCursor.current
      )
        didReceiveUpdate = !0;
      else {
        if (updateExpirationTime < renderExpirationTime) {
          didReceiveUpdate = !1;
          switch (workInProgress.tag) {
            case 3:
              pushHostRootContext(workInProgress);
              break;
            case 5:
              pushHostContext(workInProgress);
              break;
            case 1:
              isContextProvider(workInProgress.type) &&
                pushContextProvider(workInProgress);
              break;
            case 4:
              pushHostContainer(
                workInProgress,
                workInProgress.stateNode.containerInfo
              );
              break;
            case 10:
              pushProvider(workInProgress, workInProgress.memoizedProps.value);
              break;
            case 13:
              if (null !== workInProgress.memoizedState) {
                updateExpirationTime = workInProgress.child.childExpirationTime;
                if (
                  0 !== updateExpirationTime &&
                  updateExpirationTime >= renderExpirationTime
                )
                  return updateSuspenseComponent(
                    current,
                    workInProgress,
                    renderExpirationTime
                  );
                push(
                  suspenseStackCursor,
                  suspenseStackCursor.current & 1,
                  workInProgress
                );
                workInProgress = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderExpirationTime
                );
                return null !== workInProgress ? workInProgress.sibling : null;
              }
              push(
                suspenseStackCursor,
                suspenseStackCursor.current & 1,
                workInProgress
              );
              break;
            case 19:
              updateExpirationTime =
                workInProgress.childExpirationTime >= renderExpirationTime;
              if (0 !== (current.effectTag & 64)) {
                if (updateExpirationTime)
                  return updateSuspenseListComponent(
                    current,
                    workInProgress,
                    renderExpirationTime
                  );
                workInProgress.effectTag |= 64;
              }
              var renderState = workInProgress.memoizedState;
              null !== renderState &&
                ((renderState.rendering = null), (renderState.tail = null));
              push(
                suspenseStackCursor,
                suspenseStackCursor.current,
                workInProgress
              );
              if (!updateExpirationTime) return null;
          }
          return bailoutOnAlreadyFinishedWork(
            current,
            workInProgress,
            renderExpirationTime
          );
        }
        didReceiveUpdate = !1;
      }
    else didReceiveUpdate = !1;
    workInProgress.expirationTime = 0;
    switch (workInProgress.tag) {
      case 2:
        updateExpirationTime = workInProgress.type;
        null !== current &&
          ((current.alternate = null),
          (workInProgress.alternate = null),
          (workInProgress.effectTag |= 2));
        current = workInProgress.pendingProps;
        renderState = getMaskedContext(
          workInProgress,
          contextStackCursor.current
        );
        prepareToReadContext(workInProgress, renderExpirationTime);
        renderState = renderWithHooks(
          null,
          workInProgress,
          updateExpirationTime,
          current,
          renderState,
          renderExpirationTime
        );
        workInProgress.effectTag |= 1;
        if (
          "object" === typeof renderState &&
          null !== renderState &&
          "function" === typeof renderState.render &&
          void 0 === renderState.$$typeof
        ) {
          workInProgress.tag = 1;
          resetHooks();
          if (isContextProvider(updateExpirationTime)) {
            var hasContext = !0;
            pushContextProvider(workInProgress);
          } else hasContext = !1;
          workInProgress.memoizedState =
            null !== renderState.state && void 0 !== renderState.state
              ? renderState.state
              : null;
          var getDerivedStateFromProps =
            updateExpirationTime.getDerivedStateFromProps;
          "function" === typeof getDerivedStateFromProps &&
            applyDerivedStateFromProps(
              workInProgress,
              updateExpirationTime,
              getDerivedStateFromProps,
              current
            );
          renderState.updater = classComponentUpdater;
          workInProgress.stateNode = renderState;
          renderState._reactInternalFiber = workInProgress;
          mountClassInstance(
            workInProgress,
            updateExpirationTime,
            current,
            renderExpirationTime
          );
          workInProgress = finishClassComponent(
            null,
            workInProgress,
            updateExpirationTime,
            !0,
            hasContext,
            renderExpirationTime
          );
        } else
          (workInProgress.tag = 0),
            reconcileChildren(
              null,
              workInProgress,
              renderState,
              renderExpirationTime
            ),
            (workInProgress = workInProgress.child);
        return workInProgress;
      case 16:
        renderState = workInProgress.elementType;
        null !== current &&
          ((current.alternate = null),
          (workInProgress.alternate = null),
          (workInProgress.effectTag |= 2));
        current = workInProgress.pendingProps;
        initializeLazyComponentType(renderState);
        if (1 !== renderState._status) throw renderState._result;
        renderState = renderState._result;
        workInProgress.type = renderState;
        hasContext = workInProgress.tag = resolveLazyComponentTag(renderState);
        current = resolveDefaultProps(renderState, current);
        switch (hasContext) {
          case 0:
            workInProgress = updateFunctionComponent(
              null,
              workInProgress,
              renderState,
              current,
              renderExpirationTime
            );
            break;
          case 1:
            workInProgress = updateClassComponent(
              null,
              workInProgress,
              renderState,
              current,
              renderExpirationTime
            );
            break;
          case 11:
            workInProgress = updateForwardRef(
              null,
              workInProgress,
              renderState,
              current,
              renderExpirationTime
            );
            break;
          case 14:
            workInProgress = updateMemoComponent(
              null,
              workInProgress,
              renderState,
              resolveDefaultProps(renderState.type, current),
              updateExpirationTime,
              renderExpirationTime
            );
            break;
          default:
            throw ReactErrorProd(Error(306), renderState, "");
        }
        return workInProgress;
      case 0:
        return (
          (updateExpirationTime = workInProgress.type),
          (renderState = workInProgress.pendingProps),
          (renderState =
            workInProgress.elementType === updateExpirationTime
              ? renderState
              : resolveDefaultProps(updateExpirationTime, renderState)),
          updateFunctionComponent(
            current,
            workInProgress,
            updateExpirationTime,
            renderState,
            renderExpirationTime
          )
        );
      case 1:
        return (
          (updateExpirationTime = workInProgress.type),
          (renderState = workInProgress.pendingProps),
          (renderState =
            workInProgress.elementType === updateExpirationTime
              ? renderState
              : resolveDefaultProps(updateExpirationTime, renderState)),
          updateClassComponent(
            current,
            workInProgress,
            updateExpirationTime,
            renderState,
            renderExpirationTime
          )
        );
      case 3:
        pushHostRootContext(workInProgress);
        updateExpirationTime = workInProgress.updateQueue;
        if (null === updateExpirationTime) throw ReactErrorProd(Error(282));
        renderState = workInProgress.memoizedState;
        renderState = null !== renderState ? renderState.element : null;
        processUpdateQueue(
          workInProgress,
          updateExpirationTime,
          workInProgress.pendingProps,
          null,
          renderExpirationTime
        );
        updateExpirationTime = workInProgress.memoizedState.element;
        updateExpirationTime === renderState
          ? (workInProgress = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderExpirationTime
            ))
          : (reconcileChildren(
              current,
              workInProgress,
              updateExpirationTime,
              renderExpirationTime
            ),
            (workInProgress = workInProgress.child));
        return workInProgress;
      case 5:
        return (
          pushHostContext(workInProgress),
          null === current && tryToClaimNextHydratableInstance(workInProgress),
          (updateExpirationTime = workInProgress.type),
          (renderState = workInProgress.pendingProps),
          (hasContext = null !== current ? current.memoizedProps : null),
          (getDerivedStateFromProps = renderState.children),
          shouldSetTextContent(updateExpirationTime, renderState)
            ? (getDerivedStateFromProps = null)
            : null !== hasContext &&
              shouldSetTextContent(updateExpirationTime, hasContext) &&
              (workInProgress.effectTag |= 16),
          markRef(current, workInProgress),
          reconcileChildren(
            current,
            workInProgress,
            getDerivedStateFromProps,
            renderExpirationTime
          ),
          workInProgress.child
        );
      case 6:
        return (
          null === current && tryToClaimNextHydratableInstance(workInProgress),
          null
        );
      case 13:
        return updateSuspenseComponent(
          current,
          workInProgress,
          renderExpirationTime
        );
      case 4:
        return (
          pushHostContainer(
            workInProgress,
            workInProgress.stateNode.containerInfo
          ),
          (updateExpirationTime = workInProgress.pendingProps),
          null === current
            ? (workInProgress.child = reconcileChildFibers(
                workInProgress,
                null,
                updateExpirationTime,
                renderExpirationTime
              ))
            : reconcileChildren(
                current,
                workInProgress,
                updateExpirationTime,
                renderExpirationTime
              ),
          workInProgress.child
        );
      case 11:
        return (
          (updateExpirationTime = workInProgress.type),
          (renderState = workInProgress.pendingProps),
          (renderState =
            workInProgress.elementType === updateExpirationTime
              ? renderState
              : resolveDefaultProps(updateExpirationTime, renderState)),
          updateForwardRef(
            current,
            workInProgress,
            updateExpirationTime,
            renderState,
            renderExpirationTime
          )
        );
      case 7:
        return (
          reconcileChildren(
            current,
            workInProgress,
            workInProgress.pendingProps,
            renderExpirationTime
          ),
          workInProgress.child
        );
      case 8:
        return (
          reconcileChildren(
            current,
            workInProgress,
            workInProgress.pendingProps.children,
            renderExpirationTime
          ),
          workInProgress.child
        );
      case 12:
        return (
          reconcileChildren(
            current,
            workInProgress,
            workInProgress.pendingProps.children,
            renderExpirationTime
          ),
          workInProgress.child
        );
      case 10:
        a: {
          updateExpirationTime = workInProgress.type._context;
          renderState = workInProgress.pendingProps;
          getDerivedStateFromProps = workInProgress.memoizedProps;
          hasContext = renderState.value;
          pushProvider(workInProgress, hasContext);
          if (null !== getDerivedStateFromProps) {
            var oldValue = getDerivedStateFromProps.value;
            hasContext = is(oldValue, hasContext)
              ? 0
              : ("function" ===
                typeof updateExpirationTime._calculateChangedBits
                  ? updateExpirationTime._calculateChangedBits(
                      oldValue,
                      hasContext
                    )
                  : 1073741823) | 0;
            if (0 === hasContext) {
              if (
                getDerivedStateFromProps.children === renderState.children &&
                !didPerformWorkStackCursor.current
              ) {
                workInProgress = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress,
                  renderExpirationTime
                );
                break a;
              }
            } else
              for (
                oldValue = workInProgress.child,
                  null !== oldValue && (oldValue.return = workInProgress);
                null !== oldValue;

              ) {
                var list = oldValue.dependencies;
                if (null !== list) {
                  getDerivedStateFromProps = oldValue.child;
                  for (
                    var dependency = list.firstContext;
                    null !== dependency;

                  ) {
                    if (
                      dependency.context === updateExpirationTime &&
                      0 !== (dependency.observedBits & hasContext)
                    ) {
                      1 === oldValue.tag &&
                        ((dependency = createUpdate(
                          renderExpirationTime,
                          null
                        )),
                        (dependency.tag = ForceUpdate),
                        enqueueUpdate(oldValue, dependency));
                      oldValue.expirationTime < renderExpirationTime &&
                        (oldValue.expirationTime = renderExpirationTime);
                      dependency = oldValue.alternate;
                      null !== dependency &&
                        dependency.expirationTime < renderExpirationTime &&
                        (dependency.expirationTime = renderExpirationTime);
                      scheduleWorkOnParentPath(
                        oldValue.return,
                        renderExpirationTime
                      );
                      list.expirationTime < renderExpirationTime &&
                        (list.expirationTime = renderExpirationTime);
                      break;
                    }
                    dependency = dependency.next;
                  }
                } else
                  getDerivedStateFromProps =
                    10 === oldValue.tag
                      ? oldValue.type === workInProgress.type
                        ? null
                        : oldValue.child
                      : oldValue.child;
                if (null !== getDerivedStateFromProps)
                  getDerivedStateFromProps.return = oldValue;
                else
                  for (
                    getDerivedStateFromProps = oldValue;
                    null !== getDerivedStateFromProps;

                  ) {
                    if (getDerivedStateFromProps === workInProgress) {
                      getDerivedStateFromProps = null;
                      break;
                    }
                    oldValue = getDerivedStateFromProps.sibling;
                    if (null !== oldValue) {
                      oldValue.return = getDerivedStateFromProps.return;
                      getDerivedStateFromProps = oldValue;
                      break;
                    }
                    getDerivedStateFromProps = getDerivedStateFromProps.return;
                  }
                oldValue = getDerivedStateFromProps;
              }
          }
          reconcileChildren(
            current,
            workInProgress,
            renderState.children,
            renderExpirationTime
          );
          workInProgress = workInProgress.child;
        }
        return workInProgress;
      case 9:
        return (
          (renderState = workInProgress.type),
          (hasContext = workInProgress.pendingProps),
          (updateExpirationTime = hasContext.children),
          prepareToReadContext(workInProgress, renderExpirationTime),
          (renderState = readContext(
            renderState,
            hasContext.unstable_observedBits
          )),
          (updateExpirationTime = updateExpirationTime(renderState)),
          (workInProgress.effectTag |= 1),
          reconcileChildren(
            current,
            workInProgress,
            updateExpirationTime,
            renderExpirationTime
          ),
          workInProgress.child
        );
      case 14:
        return (
          (renderState = workInProgress.type),
          (hasContext = resolveDefaultProps(
            renderState,
            workInProgress.pendingProps
          )),
          (hasContext = resolveDefaultProps(renderState.type, hasContext)),
          updateMemoComponent(
            current,
            workInProgress,
            renderState,
            hasContext,
            updateExpirationTime,
            renderExpirationTime
          )
        );
      case 15:
        return updateSimpleMemoComponent(
          current,
          workInProgress,
          workInProgress.type,
          workInProgress.pendingProps,
          updateExpirationTime,
          renderExpirationTime
        );
      case 17:
        return (
          (updateExpirationTime = workInProgress.type),
          (renderState = workInProgress.pendingProps),
          (renderState =
            workInProgress.elementType === updateExpirationTime
              ? renderState
              : resolveDefaultProps(updateExpirationTime, renderState)),
          null !== current &&
            ((current.alternate = null),
            (workInProgress.alternate = null),
            (workInProgress.effectTag |= 2)),
          (workInProgress.tag = 1),
          isContextProvider(updateExpirationTime)
            ? ((current = !0), pushContextProvider(workInProgress))
            : (current = !1),
          prepareToReadContext(workInProgress, renderExpirationTime),
          constructClassInstance(
            workInProgress,
            updateExpirationTime,
            renderState,
            renderExpirationTime
          ),
          mountClassInstance(
            workInProgress,
            updateExpirationTime,
            renderState,
            renderExpirationTime
          ),
          finishClassComponent(
            null,
            workInProgress,
            updateExpirationTime,
            !0,
            current,
            renderExpirationTime
          )
        );
      case 19:
        return updateSuspenseListComponent(
          current,
          workInProgress,
          renderExpirationTime
        );
    }
    throw ReactErrorProd(Error(156));
  };
  var onCommitFiberRoot = null,
    onCommitFiberUnmount = null,
    createFiber = function(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    },
    container = _class({
      grab: function() {
        for (var i = 0; i < arguments.length; i++) arguments[i].inject(this);
        return this;
      },
      empty: function() {
        for (var node; (node = this.firstChild); ) node.eject();
        return this;
      }
    }),
    native_1 = _class({
      toElement: function() {
        return this.element;
      },
      getDOMNode: function() {
        return this.toElement();
      },
      getNode: function() {
        return this.toElement();
      },
      inject: function(container) {
        (container.containerElement || elementFrom(container)).appendChild(
          this.element
        );
        return this;
      },
      injectBefore: function(sibling) {
        sibling = elementFrom(sibling);
        sibling.parentNode.insertBefore(this.element, sibling);
        return this;
      },
      eject: function() {
        var element = this.element,
          parent = element.parentNode;
        parent && parent.removeChild(element);
        return this;
      },
      subscribe: function(type, fn, bind) {
        if ("string" != typeof type) {
          var subscriptions = [],
            t;
          for (t in type) subscriptions.push(this.subscribe(t, type[t]));
          return function() {
            for (var i = 0, l = subscriptions.length; i < l; i++)
              subscriptions[i]();
            return this;
          };
        }
        bind || (bind = this);
        var bound =
          "function" === typeof fn
            ? fn.bind
              ? fn.bind(bind)
              : function() {
                  return fn.apply(bind, arguments);
                }
            : fn;
        var element = this.element;
        if (element.addEventListener)
          return (
            element.addEventListener(type, bound, !1),
            function() {
              element.removeEventListener(type, bound, !1);
              return this;
            }
          );
        element.attachEvent("on" + type, bound);
        return function() {
          element.detachEvent("on" + type, bound);
          return this;
        };
      }
    }),
    fps = 1e3 / 60,
    invalids = [],
    renderTimer,
    renderInvalids = function() {
      clearTimeout(renderTimer);
      renderTimer = null;
      var canvases = invalids;
      invalids = [];
      for (var i = 0, l = canvases.length; i < l; i++) {
        var c = canvases[i];
        c._valid = !0;
        c.render();
      }
    },
    resolution =
      ("undefined" !== typeof window && window.devicePixelRatio) || 1,
    previousHit = null,
    previousHitSurface = null,
    CanvasSurface = _class(native_1, container, {
      initialize: function(width, height, existingElement) {
        existingElement = this.element =
          existingElement || document.createElement("canvas");
        this.context = existingElement.getContext("2d");
        this._valid = !0;
        null != width && null != height && this.resize(width, height);
        existingElement.addEventListener("mousemove", this, !1);
        existingElement.addEventListener("mouseout", this, !1);
        existingElement.addEventListener("mouseover", this, !1);
        existingElement.addEventListener("mouseup", this, !1);
        existingElement.addEventListener("mousedown", this, !1);
        existingElement.addEventListener("click", this, !1);
      },
      handleEvent: function(event) {
        if (null != event.clientX) {
          var element = this.element,
            rect = element.getBoundingClientRect();
          element = this.hitTest(
            event.clientX - rect.left - element.clientLeft,
            event.clientY - rect.top - element.clientTop
          );
          element !== previousHit &&
            (previousHit &&
              previousHit.dispatch({
                type: "mouseout",
                target: previousHit,
                relatedTarget: element,
                sourceEvent: event
              }),
            element &&
              element.dispatch({
                type: "mouseover",
                target: element,
                relatedTarget: previousHit,
                sourceEvent: event
              }),
            (previousHit = element),
            (previousHitSurface = this),
            this.refreshCursor());
          element && element.dispatch(event);
        }
      },
      refreshCursor: function() {
        if (previousHitSurface === this) {
          for (
            var hit = previousHit, hitCursor = "", hitTooltip = "";
            !(
              !hit ||
              (!hitCursor &&
                hit._cursor &&
                ((hitCursor = hit._cursor), hitTooltip)) ||
              (!hitTooltip &&
                hit._tooltip &&
                ((hitTooltip = hit._tooltip), hitCursor))
            );

          )
            hit = hit.parentNode;
          this.element.style.cursor = hitCursor;
          this.element.title = hitTooltip;
        }
      },
      resize: function(width, height) {
        var element = this.element;
        element.setAttribute("width", width * resolution);
        element.setAttribute("height", height * resolution);
        element.style.width = width + "px";
        element.style.height = height + "px";
        this.width = width;
        this.height = height;
        return this;
      },
      invalidate: function(left, top, width, height) {
        this._valid &&
          ((this._valid = !1),
          invalids.push(this),
          renderTimer ||
            (window.mozRequestAnimationFrame
              ? ((renderTimer = !0),
                window.mozRequestAnimationFrame(renderInvalids))
              : (renderTimer = setTimeout(renderInvalids, fps))));
        return this;
      },
      hitTest: function(x, y) {
        if (0 > x || 0 > y || x > this.width || y > this.height) return null;
        for (var node = this.lastChild; node; ) {
          var hit = node.hitTest(x, y);
          if (hit) return hit;
          node = node.previousSibling;
        }
        return null;
      },
      render: function() {
        var node = this.firstChild,
          context = this.context;
        context.setTransform(resolution, 0, 0, resolution, 0, 0);
        for (context.clearRect(0, 0, this.width, this.height); node; )
          node.renderTo(context, resolution, 0, 0, resolution, 0, 0),
            (node = node.nextSibling);
        this.refreshCursor();
      }
    });
  CanvasSurface.tagName = "canvas";
  var path$2 = _class({
      initialize: function(path) {
        this.reset().push(path);
      },
      push: function() {
        var p = Array.prototype.join
          .call(arguments, " ")
          .match(/[a-df-z]|[\-+]?(?:[\d\.]e[\-+]?|[^\s\-+,a-z])+/gi);
        if (!p) return this;
        for (var last, cmd = p[0], i = 1; cmd; ) {
          switch (cmd) {
            case "m":
              this.move(p[i++], p[i++]);
              break;
            case "l":
              this.line(p[i++], p[i++]);
              break;
            case "c":
              this.curve(p[i++], p[i++], p[i++], p[i++], p[i++], p[i++]);
              break;
            case "s":
              this.curve(p[i++], p[i++], null, null, p[i++], p[i++]);
              break;
            case "q":
              this.curve(p[i++], p[i++], p[i++], p[i++]);
              break;
            case "t":
              this.curve(p[i++], p[i++]);
              break;
            case "a":
              this.arc(
                p[i + 5],
                p[i + 6],
                p[i],
                p[i + 1],
                p[i + 3],
                !+p[i + 4],
                p[i + 2]
              );
              i += 7;
              break;
            case "h":
              this.line(p[i++], 0);
              break;
            case "v":
              this.line(0, p[i++]);
              break;
            case "M":
              this.moveTo(p[i++], p[i++]);
              break;
            case "L":
              this.lineTo(p[i++], p[i++]);
              break;
            case "C":
              this.curveTo(p[i++], p[i++], p[i++], p[i++], p[i++], p[i++]);
              break;
            case "S":
              this.curveTo(p[i++], p[i++], null, null, p[i++], p[i++]);
              break;
            case "Q":
              this.curveTo(p[i++], p[i++], p[i++], p[i++]);
              break;
            case "T":
              this.curveTo(p[i++], p[i++]);
              break;
            case "A":
              this.arcTo(
                p[i + 5],
                p[i + 6],
                p[i],
                p[i + 1],
                p[i + 3],
                !+p[i + 4],
                p[i + 2]
              );
              i += 7;
              break;
            case "H":
              this.lineTo(p[i++], this.penY);
              break;
            case "V":
              this.lineTo(this.penX, p[i++]);
              break;
            case "Z":
            case "z":
              this.close();
              break;
            default:
              cmd = last;
              i--;
              continue;
          }
          last = cmd;
          "m" == last ? (last = "l") : "M" == last && (last = "L");
          cmd = p[i++];
        }
        return this;
      },
      reset: function() {
        this.penX = this.penY = 0;
        this.penDownX = this.penDownY = null;
        this._pivotX = this._pivotY = 0;
        this.onReset();
        return this;
      },
      move: function(x, y) {
        this.onMove(
          this.penX,
          this.penY,
          (this._pivotX = this.penX += +x),
          (this._pivotY = this.penY += +y)
        );
        return this;
      },
      moveTo: function(x, y) {
        this.onMove(
          this.penX,
          this.penY,
          (this._pivotX = this.penX = +x),
          (this._pivotY = this.penY = +y)
        );
        return this;
      },
      line: function(x, y) {
        return this.lineTo(this.penX + +x, this.penY + +y);
      },
      lineTo: function(x, y) {
        null == this.penDownX &&
          ((this.penDownX = this.penX), (this.penDownY = this.penY));
        this.onLine(
          this.penX,
          this.penY,
          (this._pivotX = this.penX = +x),
          (this._pivotY = this.penY = +y)
        );
        return this;
      },
      curve: function(c1x, c1y, c2x, c2y, ex, ey) {
        var x = this.penX,
          y = this.penY;
        return this.curveTo(
          x + +c1x,
          y + +c1y,
          null == c2x ? null : x + +c2x,
          null == c2y ? null : y + +c2y,
          null == ex ? null : x + +ex,
          null == ey ? null : y + +ey
        );
      },
      curveTo: function(c1x, c1y, c2x, c2y, ex, ey) {
        var x = this.penX,
          y = this.penY;
        null == c2x &&
          ((c2x = +c1x),
          (c2y = +c1y),
          (c1x = 2 * x - (this._pivotX || 0)),
          (c1y = 2 * y - (this._pivotY || 0)));
        null == ex
          ? ((this._pivotX = +c1x),
            (this._pivotY = +c1y),
            (ex = +c2x),
            (ey = +c2y),
            (c2x = (ex + 2 * +c1x) / 3),
            (c2y = (ey + 2 * +c1y) / 3),
            (c1x = (x + 2 * +c1x) / 3),
            (c1y = (y + 2 * +c1y) / 3))
          : ((this._pivotX = +c2x), (this._pivotY = +c2y));
        null == this.penDownX && ((this.penDownX = x), (this.penDownY = y));
        this.onBezierCurve(
          x,
          y,
          +c1x,
          +c1y,
          +c2x,
          +c2y,
          (this.penX = +ex),
          (this.penY = +ey)
        );
        return this;
      },
      arc: function(x, y, rx, ry, outer, counterClockwise, rotation) {
        return this.arcTo(
          this.penX + +x,
          this.penY + +y,
          rx,
          ry,
          outer,
          counterClockwise,
          rotation
        );
      },
      arcTo: function(x, y, rx, ry, outer, counterClockwise, rotation) {
        ry = Math.abs(+ry || +rx || +y - this.penY);
        rx = Math.abs(+rx || +x - this.penX);
        if (!rx || !ry || (x == this.penX && y == this.penY))
          return this.lineTo(x, y);
        var tX = this.penX,
          tY = this.penY;
        counterClockwise = !+counterClockwise;
        var large = !!+outer;
        outer = rotation ? (rotation * Math.PI) / 180 : 0;
        var cos = Math.cos(outer),
          sin = Math.sin(outer);
        x -= tX;
        y -= tY;
        outer = (cos * x) / 2 + (sin * y) / 2;
        var cy = (-sin * x) / 2 + (cos * y) / 2,
          rxry = rx * rx * ry * ry,
          rycx = ry * ry * outer * outer,
          rxcy = rx * rx * cy * cy,
          a = rxry - rxcy - rycx;
        0 > a
          ? ((a = Math.sqrt(1 - a / rxry)),
            (rx *= a),
            (ry *= a),
            (outer = x / 2),
            (cy = y / 2))
          : ((a = Math.sqrt(a / (rxcy + rycx))),
            large == counterClockwise && (a = -a),
            (cy = (-a * cy * rx) / ry),
            (large = (a * outer * ry) / rx),
            (outer = cos * cy - sin * large + x / 2),
            (cy = sin * cy + cos * large + y / 2));
        large = cos / rx;
        a = sin / rx;
        sin = -sin / ry;
        rxry = cos / ry;
        cos = Math.atan2(sin * -outer + rxry * -cy, large * -outer + a * -cy);
        sin = Math.atan2(
          sin * (x - outer) + rxry * (y - cy),
          large * (x - outer) + a * (y - cy)
        );
        null == this.penDownX &&
          ((this.penDownX = this.penX), (this.penDownY = this.penY));
        this.onArc(
          tX,
          tY,
          (this._pivotX = this.penX = x + tX),
          (this._pivotY = this.penY = y + tY),
          outer + tX,
          cy + tY,
          rx,
          ry,
          cos,
          sin,
          !counterClockwise,
          rotation
        );
        return this;
      },
      counterArc: function(x, y, rx, ry, outer) {
        return this.arc(x, y, rx, ry, outer, !0);
      },
      counterArcTo: function(x, y, rx, ry, outer) {
        return this.arcTo(x, y, rx, ry, outer, !0);
      },
      close: function() {
        null != this.penDownX &&
          (this.onClose(
            this.penX,
            this.penY,
            (this.penX = this.penDownX),
            (this.penY = this.penDownY)
          ),
          (this.penDownX = null));
        return this;
      },
      onReset: function() {},
      onMove: function(sx, sy, ex, ey) {},
      onLine: function(sx, sy, ex, ey) {
        this.onBezierCurve(sx, sy, sx, sy, ex, ey, ex, ey);
      },
      onBezierCurve: function(sx, sy, c1x, c1y, c2x, c2y, ex, ey) {
        var gx = ex - sx,
          gy = ey - sy,
          g = gx * gx + gy * gy;
        var cx = c1x - sx;
        var cy = c1y - sy;
        var u = cx * gx + cy * gy;
        u > g
          ? ((cx -= gx), (cy -= gy))
          : 0 < u && 0 != g && ((cx -= (u / g) * gx), (cy -= (u / g) * gy));
        var v1 = cx * cx + cy * cy;
        cx = c2x - sx;
        cy = c2y - sy;
        u = cx * gx + cy * gy;
        u > g
          ? ((cx -= gx), (cy -= gy))
          : 0 < u && 0 != g && ((cx -= (u / g) * gx), (cy -= (u / g) * gy));
        gx = cx * cx + cy * cy;
        if (0.01 > v1 && 0.01 > gx) this.onLine(sx, sy, ex, ey);
        else {
          if (isNaN(v1) || isNaN(gx)) throw Error("Bad input");
          g = 0.5 * (c1x + c2x);
          gy = 0.5 * (c1y + c2y);
          c1x = 0.5 * (c1x + sx);
          c1y = 0.5 * (c1y + sy);
          v1 = 0.5 * (c1x + g);
          gx = 0.5 * (c1y + gy);
          c2x = 0.5 * (ex + c2x);
          c2y = 0.5 * (ey + c2y);
          g = 0.5 * (c2x + g);
          gy = 0.5 * (c2y + gy);
          cx = 0.5 * (v1 + g);
          cy = 0.5 * (gx + gy);
          this.onBezierCurve(sx, sy, c1x, c1y, v1, gx, cx, cy);
          this.onBezierCurve(cx, cy, g, gy, c2x, c2y, ex, ey);
        }
      },
      onArc: function(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
        ex = rotation ? (rotation * Math.PI) / 180 : 0;
        rotation = Math.cos(ex);
        var sin = Math.sin(ex);
        ex = rotation * rx;
        ey = -sin * ry;
        rx *= sin;
        ry *= rotation;
        ea -= sa;
        0 > ea && !ccw
          ? (ea += 2 * Math.PI)
          : 0 < ea && ccw && (ea -= 2 * Math.PI);
        ccw = Math.ceil(Math.abs(ea / (Math.PI / 2)));
        ea /= ccw;
        rotation = (4 / 3) * Math.tan(ea / 4);
        sin = Math.cos(sa);
        for (var y = Math.sin(sa), i = 0; i < ccw; i++) {
          var cp1x = sin - rotation * y,
            cp1y = y + rotation * sin;
          sa += ea;
          sin = Math.cos(sa);
          y = Math.sin(sa);
          var cp2x = sin + rotation * y,
            cp2y = y - rotation * sin;
          this.onBezierCurve(
            sx,
            sy,
            cx + ex * cp1x + ey * cp1y,
            cy + rx * cp1x + ry * cp1y,
            cx + ex * cp2x + ey * cp2y,
            cy + rx * cp2x + ry * cp2y,
            (sx = cx + ex * sin + ey * y),
            (sy = cy + rx * sin + ry * y)
          );
        }
      },
      onClose: function(sx, sy, ex, ey) {
        this.onLine(sx, sy, ex, ey);
      }
    }),
    CanvasPath = _class(path$2, {
      initialize: function(path) {
        this.reset();
        path instanceof CanvasPath
          ? (this.path = path.path.slice(0))
          : path &&
            (path.applyToPath ? path.applyToPath(this) : this.push(path));
      },
      onReset: function() {
        this.path = [];
      },
      onMove: function(sx, sy, x, y) {
        this.path.push(function(context) {
          context.moveTo(x, y);
        });
      },
      onLine: function(sx, sy, x, y) {
        this.path.push(function(context) {
          context.lineTo(x, y);
        });
      },
      onBezierCurve: function(sx, sy, p1x, p1y, p2x, p2y, x, y) {
        this.path.push(function(context) {
          context.bezierCurveTo(p1x, p1y, p2x, p2y, x, y);
        });
      },
      _arcToBezier: path$2.prototype.onArc,
      onArc: function(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
        if (rx != ry || rotation)
          return this._arcToBezier(
            sx,
            sy,
            ex,
            ey,
            cx,
            cy,
            rx,
            ry,
            sa,
            ea,
            ccw,
            rotation
          );
        this.path.push(function(context) {
          context.arc(cx, cy, rx, sa, ea, ccw);
        });
      },
      onClose: function() {
        this.path.push(function(context) {
          context.closePath();
        });
      },
      toCommands: function() {
        return this.path.slice(0);
      }
    }),
    path = CanvasPath,
    colors = {
      maroon: "#800000",
      red: "#ff0000",
      orange: "#ffA500",
      yellow: "#ffff00",
      olive: "#808000",
      purple: "#800080",
      fuchsia: "#ff00ff",
      white: "#ffffff",
      lime: "#00ff00",
      green: "#008000",
      navy: "#000080",
      blue: "#0000ff",
      aqua: "#00ffff",
      teal: "#008080",
      black: "#000000",
      silver: "#c0c0c0",
      gray: "#808080"
    },
    map = function(array, fn) {
      for (var results = [], i = 0, l = array.length; i < l; i++)
        results[i] = fn(array[i], i);
      return results;
    },
    Color = function(color, type) {
      if (color.isColor)
        (this.red = color.red),
          (this.green = color.green),
          (this.blue = color.blue),
          (this.alpha = color.alpha);
      else {
        var namedColor = colors[color];
        namedColor && ((color = namedColor), (type = "hex"));
        switch (typeof color) {
          case "string":
            type ||
              (type = (type = color.match(/^rgb|^hsb|^hsl/)) ? type[0] : "hex");
            break;
          case "object":
            type = type || "rgb";
            color = color.toString();
            break;
          case "number":
            (type = "hex"), (color = color.toString(16));
        }
        color = Color["parse" + type.toUpperCase()](color);
        this.red = color[0];
        this.green = color[1];
        this.blue = color[2];
        this.alpha = color[3];
      }
      this.isColor = !0;
    },
    listMatch = /([-.\d]+%?)\s*,\s*([-.\d]+%?)\s*,\s*([-.\d]+%?)\s*,?\s*([-.\d]*%?)/,
    hexMatch = /^#?([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{1,2})([a-f0-9]{0,2})$/i;
  Color.parseRGB = function(color) {
    return map(color.match(listMatch).slice(1), function(bit, i) {
      bit && (bit = parseFloat(bit) * ("%" == bit[bit.length - 1] ? 2.55 : 1));
      return 3 > i
        ? Math.round(0 > (bit %= 256) ? bit + 256 : bit)
        : Math.min(1, Math.max(0, "" === bit ? 1 : Number(bit)));
    });
  };
  Color.parseHEX = function(color) {
    1 == color.length && (color = color + color + color);
    return map(color.match(hexMatch).slice(1), function(bit, i) {
      return 3 == i
        ? bit
          ? parseInt(bit, 16) / 255
          : 1
        : parseInt(1 == bit.length ? bit + bit : bit, 16);
    });
  };
  Color.parseHSB = function(color) {
    var hsb = map(color.match(listMatch).slice(1), function(bit, i) {
      bit && (bit = parseFloat(bit));
      return 0 === i
        ? Math.round(0 > (bit %= 360) ? bit + 360 : bit)
        : 3 > i
          ? Math.min(100, Math.max(0, Math.round(bit)))
          : Math.min(1, Math.max(0, "" === bit ? 1 : Number(bit)));
    });
    color = hsb[3];
    var br = Math.round((hsb[2] / 100) * 255);
    if (0 == hsb[1]) return [br, br, br, color];
    var hue = hsb[0],
      f = hue % 60,
      p = Math.round(((hsb[2] * (100 - hsb[1])) / 1e4) * 255),
      q = Math.round(((hsb[2] * (6e3 - hsb[1] * f)) / 6e5) * 255);
    hsb = Math.round(((hsb[2] * (6e3 - hsb[1] * (60 - f))) / 6e5) * 255);
    switch (Math.floor(hue / 60)) {
      case 0:
        return [br, hsb, p, color];
      case 1:
        return [q, br, p, color];
      case 2:
        return [p, br, hsb, color];
      case 3:
        return [p, q, br, color];
      case 4:
        return [hsb, p, br, color];
      default:
        return [br, p, q, color];
    }
  };
  Color.parseHSL = function(color) {
    var hsb = map(color.match(listMatch).slice(1), function(bit, i) {
      bit && (bit = parseFloat(bit));
      return 0 === i
        ? Math.round(0 > (bit %= 360) ? bit + 360 : bit)
        : 3 > i
          ? Math.min(100, Math.max(0, Math.round(bit)))
          : Math.min(1, Math.max(0, "" === bit ? 1 : Number(bit)));
    });
    color = hsb[0] / 60;
    var l = hsb[2] / 100,
      a = hsb[3];
    hsb = (hsb[1] / 100) * (1 - Math.abs(2 * l - 1));
    var m = l - hsb / 2;
    l = Math.round(255 * (hsb + m));
    hsb = Math.round(255 * (hsb * (1 - Math.abs((color % 2) - 1)) + m));
    m = Math.round(255 * m);
    switch (Math.floor(color)) {
      case 0:
        return [l, hsb, m, a];
      case 1:
        return [hsb, l, m, a];
      case 2:
        return [m, l, hsb, a];
      case 3:
        return [m, hsb, l, a];
      case 4:
        return [hsb, m, l, a];
      default:
        return [l, m, hsb, a];
    }
  };
  var toString = function(type, array) {
    1 != array[3] ? (type += "a") : array.pop();
    return type + "(" + array.join(", ") + ")";
  };
  Color.prototype = {
    toHSB: function(array) {
      var red = this.red,
        green = this.green,
        blue = this.blue,
        alpha = this.alpha,
        max = Math.max(red, green, blue),
        delta = max - Math.min(red, green, blue),
        hue = 0,
        saturation = 0 != delta ? delta / max : 0;
      if (saturation) {
        hue = (max - red) / delta;
        var gr = (max - green) / delta;
        blue = (max - blue) / delta;
        hue =
          red == max ? blue - gr : green == max ? 2 + hue - blue : 4 + gr - hue;
        0 > (hue /= 6) && hue++;
      }
      red = [
        Math.round(360 * hue),
        Math.round(100 * saturation),
        Math.round((max / 255) * 100),
        alpha
      ];
      return array ? red : toString("hsb", red);
    },
    toHSL: function(array) {
      var red = this.red,
        green = this.green,
        blue = this.blue,
        alpha = this.alpha,
        max = Math.max(red, green, blue),
        min = Math.min(red, green, blue),
        delta = max - min,
        hue = 0,
        saturation = 0 != delta ? delta / (255 - Math.abs(max + min - 255)) : 0;
      if (saturation) {
        hue = (max - red) / delta;
        var gr = (max - green) / delta;
        blue = (max - blue) / delta;
        hue =
          red == max ? blue - gr : green == max ? 2 + hue - blue : 4 + gr - hue;
        0 > (hue /= 6) && hue++;
      }
      red = [
        Math.round(360 * hue),
        Math.round(100 * saturation),
        Math.round(((max + min) / 512) * 100),
        alpha
      ];
      return array ? red : toString("hsl", red);
    },
    toHEX: function(array) {
      var a = this.alpha,
        alpha = 1 == (a = Math.round(255 * a).toString(16)).length ? a + a : a;
      a = map([this.red, this.green, this.blue], function(bit) {
        bit = bit.toString(16);
        return 1 == bit.length ? "0" + bit : bit;
      });
      return array
        ? a.concat(alpha)
        : "#" + a.join("") + ("ff" == alpha ? "" : alpha);
    },
    toRGB: function(array) {
      var rgb = [this.red, this.green, this.blue, this.alpha];
      return array ? rgb : toString("rgb", rgb);
    }
  };
  Color.prototype.toString = Color.prototype.toRGB;
  Color.hex = function(hex) {
    return new Color(hex, "hex");
  };
  null == commonjsGlobal.hex && (commonjsGlobal.hex = Color.hex);
  Color.hsb = function(h, s, b, a) {
    return new Color([h || 0, s || 0, b || 0, null == a ? 1 : a], "hsb");
  };
  null == commonjsGlobal.hsb && (commonjsGlobal.hsb = Color.hsb);
  Color.hsl = function(h, s, l, a) {
    return new Color([h || 0, s || 0, l || 0, null == a ? 1 : a], "hsl");
  };
  null == commonjsGlobal.hsl && (commonjsGlobal.hsl = Color.hsl);
  Color.rgb = function(r, g, b, a) {
    return new Color([r || 0, g || 0, b || 0, null == a ? 1 : a], "rgb");
  };
  null == commonjsGlobal.rgb && (commonjsGlobal.rgb = Color.rgb);
  Color.detach = function(color) {
    color = new Color(color);
    return [
      Color.rgb(color.red, color.green, color.blue).toString(),
      color.alpha
    ];
  };
  var color$jscomp$0 = Color,
    dummy = _class({
      _resetPlacement: function() {
        var container = this.parentNode;
        if (container) {
          var previous = this.previousSibling,
            next = this.nextSibling;
          previous
            ? (previous.nextSibling = next)
            : (container.firstChild = next);
          next
            ? (next.previousSibling = previous)
            : (container.lastChild = this.previousSibling);
        }
        this.parentNode = this.nextSibling = this.previousSibling = null;
        return this;
      },
      inject: function(container) {
        this._resetPlacement();
        var last = container.lastChild;
        last
          ? ((last.nextSibling = this), (this.previousSibling = last))
          : (container.firstChild = this);
        container.lastChild = this;
        this.parentNode = container;
        this._place();
        return this;
      },
      injectBefore: function(sibling) {
        this._resetPlacement();
        var container = sibling.parentNode;
        if (!container) return this;
        var previous = sibling.previousSibling;
        previous
          ? ((previous.nextSibling = this), (this.previousSibling = previous))
          : (container.firstChild = this);
        sibling.previousSibling = this;
        this.nextSibling = sibling;
        this.parentNode = container;
        this._place();
        return this;
      },
      eject: function() {
        this._resetPlacement();
        this._place();
        return this;
      },
      _place: function() {},
      dispatch: function(event) {
        var events = this._events;
        if ((events = events && events[event.type])) {
          events = events.slice(0);
          for (var i = 0, l = events.length; i < l; i++) {
            var fn = events[i];
            !1 ===
              ("function" == typeof fn
                ? fn.call(this, event)
                : fn.handleEvent(event)) && event.preventDefault();
          }
        }
        this.parentNode &&
          this.parentNode.dispatch &&
          this.parentNode.dispatch(event);
      },
      subscribe: function(type, fn, bind) {
        if ("string" != typeof type) {
          var subscriptions = [],
            t;
          for (t in type) subscriptions.push(this.subscribe(t, type[t]));
          return function() {
            for (var i = 0, l = subscriptions.length; i < l; i++)
              subscriptions[i]();
            return this;
          };
        }
        var bound = "function" === typeof fn ? fn.bind(bind || this) : fn;
        fn = this._events || (this._events = {});
        var listeners = fn[type] || (fn[type] = []);
        listeners.push(bound);
        return function() {
          for (var i = 0, l = listeners.length; i < l; i++)
            if (listeners[i] === bound) {
              listeners.splice(i, 1);
              break;
            }
        };
      }
    }),
    node = _class(transform, dummy, {
      invalidate: function() {
        this.parentNode && this.parentNode.invalidate();
        this._layer && (this._layerCache = null);
        return this;
      },
      _place: function() {
        this.invalidate();
      },
      _transform: function() {
        this.invalidate();
      },
      blend: function(opacity) {
        1 <= opacity && this._layer && (this._layer = null);
        this._opacity = opacity;
        this.parentNode && this.parentNode.invalidate();
        return this;
      },
      hide: function() {
        this._invisible = !0;
        this.parentNode && this.parentNode.invalidate();
        return this;
      },
      show: function() {
        this._invisible = !1;
        this.parentNode && this.parentNode.invalidate();
        return this;
      },
      indicate: function(cursor, tooltip) {
        this._cursor = cursor;
        this._tooltip = tooltip;
        return this.invalidate();
      },
      hitTest: function(x, y) {
        return this._invisible
          ? null
          : (x = this.inversePoint(x, y))
            ? this.localHitTest(x.x, x.y)
            : null;
      },
      renderTo: function(context, xx, yx, xy, yy, x, y) {
        var opacity = this._opacity;
        if (null == opacity || 1 <= opacity)
          return this.renderLayerTo(context, xx, yx, xy, yy, x, y);
        var layer = this._layer,
          isDirty = !0,
          w = context.canvas.width,
          h = context.canvas.height;
        if (layer) {
          layer.setTransform(1, 0, 0, 1, 0, 0);
          var canvas = layer.canvas;
          if (canvas.width < w || canvas.height < h)
            (canvas.width = w), (canvas.height = h);
          else {
            var c = this._layerCache;
            c &&
            c.xx === xx &&
            c.yx === yx &&
            c.xy === xy &&
            c.yy === yy &&
            c.x === x &&
            c.y === y
              ? (isDirty = !1)
              : layer.clearRect(0, 0, w, h);
          }
        } else
          (canvas = document.createElement("canvas")),
            (canvas.width = w),
            (canvas.height = h),
            (this._layer = layer = canvas.getContext("2d"));
        isDirty &&
          (this.renderLayerTo(layer, xx, yx, xy, yy, x, y),
          (this._layerCache = { xx: xx, yx: yx, xy: xy, yy: yy, x: x, y: y }));
        context.globalAlpha = opacity;
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.drawImage(canvas, 0, 0, w, h, 0, 0, w, h);
        context.globalAlpha = 1;
      }
    }),
    genericCanvas =
      "undefined" !== typeof document && document.createElement("canvas"),
    genericContext =
      genericCanvas &&
      genericCanvas.getContext &&
      genericCanvas.getContext("2d"),
    Base = _class(node, {
      initialize: function() {
        this._strokeWidth = this._strokeJoin = this._strokeDash = this._strokeCap = this._stroke = this._fillTransform = this._pendingFill = this._fill = null;
      },
      _addColors: function(gradient, stops) {
        if ("length" in stops)
          for (var i = 0, l = stops.length - 1; i <= l; i++)
            gradient.addColorStop(
              i / l,
              new color$jscomp$0(stops[i]).toString()
            );
        else
          for (i in stops)
            gradient.addColorStop(i, new color$jscomp$0(stops[i]).toString());
        return gradient;
      },
      fill: function(color$$1) {
        if (1 < arguments.length) return this.fillLinear(arguments);
        this._pendingFill && this._pendingFill();
        this._fill = color$$1 ? new color$jscomp$0(color$$1).toString() : null;
        return this.invalidate();
      },
      fillRadial: function(
        stops,
        focusX,
        focusY,
        radiusX,
        radiusY,
        centerX,
        centerY
      ) {
        null == focusX && (focusX = (this.left || 0) + 0.5 * (this.width || 0));
        null == focusY && (focusY = (this.top || 0) + 0.5 * (this.height || 0));
        null == radiusY && (radiusY = radiusX || 0.5 * this.height || 0);
        null == radiusX && (radiusX = 0.5 * (this.width || 0));
        null == centerX && (centerX = focusX);
        null == centerY && (centerY = focusY);
        centerX += centerX - focusX;
        centerY += centerY - focusY;
        if (0 === radiusX || "0" === radiusX) return this.fillLinear(stops);
        radiusY /= radiusX;
        this._pendingFill && this._pendingFill();
        focusX = genericContext.createRadialGradient(
          focusX,
          focusY / radiusY,
          0,
          centerX,
          centerY / radiusY,
          2 * radiusX
        );
        if ("length" in stops) {
          var i = 0;
          for (focusY = stops.length - 1; i <= focusY; i++)
            focusX.addColorStop(
              i / focusY / 2,
              new color$jscomp$0(stops[i]).toString()
            ),
              focusX.addColorStop(
                1 - i / focusY / 2,
                new color$jscomp$0(stops[i]).toString()
              );
        } else
          for (i in stops)
            focusX.addColorStop(i / 2, new color$jscomp$0(stops[i]).toString()),
              focusX.addColorStop(
                1 - i / 2,
                new color$jscomp$0(stops[i]).toString()
              );
        this._fill = focusX;
        this._fillTransform = new transform(1, 0, 0, radiusY);
        return this.invalidate();
      },
      fillLinear: function(stops, x1, y1, x2, y2) {
        if (5 > arguments.length) {
          var angle = ((null == x1 ? 270 : x1) * Math.PI) / 180,
            x = Math.cos(angle);
          angle = -Math.sin(angle);
          var l = (Math.abs(x) + Math.abs(angle)) / 2,
            w = this.width || 1,
            h = this.height || 1;
          x *= l;
          angle *= l;
          x1 = 0.5 - x;
          x2 = 0.5 + x;
          y1 = 0.5 - angle;
          y2 = 0.5 + angle;
          this._fillTransform = new transform(w, 0, 0, h);
        } else this._fillTransform = null;
        this._pendingFill && this._pendingFill();
        x = genericContext.createLinearGradient(x1, y1, x2, y2);
        this._addColors(x, stops);
        this._fill = x;
        return this.invalidate();
      },
      fillImage: function(url, width, height, left, top, color1, color2) {
        this._pendingFill && this._pendingFill();
        var img = url;
        img instanceof Image || ((img = new Image()), (img.src = url));
        if (img.width && img.height)
          return this._fillImage(
            img,
            width,
            height,
            left || 0,
            top || 0,
            color1,
            color2
          );
        this._fill = null;
        var self = this,
          callback = function() {
            cancel();
            self._fillImage(
              img,
              width,
              height,
              left || 0,
              top || 0,
              color1,
              color2
            );
          },
          cancel = function() {
            img.removeEventListener("load", callback, !1);
            self._pendingFill = null;
          };
        this._pendingFill = cancel;
        img.addEventListener("load", callback, !1);
        return this;
      },
      _fillImage: function(img, width, height, left, top, color1, color2) {
        width = width ? width / img.width : 1;
        height = height ? height / img.height : 1;
        if (null != color1) {
          color$jscomp$0.detach(color1);
          color2 = color$jscomp$0.detach(color2);
          color1 = document.createElement("canvas");
          var context = color1.getContext("2d");
          color1.width = img.width;
          color1.height = img.height;
          context.fillStyle = color2[0];
          context.fillRect(0, 0, img.width, img.height);
          context.globalCompositeOperation = "lighter";
          context.drawImage(img, 0, 0);
          img = color1;
        }
        this._fill = genericContext.createPattern(img, "repeat");
        this._fillTransform = new transform(
          width,
          0,
          0,
          height,
          left || 0,
          top || 0
        );
        return this.invalidate();
      },
      stroke: function(color$$1, width, cap, join, dash) {
        this._stroke = color$$1
          ? new color$jscomp$0(color$$1).toString()
          : null;
        this._strokeWidth = null != width ? width : 1;
        this._strokeCap = null != cap ? cap : "round";
        this._strokeJoin = null != join ? join : "round";
        this._strokeDash = dash;
        return this.invalidate();
      },
      element_renderTo: node.prototype.renderTo,
      renderTo: function(context, xx, yx, xy, yy, x, y) {
        var opacity = this._opacity;
        if (null == opacity || 1 <= opacity)
          return this.renderLayerTo(context, xx, yx, xy, yy, x, y);
        if (this._fill && this._stroke)
          return this.element_renderTo(context, xx, yx, xy, yy, x, y);
        context.globalAlpha = opacity;
        xx = this.renderLayerTo(context, xx, yx, xy, yy, x, y);
        context.globalAlpha = 1;
        return xx;
      },
      renderLayerTo: function(context, xx, yx, xy, yy, x, y) {
        context.setTransform(xx, yx, xy, yy, x, y);
        this.renderShapeTo(context);
      }
    });
  Base._genericContext = genericContext;
  var shape = _class(Base, {
      base_initialize: Base.prototype.initialize,
      initialize: function(path$$1, width, height) {
        this.base_initialize();
        this.width = width;
        this.height = height;
        null != path$$1 && this.draw(path$$1);
      },
      draw: function(path$$1, width, height) {
        path$$1 instanceof path || (path$$1 = new path(path$$1));
        this.path = path$$1;
        this._commands = path$$1.toCommands();
        null != width && (this.width = width);
        null != height && (this.height = height);
        return this.invalidate();
      },
      localHitTest: function(x, y) {
        if (!this._fill) return null;
        if (null == this.width || null == this.height) {
          var context = Base._genericContext,
            commands = this._commands;
          if (!commands) return null;
          context.beginPath();
          for (var i = 0, l = commands.length; i < l; i++) commands[i](context);
          return context.isPointInPath(x, y) ? this : null;
        }
        return 0 < x && 0 < y && x < this.width && y < this.height
          ? this
          : null;
      },
      renderShapeTo: function(context) {
        if (
          this._invisible ||
          !this._commands ||
          (!this._fill && !this._stroke)
        )
          return null;
        context.transform(this.xx, this.yx, this.xy, this.yy, this.x, this.y);
        var commands = this._commands,
          fill = this._fill,
          stroke = this._stroke,
          dash = this._strokeDash;
        context.beginPath();
        dash
          ? context.setLineDash
            ? context.setLineDash(dash)
            : (context.mozDash = dash)
          : context.setLineDash
            ? context.setLineDash([])
            : (context.mozDash = null);
        dash = 0;
        for (var l = commands.length; dash < l; dash++) commands[dash](context);
        fill &&
          ((commands = this._fillTransform)
            ? (context.save(),
              context.transform(
                commands.xx,
                commands.yx,
                commands.xy,
                commands.yy,
                commands.x,
                commands.y
              ),
              (context.fillStyle = fill),
              context.fill(),
              context.restore())
            : ((context.fillStyle = fill), context.fill()));
        stroke &&
          ((context.strokeStyle = stroke),
          (context.lineWidth = this._strokeWidth),
          (context.lineCap = this._strokeCap),
          (context.lineJoin = this._strokeJoin),
          context.stroke());
      }
    }),
    group = _class(node, container, {
      initialize: function(width, height) {
        this.width = width;
        this.height = height;
      },
      localHitTest: function(x, y) {
        for (var node$$2 = this.lastChild; node$$2; ) {
          var hit = node$$2.hitTest(x, y);
          if (hit) return hit;
          node$$2 = node$$2.previousSibling;
        }
        return null;
      },
      renderLayerTo: function(context, xx, yx, xy, yy, x, y) {
        if (!this._invisible) {
          x = xx * this.x + xy * this.y + x;
          y = yx * this.x + yy * this.y + y;
          var t = xx;
          xx = t * this.xx + xy * this.yx;
          xy = t * this.xy + xy * this.yy;
          t = yx;
          yx = t * this.xx + yy * this.yx;
          yy = t * this.xy + yy * this.yy;
          for (t = this.firstChild; t; )
            t.renderTo(context, xx, yx, xy, yy, x, y), (t = t.nextSibling);
        }
      }
    }),
    clippingrectangle = _class(node, container, {
      initialize: function(width, height) {
        this.width = width;
        this.height = height;
      },
      localHitTest: function(x, y) {
        for (var node$$2 = this.lastChild; node$$2; ) {
          var hit = node$$2.hitTest(x, y);
          if (hit) return hit;
          node$$2 = node$$2.previousSibling;
        }
        return null;
      },
      renderLayerTo: function(context, xx, yx, xy, yy, x, y) {
        context.setTransform(xx, yx, xy, yy, x, y);
        context.save();
        context.beginPath();
        context.rect(this.x, this.y, this.width, this.height);
        context.clip();
        for (var node$$2 = this.firstChild; node$$2; )
          node$$2.renderTo(context, xx, yx, xy, yy, x, y),
            (node$$2 = node$$2.nextSibling);
        context.restore();
      }
    }),
    fontAnchors = { middle: "center" },
    text = _class(Base, {
      base_initialize: Base.prototype.initialize,
      initialize: function(text, font, alignment, path) {
        this.base_initialize();
        this.draw.apply(this, arguments);
      },
      draw: function(text, font, alignment, path) {
        if ("string" == typeof font) var em = Number(/(\d+)/.exec(font)[0]);
        else
          font
            ? ((em = parseFloat(font.fontSize || font["font-size"] || "12")),
              (font =
                (font.fontStyle || font["font-style"] || "") +
                " " +
                (font.fontVariant || font["font-variant"] || "") +
                " " +
                (font.fontWeight || font["font-weight"] || "") +
                " " +
                em +
                "px " +
                (font.fontFamily || font["font-family"] || "Arial")))
            : (font = this._font);
        text = text && text.split(/\r?\n/);
        this._font = font;
        this._fontSize = em;
        this._text = text;
        this._alignment = fontAnchors[alignment] || alignment || "left";
        font = Base._genericContext;
        font.font = this._font;
        font.textAlign = this._alignment;
        font.textBaseline = "middle";
        text = this._text;
        alignment = text.length;
        for (var i = (path = 0); i < alignment; i++) {
          var w = font.measureText(text[i]).width;
          w > path && (path = w);
        }
        this.width = path;
        this.height = alignment ? 1.1 * alignment * em : 0;
        return this.invalidate();
      },
      localHitTest: function(x, y) {
        return this._fill
          ? 0 < x && 0 < y && x < this.width && y < this.height
            ? this
            : null
          : null;
      },
      renderShapeTo: function(context) {
        if (this._invisible || !this._text || (!this._fill && !this._stroke))
          return null;
        context.transform(this.xx, this.yx, this.xy, this.yy, this.x, this.y);
        var fill = this._fill,
          stroke = this._stroke,
          text = this._text,
          dash = this._strokeDash;
        context.font = this._font;
        context.textAlign = this._alignment;
        context.textBaseline = "middle";
        var em = this._fontSize,
          y = em / 2;
        em *= 1.1;
        var l = text.length;
        if (fill)
          for (context.fillStyle = fill, fill = 0; fill < l; fill++)
            context.fillText(text[fill], 0, y + fill * em);
        if (stroke)
          for (
            dash
              ? context.setLineDash
                ? context.setLineDash(dash)
                : (context.mozDash = dash)
              : context.setLineDash
                ? context.setLineDash([])
                : (context.mozDash = null),
              context.strokeStyle = stroke,
              context.lineWidth = this._strokeWidth,
              context.lineCap = this._strokeCap,
              context.lineJoin = this._strokeJoin,
              fill = 0;
            fill < l;
            fill++
          )
            context.strokeText(text[fill], 0, y + fill * em);
      }
    }),
    styleSheet,
    styledTags = {},
    styleTag = function(tag) {
      styleSheet &&
        (styledTags[tag] = styleSheet.addRule(
          "av\\:" + tag,
          "behavior:url(#default#VML);display:inline-block;position:absolute;left:0px;top:0px;"
        ));
    },
    dom = {
      init: function(document) {
        try {
          var namespaces = document.namespaces;
        } catch (e) {}
        if (!namespaces) return !1;
        namespaces.add("av", "urn:schemas-microsoft-com:vml");
        namespaces.add("ao", "urn:schemas-microsoft-com:office:office");
        styleSheet = document.createStyleSheet();
        styleSheet.addRule(
          "vml",
          "display:inline-block;position:relative;overflow:hidden;"
        );
        styleTag("vml");
        return !0;
      },
      createElement: function(tag) {
        tag in styledTags || styleTag(tag);
        return document.createElement("av:" + tag);
      }
    },
    VMLSurface = _class(native_1, container, {
      initialize: function(width, height, existingElement) {
        this.element = existingElement || document.createElement("vml");
        this.containerElement = dom.createElement("group");
        this.element.appendChild(this.containerElement);
        null != width && null != height && this.resize(width, height);
      },
      resize: function(width, height) {
        this.width = width;
        this.height = height;
        var style = this.element.style;
        style.pixelWidth = width;
        style.pixelHeight = height;
        style = this.containerElement.style;
        style.width = width;
        style.height = height;
        this.containerElement.coordorigin = "50,50";
        this.containerElement.coordsize = 100 * width + "," + 100 * height;
        return this;
      }
    });
  VMLSurface.tagName = "av:vml";
  var round = Math.round,
    VMLPath = _class(path$2, {
      initialize: function(path) {
        this.reset();
        path instanceof VMLPath
          ? (this.path = [Array.prototype.join.call(path.path, " ")])
          : path &&
            (path.applyToPath ? path.applyToPath(this) : this.push(path));
      },
      onReset: function() {
        this.path = [];
      },
      onMove: function(sx, sy, x, y) {
        this.path.push("m", round(100 * x), round(100 * y));
      },
      onLine: function(sx, sy, x, y) {
        this.path.push("l", round(100 * x), round(100 * y));
      },
      onBezierCurve: function(sx, sy, p1x, p1y, p2x, p2y, x, y) {
        this.path.push(
          "c",
          round(100 * p1x),
          round(100 * p1y),
          round(100 * p2x),
          round(100 * p2y),
          round(100 * x),
          round(100 * y)
        );
      },
      _arcToBezier: path$2.prototype.onArc,
      onArc: function(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
        if (rx != ry || rotation)
          return this._arcToBezier(
            sx,
            sy,
            ex,
            ey,
            cx,
            cy,
            rx,
            ry,
            sa,
            ea,
            ccw,
            rotation
          );
        cx *= 100;
        cy *= 100;
        rx *= 100;
        this.path.push(
          ccw ? "at" : "wa",
          round(cx - rx),
          round(cy - rx),
          round(cx + rx),
          round(cy + rx),
          round(100 * sx),
          round(100 * sy),
          round(100 * ex),
          round(100 * ey)
        );
      },
      onClose: function() {
        this.path.push("x");
      },
      toVML: function() {
        return this.path.join(" ");
      }
    });
  VMLPath.prototype.toString = VMLPath.prototype.toVML;
  var path$4 = VMLPath,
    shadow = _class(dummy, native_1, {
      dummy_inject: dummy.prototype.inject,
      dummy_injectBefore: dummy.prototype.injectBefore,
      dummy_eject: dummy.prototype.eject,
      native_inject: native_1.prototype.inject,
      native_injectBefore: native_1.prototype.injectBefore,
      native_eject: native_1.prototype.eject,
      inject: function(container) {
        this.dummy_inject(container);
        this.native_inject(container);
        return this;
      },
      injectBefore: function(sibling) {
        this.dummy_injectBefore(sibling);
        this.native_injectBefore(sibling);
        return this;
      },
      eject: function() {
        this.dummy_eject();
        this.native_eject();
        return this;
      }
    }),
    node$2 = _class(shadow, transform, {
      initialize: function(tag) {
        this.element = dom.createElement(tag);
      },
      _place: function() {
        this.parentNode && this._transform();
      },
      hide: function() {
        this.element.style.display = "none";
        return this;
      },
      show: function() {
        this.element.style.display = "";
        return this;
      },
      indicate: function(cursor, tooltip) {
        cursor && (this.element.style.cursor = cursor);
        tooltip && (this.element.title = tooltip);
        return this;
      }
    }),
    defaultBox = { left: 0, top: 0, width: 500, height: 500 },
    base$2 = _class(node$2, {
      element_initialize: node$2.prototype.initialize,
      initialize: function(tag) {
        this.element_initialize(tag);
        tag = this.element;
        var skew = (this.skewElement = dom.createElement("skew"));
        skew.on = !0;
        tag.appendChild(skew);
        skew = this.fillElement = dom.createElement("fill");
        skew.on = !1;
        tag.appendChild(skew);
        skew = this.strokeElement = dom.createElement("stroke");
        skew.on = !1;
        tag.appendChild(skew);
      },
      _transform: function() {
        var container = this.parentNode,
          m = container
            ? new transform(container._activeTransform).transform(this)
            : this,
          box = this._boxCoords || this._size || defaultBox;
        container = box.left || 0;
        var originY = box.top || 0,
          width = box.width || 1;
        box = box.height || 1;
        var flip = m.yx / m.xx > m.yy / m.xy;
        if (0 > m.xx ? 0 <= m.xy : 0 > m.xy) flip = !flip;
        flip = flip ? -1 : 1;
        m = new transform().scale(flip, 1).transform(m);
        var rotation = (180 * Math.atan2(-m.xy, m.yy)) / Math.PI,
          rad = (rotation * Math.PI) / 180,
          sin = Math.sin(rad);
        rad = Math.cos(rad);
        sin = new transform(
          m.xx * rad - m.xy * sin,
          (m.yx * rad - m.yy * sin) * flip,
          (m.xy * rad + m.xx * sin) * flip,
          m.yy * rad + m.yx * sin
        );
        var rotationTransform = new transform().rotate(rotation, 0, 0),
          shapeToBox = new transform()
            .rotate(-rotation, 0, 0)
            .transform(m)
            .moveTo(0, 0);
        width *= Math.abs(shapeToBox.xx);
        box *= Math.abs(shapeToBox.yy);
        rad = m.x;
        var top = m.y,
          vx = -width / 2,
          vy = -box / 2,
          point = rotationTransform.point(vx, vy);
        rad -= point.x - vx;
        top -= point.y - vy;
        var rsm = new transform(m).moveTo(0, 0);
        point = rsm.point(container, originY);
        rad += point.x;
        top += point.y;
        0 > flip && (rad = -rad - width);
        rsm = rsm.point(-container, -originY);
        vx = rotationTransform.point(width, box);
        vy = rotationTransform.point(width, 0);
        point = rotationTransform.point(0, box);
        rotationTransform =
          ((rsm.x - vx.x / 2) /
            (Math.max(0, vx.x, vy.x, point.x) -
              Math.min(0, vx.x, vy.x, point.x))) *
          flip;
        rsm =
          (rsm.y - vx.y / 2) /
          (Math.max(0, vx.y, vy.y, point.y) - Math.min(0, vx.y, vy.y, point.y));
        point = shapeToBox.point(container, originY);
        container = point.x;
        originY = point.y;
        if ((shapeToBox = this._strokeWidth))
          (vx = m.xx + m.xy),
            (vy = m.yy + m.yx),
            (shapeToBox *= Math.sqrt(vx * vx + vy * vy) / Math.sqrt(2));
        width *= 100;
        box *= 100;
        m = this.element;
        m.coordorigin = 100 * container + "," + 100 * originY;
        m.coordsize = width + "," + box;
        m.style.left = 100 * rad + "px";
        m.style.top = 100 * top + "px";
        m.style.width = width;
        m.style.height = box;
        m.style.rotation = rotation.toFixed(8);
        m.style.flip = 0 > flip ? "x" : "";
        container = this.skewElement;
        container.matrix = [
          sin.xx.toFixed(4),
          sin.xy.toFixed(4),
          sin.yx.toFixed(4),
          sin.yy.toFixed(4),
          0,
          0
        ];
        container.origin = rotationTransform + "," + rsm;
        this.strokeElement.weight = shapeToBox + "px";
      },
      _createGradient: function(style, stops) {
        var fill = this.fillElement;
        this.element.removeChild(fill);
        fill.type = style;
        fill.method = "none";
        fill.rotate = !0;
        var colors = [],
          color1,
          color2;
        style = function(offset, color$$2) {
          color$$2 = color$jscomp$0.detach(color$$2);
          null == color1 ? (color1 = color2 = color$$2) : (color2 = color$$2);
          colors.push(offset + " " + color$$2[0]);
        };
        if ("length" in stops)
          for (var i = 0, l = stops.length - 1; i <= l; i++)
            style(i / l, stops[i]);
        else for (i in stops) style(i, stops[i]);
        fill.color = color1[0];
        fill.color2 = color2[0];
        fill.colors = colors;
        fill.opacity = color2[1];
        fill["ao:opacity2"] = color1[1];
        fill.on = !0;
        this.element.appendChild(fill);
        return fill;
      },
      _setColor: function(type, color$$2) {
        type = "fill" == type ? this.fillElement : this.strokeElement;
        null == color$$2
          ? (type.on = !1)
          : ((color$$2 = color$jscomp$0.detach(color$$2)),
            (type.color = color$$2[0]),
            (type.opacity = color$$2[1]),
            (type.on = !0));
      },
      fill: function(color$$2) {
        if (1 < arguments.length) this.fillLinear(arguments);
        else {
          this._boxCoords = defaultBox;
          var fill = this.fillElement;
          fill.type = "solid";
          fill.color2 = "";
          fill["ao:opacity2"] = "";
          fill.colors && (fill.colors.value = "");
          this._setColor("fill", color$$2);
        }
        return this;
      },
      fillRadial: function(
        stops,
        focusX,
        focusY,
        radiusX,
        radiusY,
        centerX,
        centerY
      ) {
        stops = this._createGradient("gradientradial", stops);
        null == focusX && (focusX = this.left + 0.5 * this.width);
        null == focusY && (focusY = this.top + 0.5 * this.height);
        null == radiusY && (radiusY = radiusX || 0.5 * this.height);
        null == radiusX && (radiusX = 0.5 * this.width);
        null == centerX && (centerX = focusX);
        null == centerY && (centerY = focusY);
        radiusX = this._boxCoords = {
          left: centerX + (centerX - focusX) - 2 * radiusX,
          top: centerY + (centerY - focusY) - 2 * radiusY,
          width: 4 * radiusX,
          height: 4 * radiusY
        };
        focusX -= radiusX.left;
        focusY -= radiusX.top;
        focusX /= radiusX.width;
        focusY /= radiusX.height;
        stops.focussize = "0 0";
        stops.focusposition = focusX + "," + focusY;
        stops.focus = "50%";
        this._transform();
        return this;
      },
      fillLinear: function(stops, x1, y1, x2, y2) {
        var fill = this._createGradient("gradient", stops);
        fill.focus = "100%";
        if (5 == arguments.length) {
          var w = Math.abs(x2 - x1),
            h = Math.abs(y2 - y1);
          this._boxCoords = {
            left: Math.min(x1, x2),
            top: Math.min(y1, y2),
            width: 1 > w ? h : w,
            height: 1 > h ? w : h
          };
          fill.angle =
            (360 + (180 * Math.atan2((x2 - x1) / h, (y2 - y1) / w)) / Math.PI) %
            360;
        } else
          (this._boxCoords = null),
            (fill.angle = null == x1 ? 0 : (90 + x1) % 360);
        this._transform();
        return this;
      },
      fillImage: function(url, width, height, left, top, color1, color2) {
        var fill = this.fillElement;
        null != color1
          ? ((color1 = color$jscomp$0.detach(color1)),
            null != color2 && (color2 = color$jscomp$0.detach(color2)),
            (fill.type = "pattern"),
            (fill.color = color1[0]),
            (fill.color2 = null == color2 ? color1[0] : color2[0]),
            (fill.opacity = null == color2 ? 0 : color2[1]),
            (fill["ao:opacity2"] = color1[1]))
          : ((fill.type = "tile"),
            (fill.color = ""),
            (fill.color2 = ""),
            (fill.opacity = 1),
            (fill["ao:opacity2"] = 1));
        fill.colors && (fill.colors.value = "");
        fill.rotate = !0;
        fill.src = url;
        fill.size = "1,1";
        fill.position = "0,0";
        fill.origin = "0,0";
        fill.aspect = "ignore";
        fill.on = !0;
        left || (left = 0);
        top || (top = 0);
        this._boxCoords = width
          ? { left: left + 0.5, top: top + 0.5, width: width, height: height }
          : null;
        this._transform();
        return this;
      },
      stroke: function(color$$2, width, cap, join) {
        var stroke = this.strokeElement;
        this._strokeWidth = null != width ? width : 1;
        stroke.weight = null != width ? width + "px" : 1;
        stroke.endcap = null != cap ? ("butt" == cap ? "flat" : cap) : "round";
        stroke.joinstyle = null != join ? join : "round";
        this._setColor("stroke", color$$2);
        return this;
      }
    }),
    shape$2 = _class(base$2, {
      base_initialize: base$2.prototype.initialize,
      initialize: function(path, width, height) {
        this.base_initialize("shape");
        var p = (this.pathElement = dom.createElement("path"));
        p.gradientshapeok = !0;
        this.element.appendChild(p);
        this.width = width;
        this.height = height;
        null != path && this.draw(path);
      },
      draw: function(path, width, height) {
        path instanceof path$4 || (path = new path$4(path));
        this._vml = path.toVML();
        null != width && (this.width = width);
        null != height && (this.height = height);
        this._boxCoords || this._transform();
        this._redraw(this._prefix, this._suffix);
        return this;
      },
      _redraw: function(prefix, suffix) {
        var vml = this._vml || "";
        this._prefix = prefix;
        this._suffix = suffix;
        prefix && (vml = [prefix, vml, suffix, "ns e", vml, "nf"].join(" "));
        this.element.path = vml + "e";
      },
      fillRadial: function(
        stops,
        focusX,
        focusY,
        radiusX,
        radiusY,
        centerX,
        centerY
      ) {
        stops = this._createGradient("gradientradial", stops);
        null == focusX && (focusX = (this.left || 0) + 0.5 * (this.width || 0));
        null == focusY && (focusY = (this.top || 0) + 0.5 * (this.height || 0));
        null == radiusY && (radiusY = radiusX || 0.5 * this.height || 0);
        null == radiusX && (radiusX = 0.5 * (this.width || 0));
        null == centerX && (centerX = focusX);
        null == centerY && (centerY = focusY);
        centerX = Math.round(100 * (centerX + (centerX - focusX)));
        centerY = Math.round(100 * (centerY + (centerY - focusY)));
        radiusX = Math.round(200 * radiusX);
        radiusY = Math.round(200 * radiusY);
        radiusX = [
          "wa",
          centerX - radiusX,
          centerY - radiusY,
          centerX + radiusX,
          centerY + radiusY
        ].join(" ");
        this._redraw(
          [
            "m",
            centerX,
            centerY - radiusY,
            "l",
            centerX,
            centerY - radiusY
          ].join(" "),
          [
            "m",
            centerX,
            centerY - radiusY,
            radiusX,
            centerX,
            centerY - radiusY,
            centerX,
            centerY + radiusY,
            radiusX,
            centerX,
            centerY + radiusY,
            centerX,
            centerY - radiusY,
            radiusX,
            centerX,
            centerY - radiusY,
            centerX,
            centerY + radiusY,
            radiusX,
            centerX,
            centerY + radiusY,
            centerX,
            centerY - radiusY
          ].join(" ")
        );
        this._boxCoords = {
          left: focusX - 2,
          top: focusY - 2,
          width: 4,
          height: 4
        };
        stops.focusposition = "0.5,0.5";
        stops.focussize = "0 0";
        stops.focus = "50%";
        this._transform();
        return this;
      }
    }),
    group$2 = _class(node$2, container, {
      element_initialize: node$2.prototype.initialize,
      initialize: function(width, height) {
        this.element_initialize("group");
        this.width = width;
        this.height = height;
      },
      _transform: function() {
        var element = this.element;
        element.coordorigin = "0,0";
        element.coordsize = "1000,1000";
        element.style.left = 0;
        element.style.top = 0;
        element.style.width = 1e3;
        element.style.height = 1e3;
        element.style.rotation = 0;
        this._activeTransform = (element = this.parentNode)
          ? new transform(element._activeTransform).transform(this)
          : this;
        for (element = this.firstChild; element; )
          element._transform(), (element = element.nextSibling);
      }
    }),
    clippingrectangle$2 = _class(node$2, container, {
      element_initialize: node$2.prototype.initialize,
      initialize: function(width, height) {
        this.element_initialize("clippingrectangle");
        this.width = width;
        this.height = height;
      },
      _transform: function() {
        var element = this.element;
        element.clip = !0;
        element.coordorigin = -this.x + "," + -1 * this.y;
        element.coordsize = this.width + "," + this.height;
        element.style.clipLeft = this.x;
        element.style.clipRight = this.width + this.x;
        element.style.clipTop = this.y;
        element.style.left = -this.x;
        element.style.top = -this.y;
        element.style.width = this.width + this.x;
        element.style.height = this.height + this.y;
        element.style.rotation = 0;
        this._activeTransform = (element = this.parentNode)
          ? new transform(element._activeTransform).transform(this)
          : this;
        for (element = this.firstChild; element; )
          element._transform(), (element = element.nextSibling);
      }
    }),
    fontAnchors$1 = {
      start: "left",
      middle: "center",
      end: "right"
    },
    text$2 = _class(base$2, {
      base_initialize: base$2.prototype.initialize,
      initialize: function(text, font, alignment, path) {
        this.base_initialize("shape");
        var p = (this.pathElement = dom.createElement("path"));
        p.textpathok = !0;
        this.element.appendChild(p);
        p = this.textPathElement = dom.createElement("textpath");
        p.on = !0;
        p.style["v-text-align"] = "left";
        this.element.appendChild(p);
        this.draw.apply(this, arguments);
      },
      draw: function(text, font, alignment, path) {
        var element = this.element,
          textPath = this.textPathElement,
          style = textPath.style;
        textPath.string = text;
        if (font)
          if ("string" == typeof font) style.font = font;
          else
            for (var key in font) {
              var ckey = key.camelCase ? key.camelCase() : key;
              style[ckey] =
                "fontFamily" == ckey ? "'" + font[key] + "'" : font[key];
            }
        alignment &&
          (style["v-text-align"] = fontAnchors$1[alignment] || alignment);
        if (path)
          (this.currentPath = path = new path$4(path)),
            (this.element.path = path.toVML());
        else if (!this.currentPath) {
          font = -1;
          for (alignment = "\n"; -1 < (font = text.indexOf("\n", font + 1)); )
            alignment += "\n";
          textPath.string = alignment + textPath.string;
          this.element.path = "m0,0l1,0";
        }
        element = element.cloneNode(!0);
        style = element.style;
        element.coordorigin = "0,0";
        element.coordsize = "10000,10000";
        style.left = "0px";
        style.top = "0px";
        style.width = "10000px";
        style.height = "10000px";
        style.rotation = 0;
        element.removeChild(element.firstChild);
        text = new VMLSurface(1, 1);
        textPath = new group$2();
        text.inject(element.ownerDocument.body);
        textPath.element.appendChild(element);
        textPath.inject(text);
        element = element.getBoundingClientRect();
        textPath = text.toElement().getBoundingClientRect();
        text.eject();
        this.left = element.left - textPath.left;
        this.top = element.top - textPath.top;
        this.width = element.right - element.left;
        this.height = element.bottom - element.top;
        this.right = element.right - textPath.left;
        this.bottom = element.bottom - textPath.top;
        this._transform();
        return this;
      }
    }),
    fastNoSideEffects = createCommonjsModule(function(module, exports) {
      (module = document.createElement("canvas")) && module.getContext
        ? ((exports.Surface = CanvasSurface),
          (exports.Path = path),
          (exports.Shape = shape),
          (exports.Group = group),
          (exports.ClippingRectangle = clippingrectangle),
          (exports.Text = text))
        : ((exports.Surface = VMLSurface),
          (exports.Path = path$4),
          (exports.Shape = shape$2),
          (exports.Group = group$2),
          (exports.ClippingRectangle = clippingrectangle$2),
          (exports.Text = text$2),
          "undefined" !== typeof document && dom.init(document));
    });
  current.setCurrent(fastNoSideEffects);
  var slice = Array.prototype.slice,
    LinearGradient = (function() {
      function LinearGradient(stops, x1, y1, x2, y2) {
        this._args = slice.call(arguments);
      }
      LinearGradient.prototype.applyFill = function(node) {
        node.fillLinear.apply(node, this._args);
      };
      return LinearGradient;
    })(),
    RadialGradient = (function() {
      function RadialGradient(stops, fx, fy, rx, ry, cx, cy) {
        this._args = slice.call(arguments);
      }
      RadialGradient.prototype.applyFill = function(node) {
        node.fillRadial.apply(node, this._args);
      };
      return RadialGradient;
    })(),
    Pattern = (function() {
      function Pattern(url, width, height, left, top) {
        this._args = slice.call(arguments);
      }
      Pattern.prototype.applyFill = function(node) {
        node.fillImage.apply(node, this._args);
      };
      return Pattern;
    })(),
    Surface = (function(_React$Component) {
      function Surface() {
        return _React$Component.apply(this, arguments) || this;
      }
      _inheritsLoose(Surface, _React$Component);
      var _proto4 = Surface.prototype;
      _proto4.componentDidMount = function() {
        var _this$props = this.props;
        this._surface = current.Surface(
          +_this$props.width,
          +_this$props.height,
          this._tagRef
        );
        _this$props = new FiberRootNode(this._surface, 0, !1);
        var uninitializedFiber = createFiber(3, null, null, 0);
        _this$props.current = uninitializedFiber;
        this._mountNode = uninitializedFiber.stateNode = _this$props;
        updateContainer(this.props.children, this._mountNode, this);
      };
      _proto4.componentDidUpdate = function(prevProps, prevState) {
        prevState = this.props;
        (prevState.height === prevProps.height &&
          prevState.width === prevProps.width) ||
          this._surface.resize(+prevState.width, +prevState.height);
        updateContainer(this.props.children, this._mountNode, this);
        this._surface.render && this._surface.render();
      };
      _proto4.componentWillUnmount = function() {
        updateContainer(null, this._mountNode, this);
      };
      _proto4.render = function() {
        var _this = this,
          props = this.props;
        return React.createElement(current.Surface.tagName, {
          ref: function(ref) {
            return (_this._tagRef = ref);
          },
          accessKey: props.accessKey,
          className: props.className,
          draggable: props.draggable,
          role: props.role,
          style: props.style,
          tabIndex: props.tabIndex,
          title: props.title
        });
      };
      return Surface;
    })(React.Component),
    Text = (function(_React$Component2) {
      function Text(props) {
        var _this2 = _React$Component2.call(this, props) || this;
        ["height", "width", "x", "y"].forEach(function(key) {
          Object.defineProperty(_assertThisInitialized(_this2), key, {
            get: function() {
              return this._text ? this._text[key] : void 0;
            }
          });
        });
        return _this2;
      }
      _inheritsLoose(Text, _React$Component2);
      Text.prototype.render = function() {
        var _this3 = this;
        return React.createElement(
          TYPES.TEXT,
          _extends({}, this.props, {
            ref: function(t) {
              return (_this3._text = t);
            }
          }),
          childrenAsString(this.props.children)
        );
      };
      return Text;
    })(React.Component);
  (function(devToolsConfig) {
    var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
    return injectInternals(
      _assign({}, devToolsConfig, {
        overrideHookState: null,
        overrideProps: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
        findHostInstanceByFiber: function(fiber) {
          fiber = findCurrentHostFiber(fiber);
          return null === fiber ? null : fiber.stateNode;
        },
        findFiberByHostInstance: function(instance) {
          return findFiberByHostInstance
            ? findFiberByHostInstance(instance)
            : null;
        },
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
      })
    );
  })({
    findFiberByHostInstance: function() {
      return null;
    },
    bundleType: 0,
    version: "16.8.6",
    rendererPackageName: "react-art"
  });
  return {
    ClippingRectangle: TYPES.CLIPPING_RECTANGLE,
    Group: TYPES.GROUP,
    Shape: TYPES.SHAPE,
    Path: current.Path,
    LinearGradient: LinearGradient,
    Pattern: Pattern,
    RadialGradient: RadialGradient,
    Surface: Surface,
    Text: Text,
    Transform: transform
  };
});

/** @license React vundefined
 * react-debug-tools.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";
var ErrorStackParser = require("error-stack-parser"),
  React = require("react"),
  getOwnPropertySymbols = Object.getOwnPropertySymbols,
  hasOwnProperty = Object.prototype.hasOwnProperty,
  propIsEnumerable = Object.prototype.propertyIsEnumerable,
  objectAssign = (function() {
    try {
      if (!Object.assign) return !1;
      var test1 = new String("abc");
      test1[5] = "de";
      if ("5" === Object.getOwnPropertyNames(test1)[0]) return !1;
      var test2 = {};
      for (test1 = 0; 10 > test1; test1++)
        test2["_" + String.fromCharCode(test1)] = test1;
      if (
        "0123456789" !==
        Object.getOwnPropertyNames(test2)
          .map(function(n) {
            return test2[n];
          })
          .join("")
      )
        return !1;
      var test3 = {};
      "abcdefghijklmnopqrst".split("").forEach(function(letter) {
        test3[letter] = letter;
      });
      return "abcdefghijklmnopqrst" !==
        Object.keys(Object.assign({}, test3)).join("")
        ? !1
        : !0;
    } catch (err) {
      return !1;
    }
  })()
    ? Object.assign
    : function(target, source) {
        if (null === target || void 0 === target)
          throw new TypeError(
            "Object.assign cannot be called with null or undefined"
          );
        var to = Object(target);
        for (var symbols, s = 1; s < arguments.length; s++) {
          var from = Object(arguments[s]);
          for (var key in from)
            hasOwnProperty.call(from, key) && (to[key] = from[key]);
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++)
              propIsEnumerable.call(from, symbols[i]) &&
                (to[symbols[i]] = from[symbols[i]]);
          }
        }
        return to;
      },
  ReactSharedInternals =
    React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher") ||
  (ReactSharedInternals.ReactCurrentDispatcher = { current: null });
ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig") ||
  (ReactSharedInternals.ReactCurrentBatchConfig = { suspense: null });
var hookLog = [],
  primitiveStackCache = null;
function getPrimitiveStackCache() {
  if (null === primitiveStackCache) {
    var cache = new Map();
    try {
      Dispatcher.useContext({ _currentValue: null }),
        Dispatcher.useState(null),
        Dispatcher.useReducer(function(s) {
          return s;
        }, null),
        Dispatcher.useRef(null),
        Dispatcher.useLayoutEffect(function() {}),
        Dispatcher.useEffect(function() {}),
        Dispatcher.useImperativeHandle(void 0, function() {
          return null;
        }),
        Dispatcher.useDebugValue(null),
        Dispatcher.useCallback(function() {}),
        Dispatcher.useMemo(function() {
          return null;
        });
    } finally {
      var readHookLog = hookLog;
      hookLog = [];
    }
    for (var i = 0; i < readHookLog.length; i++) {
      var hook = readHookLog[i];
      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));
    }
    primitiveStackCache = cache;
  }
  return primitiveStackCache;
}
var currentHook = null;
function nextHook() {
  var hook = currentHook;
  null !== hook && (currentHook = hook.next);
  return hook;
}
var Dispatcher = {
    readContext: function(context) {
      return context._currentValue;
    },
    useCallback: function(callback) {
      var hook = nextHook();
      hookLog.push({
        primitive: "Callback",
        stackError: Error(),
        value: null !== hook ? hook.memoizedState[0] : callback
      });
      return callback;
    },
    useContext: function(context) {
      hookLog.push({
        primitive: "Context",
        stackError: Error(),
        value: context._currentValue
      });
      return context._currentValue;
    },
    useEffect: function(create) {
      nextHook();
      hookLog.push({ primitive: "Effect", stackError: Error(), value: create });
    },
    useImperativeHandle: function(ref) {
      nextHook();
      var instance = void 0;
      null !== ref && "object" === typeof ref && (instance = ref.current);
      hookLog.push({
        primitive: "ImperativeHandle",
        stackError: Error(),
        value: instance
      });
    },
    useDebugValue: function(value, formatterFn) {
      hookLog.push({
        primitive: "DebugValue",
        stackError: Error(),
        value: "function" === typeof formatterFn ? formatterFn(value) : value
      });
    },
    useLayoutEffect: function(create) {
      nextHook();
      hookLog.push({
        primitive: "LayoutEffect",
        stackError: Error(),
        value: create
      });
    },
    useMemo: function(nextCreate) {
      var hook = nextHook();
      nextCreate = null !== hook ? hook.memoizedState[0] : nextCreate();
      hookLog.push({
        primitive: "Memo",
        stackError: Error(),
        value: nextCreate
      });
      return nextCreate;
    },
    useReducer: function(reducer, initialArg, init) {
      reducer = nextHook();
      initialArg =
        null !== reducer
          ? reducer.memoizedState
          : void 0 !== init
            ? init(initialArg)
            : initialArg;
      hookLog.push({
        primitive: "Reducer",
        stackError: Error(),
        value: initialArg
      });
      return [initialArg, function() {}];
    },
    useRef: function(initialValue) {
      var hook = nextHook();
      initialValue =
        null !== hook ? hook.memoizedState : { current: initialValue };
      hookLog.push({
        primitive: "Ref",
        stackError: Error(),
        value: initialValue.current
      });
      return initialValue;
    },
    useState: function(initialState) {
      var hook = nextHook();
      initialState =
        null !== hook
          ? hook.memoizedState
          : "function" === typeof initialState
            ? initialState()
            : initialState;
      hookLog.push({
        primitive: "State",
        stackError: Error(),
        value: initialState
      });
      return [initialState, function() {}];
    },
    useResponder: function(responder, listenerProps) {
      hookLog.push({
        primitive: "Responder",
        stackError: Error(),
        value: {
          responder: responder.displayName || "EventResponder",
          props: listenerProps
        }
      });
      return { responder: responder, props: listenerProps };
    }
  },
  mostLikelyAncestorIndex = 0;
function findSharedIndex(hookStack, rootStack, rootIndex) {
  var source = rootStack[rootIndex].source,
    i = 0;
  a: for (; i < hookStack.length; i++)
    if (hookStack[i].source === source) {
      for (
        var a = rootIndex + 1, b = i + 1;
        a < rootStack.length && b < hookStack.length;
        a++, b++
      )
        if (hookStack[b].source !== rootStack[a].source) continue a;
      return i;
    }
  return -1;
}
function isReactWrapper(functionName, primitiveName) {
  if (!functionName) return !1;
  primitiveName = "use" + primitiveName;
  return functionName.length < primitiveName.length
    ? !1
    : functionName.lastIndexOf(primitiveName) ===
        functionName.length - primitiveName.length;
}
function parseCustomHookName(functionName) {
  if (!functionName) return "";
  var startIndex = functionName.lastIndexOf(".");
  -1 === startIndex && (startIndex = 0);
  "use" === functionName.substr(startIndex, 3) && (startIndex += 3);
  return functionName.substr(startIndex);
}
function buildTree(rootStack$jscomp$0, readHookLog) {
  for (
    var rootChildren = [],
      prevStack = null,
      levelChildren = rootChildren,
      nativeHookID = 0,
      stackOfChildren = [],
      i = 0;
    i < readHookLog.length;
    i++
  ) {
    var hook = readHookLog[i];
    var rootStack = rootStack$jscomp$0,
      hook$jscomp$0 = hook;
    var stack = ErrorStackParser.parse(hook$jscomp$0.stackError);
    b: {
      var hookStack = stack,
        rootIndex = findSharedIndex(
          hookStack,
          rootStack,
          mostLikelyAncestorIndex
        );
      if (-1 !== rootIndex) rootStack = rootIndex;
      else {
        for (
          var i$jscomp$0 = 0;
          i$jscomp$0 < rootStack.length && 5 > i$jscomp$0;
          i$jscomp$0++
        )
          if (
            ((rootIndex = findSharedIndex(hookStack, rootStack, i$jscomp$0)),
            -1 !== rootIndex)
          ) {
            mostLikelyAncestorIndex = i$jscomp$0;
            rootStack = rootIndex;
            break b;
          }
        rootStack = -1;
      }
    }
    b: {
      hookStack = stack;
      rootIndex = getPrimitiveStackCache().get(hook$jscomp$0.primitive);
      if (void 0 !== rootIndex)
        for (
          i$jscomp$0 = 0;
          i$jscomp$0 < rootIndex.length && i$jscomp$0 < hookStack.length;
          i$jscomp$0++
        )
          if (rootIndex[i$jscomp$0].source !== hookStack[i$jscomp$0].source) {
            i$jscomp$0 < hookStack.length - 1 &&
              isReactWrapper(
                hookStack[i$jscomp$0].functionName,
                hook$jscomp$0.primitive
              ) &&
              i$jscomp$0++;
            i$jscomp$0 < hookStack.length - 1 &&
              isReactWrapper(
                hookStack[i$jscomp$0].functionName,
                hook$jscomp$0.primitive
              ) &&
              i$jscomp$0++;
            hook$jscomp$0 = i$jscomp$0;
            break b;
          }
      hook$jscomp$0 = -1;
    }
    stack =
      -1 === rootStack || -1 === hook$jscomp$0 || 2 > rootStack - hook$jscomp$0
        ? null
        : stack.slice(hook$jscomp$0, rootStack - 1);
    if (null !== stack) {
      hook$jscomp$0 = 0;
      if (null !== prevStack) {
        for (
          ;
          hook$jscomp$0 < stack.length &&
          hook$jscomp$0 < prevStack.length &&
          stack[stack.length - hook$jscomp$0 - 1].source ===
            prevStack[prevStack.length - hook$jscomp$0 - 1].source;

        )
          hook$jscomp$0++;
        for (
          prevStack = prevStack.length - 1;
          prevStack > hook$jscomp$0;
          prevStack--
        )
          levelChildren = stackOfChildren.pop();
      }
      for (
        prevStack = stack.length - hook$jscomp$0 - 1;
        1 <= prevStack;
        prevStack--
      )
        (hook$jscomp$0 = []),
          levelChildren.push({
            id: null,
            isStateEditable: !1,
            name: parseCustomHookName(stack[prevStack - 1].functionName),
            value: void 0,
            subHooks: hook$jscomp$0
          }),
          stackOfChildren.push(levelChildren),
          (levelChildren = hook$jscomp$0);
      prevStack = stack;
    }
    stack = hook.primitive;
    hook$jscomp$0 =
      "Context" === stack || "DebugValue" === stack ? null : nativeHookID++;
    levelChildren.push({
      id: hook$jscomp$0,
      isStateEditable: "Reducer" === stack || "State" === stack,
      name: stack,
      value: hook.value,
      subHooks: []
    });
  }
  processDebugValues(rootChildren, null);
  return rootChildren;
}
function processDebugValues(hooksTree, parentHooksNode) {
  for (var debugValueHooksNodes = [], i = 0; i < hooksTree.length; i++) {
    var hooksNode = hooksTree[i];
    "DebugValue" === hooksNode.name && 0 === hooksNode.subHooks.length
      ? (hooksTree.splice(i, 1), i--, debugValueHooksNodes.push(hooksNode))
      : processDebugValues(hooksNode.subHooks, hooksNode);
  }
  null !== parentHooksNode &&
    (1 === debugValueHooksNodes.length
      ? (parentHooksNode.value = debugValueHooksNodes[0].value)
      : 1 < debugValueHooksNodes.length &&
        (parentHooksNode.value = debugValueHooksNodes.map(function(_ref) {
          return _ref.value;
        })));
}
function inspectHooks(renderFunction, props, currentDispatcher) {
  null == currentDispatcher &&
    (currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher);
  var previousDispatcher = currentDispatcher.current;
  currentDispatcher.current = Dispatcher;
  try {
    var ancestorStackError = Error();
    renderFunction(props);
  } finally {
    (renderFunction = hookLog),
      (hookLog = []),
      (currentDispatcher.current = previousDispatcher);
  }
  currentDispatcher = ErrorStackParser.parse(ancestorStackError);
  return buildTree(currentDispatcher, renderFunction);
}
function restoreContexts(contextMap) {
  contextMap.forEach(function(value, context) {
    return (context._currentValue = value);
  });
}
var ReactDebugTools = {
    inspectHooks: inspectHooks,
    inspectHooksOfFiber: function(fiber, currentDispatcher) {
      null == currentDispatcher &&
        (currentDispatcher = ReactSharedInternals.ReactCurrentDispatcher);
      if (0 !== fiber.tag && 15 !== fiber.tag && 11 !== fiber.tag)
        throw Error(
          "Unknown Fiber. Needs to be a function component to inspect hooks."
        );
      getPrimitiveStackCache();
      var type = fiber.type,
        props = fiber.memoizedProps;
      if (type !== fiber.elementType && type && type.defaultProps) {
        props = objectAssign({}, props);
        var defaultProps = type.defaultProps;
        for (propName in defaultProps)
          void 0 === props[propName] &&
            (props[propName] = defaultProps[propName]);
      }
      currentHook = fiber.memoizedState;
      var propName = new Map();
      try {
        for (defaultProps = fiber; defaultProps; ) {
          if (10 === defaultProps.tag) {
            var context = defaultProps.type._context;
            propName.has(context) ||
              (propName.set(context, context._currentValue),
              (context._currentValue = defaultProps.memoizedProps.value));
          }
          defaultProps = defaultProps.return;
        }
        if (11 === fiber.tag) {
          var renderFunction = type.render;
          type = props;
          var ref = fiber.ref;
          fiber = currentDispatcher;
          var previousDispatcher = fiber.current;
          fiber.current = Dispatcher;
          try {
            var ancestorStackError = Error();
            renderFunction(type, ref);
          } finally {
            var readHookLog = hookLog;
            hookLog = [];
            fiber.current = previousDispatcher;
          }
          var rootStack = ErrorStackParser.parse(ancestorStackError);
          return buildTree(rootStack, readHookLog);
        }
        return inspectHooks(type, props, currentDispatcher);
      } finally {
        (currentHook = null), restoreContexts(propName);
      }
    }
  },
  ReactDebugTools$1 =
    (ReactDebugTools && ReactDebugTools["default"]) || ReactDebugTools;
module.exports = ReactDebugTools$1.default || ReactDebugTools$1;
